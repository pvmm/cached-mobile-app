


                   С О Д Е Р Ж А Н И Е


  ВВЕДЕНИЕ   ........................................  1

            ЧАСТЬ 1. РАБОТА С СИСТЕМОЙ.

  Глава 1. С ЧЕГО НАЧАТЬ.  ..........................  1

  Глава 2. ОСНОВНОЕ МЕНЮ.  ..........................  2

    2.1. Изображение на экране  .....................  2
    2.2. Файл EP.CFG  ...............................  2
    2.3. Команды основного меню.
      2.3.1. Initialize disk system  ................  3
      2.3.2. Default drive user  ....................  3
      2.3.3. Main file  .............................  3
      2.3.4. Work file  .............................  3
      2.3.5. Edit  ..................................  4
      2.3.6. Pick  ..................................  4
      2.3.7. Save  ..................................  4
      2.3.8. Verify  ................................  5
      2.3.9. Compile  ...............................  5
      2.3.10. Run  ..................................  6
      2.3.11. Quit ..................................  6
      2.3.12. Help ..................................  6
      2.3.13. Find run-time error  ..................  6
      2.3.14. Compile to Disk/Memory  ...............  7
      2.3.15. Parameter string  .....................  7
      2.3.16. BAK-copy  .............................  7
      2.3.17. Verify on/off  ........................  7
      2.3.18. Autosave EP.CFG on/off  ...............  7
      2.3.19. Default EP.CFG  .......................  7
      2.3.20. Restore EP.CFG ........................  7
      2.3.21. Save EP.CFG  ..........................  7
    2.4. Ошибки при работе с диском  ................  7

  Глава 4. КОМПИЛЯЦИЯ ПРОГРАММЫ И ПОИСК ОШИБОК.

    4.1. Компиляция программы  ......................  8
    4.2. Поиск позиции. Ошибки периода исполнения....  9

  Глава 5. ВЫПОЛНЕНИЕ СКОМПИЛИРОВАННОЙ ПРОГРАММЫ.....  9

  Глава 6. ОПТИМИЗАЦИЯ КОДА.

    6.1. Оптимизация кода операторов ................ 11
    6.2. Устранение кода неиспользуемых процедур .... 11
    6.3. Совмещение памяти .......................... 12
    6.4. Вычисление константных выражений ........... 12
    6.5. Локальная оптимизация кода ................. 13

            ЧАСТЬ 2. ОПИСАНИЕ ЯЗЫКА.

  Глава 1. ЛЕКСЕМЫ И КОНСТАНТЫ.

    1.1. Спец.символы и зарезервированные слова  .... 13
    1.2. Идентификаторы ............................. 13
    1.3. Метки  ..................................... 14
    1.4. Числовые константы ......................... 14
    1.5. Строки символов  ........................... 14
    1.6. Описание константы  ........................ 14
    1.7. Комментарии  ............................... 14
    1.8. Строки программы ........................... 14

  Глава 2. БЛОКИ И ОБЛАСТИ ВИДИМОСТИ.

    2.1. Синтаксис  ................................. 14
    2.2. Блоки и правила видимости  ................. 15
    2.3. Видимость идентификаторов, описанных
                                      в модулях  .... 15
    2.4. Описатель private  ......................... 15

  Глава 3. ТИПЫ.

    3.1. Простые типы  .............................. 16
      3.1.1. Упорядоченные типы  .................... 16
      3.1.2. Вещественный тип (Real) ................ 17
    3.2. Строковые типы  ............................ 17
    3.3. Составные типы  ............................ 17
      3.3.1. Тип массива  ........................... 17
      3.3.2. Тип записи  ............................ 18
      3.3.3. Тип множества .......................... 19
      3.3.4. Тип файла  ............................. 19
    3.4. Типы указателей  ........................... 19
    3.5. Идентичные и совместимые типы .............. 19
      3.5.1. Идентичность типов  .................... 19
      3.5.2. Совместимость типов .................... 20
      3.5.3. Совместимость относительно присваивания  20
      3.5.4. Раздел описания типов  ................. 20

  Глава 4. ПЕРЕМЕННЫЕ.

    4.1. Описание переменных  ......................  20
      4.1.1. Abolute - конструкция .................  20
    4.2. Ссылка на переменную  .....................  21
    4.3. Квалификаторы  ............................  21
      4.3.1. Массивы, строки и индексы .............  22
      4.3.2. Записи и селекторы полей  .............  22
      4.3.3. Указатели и динамические переменные ...  22
    4.4. Преобразователь типа переменной ...........  22

  Глава 5. ТИПИЗИРОВАННЫЕ КОНСТАНТЫ.

    5.1. Типизированные константы простых типов ....  23
    5.2. Типизированные константы строкового типа ..  23
    5.3. Типизированные константы составных типов ..  23
      5.3.1. Типизированные константы типа массивов   23
      5.3.2. Типизированные константытипа записи ...  23
      5.3.3. Типизированные константы типа множества  23
    5.4. Типизированные константы указательного типа  24

  Глава 6. ВЫРАЖЕНИЯ.

   6.1. Синтаксис выражений  .......................  24
   6.2. Операции  ..................................  25
     6.2.1. Арифметические операции  ...............  25
     6.2.2. Логические операции  ...................  26
     6.2.3. Булевские операции  ....................  26
     6.2.4. Операции над строками  .................  26
     6.2.5. Операции над множествами  ..............  26
     6.2.6. Операции сравнения  ....................  26
     6.2.7. Операция @  ............................  27
   6.3. Вызов функции  .............................  27
   6.4. Конструктор множества  .....................  27
   6.5. Преобразователь типа выражения  ............  27

  Глава 7. ОПЕРАТОРЫ.

   7.1. Простые операторы  .........................  28
     7.1.1. Оператор присваивания  .................  28
     7.1.2. Вызов процедуры  .......................  28
     7.1.3. Оператор перехода  .....................  28
     7.1.4. Оператор inline  .......................  28
   7.2. Структурные операторы  .....................  29
     7.2.1. Составной оператор  ....................  29
     7.2.2. Условные операторы  ....................  29
     7.2.3. Операторы цикла  .......................  30
     7.2.4. Оператор with  .........................  31

  Глава 8. ПРОЦЕДУРЫ И ФУНКЦИИ.

   8.1. Описание процедуры  ........................  31
   8.2. Описание функции  ..........................  32
   8.3. Параметры ..................................  32
     8.3.1. Параметры, передаваемые по значению ....  32
     8.3.2. Параметры, передаваемые по ссылке  .....  32
     8.3.3. Нетипизированные параметры  ............  33
   8.4. Forward - описание  ........................  33
   8.5. Рекурсивные процедуры и функции  ...........  33

  Глава 9. ПРОГРАММЫ И МОДУЛИ.

   9.1. Программы  .................................  33
     9.1.1. Предложение  uses  .....................  33
   9.2. Модули  ....................................  34

  Глава 10. ВВОД И ВЫВОД.

   10.1. Общие замечания  ..........................  34
   10.2. Виды файлов  ..............................  35
     10.2.1. Типизированные файлы  .................  35
     10.2.2. Нетипизированные файлы  ...............  35
     10.2.3. Текстовые файлы  ......................  35
   10.3. Стандартные процедуры и функции
                                  ввода-вывода .....  36
   10.4. Форматные преобразования при работе
                            с текстовыми файлами ...  37
   10.5. Имена дисковых файлов  ....................  38
   10.6. Устройства в языке EP  ....................  38
   10.7. Ввод и вывод информации при работе
                              с устройством CON ....  38
   10.8. Предопределенные файлы  ...................  38

  Глава 12. ДИРЕКТИВЫ КОМПИЛЯТОРА.

   12.1. Директивы-переключатели  ..................  39
   12.2. Параметрические директивы  ................  40

  Глава 13. ВНУТРЕННЕЕ УСТРОЙСТВО.

   13.1. Распределение памяти  .....................  41
   13.2. Внутренние форматы данных  ................  41
   13.3. Соглашение о связях  ......................  43
   13.4. Управление кучей  .........................  44
   13.5. Прямые обращения к памяти и портам  .......  44
   13.6. Процедуры выхода ..........................  44
   13.7. Реализация рекурсивных процедур  ..........  45
   13.8. Прочие замечания ..........................  45
     13.8.1. Генерация и оптимизация кода  .........  45
     13.8.2. Работа с датчиком случайных чисел  ....  45
     13.8.3. Вызов функции BDOS и BIOS  ............  46
     13.8.4. Работа с системой прерываний  .........  46
     13.8.5. Подключение фрагментов на ассемблере ..  46

  Глава 14. СТАНДАРТНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ.   .....  47

       Abs, Addr, Append, ArcTan, Assign   .........  47
       BDOS, BIOS, BlockRead  ......................  48
       BlockWrite, Break, ChDir, CheckStack, Chr ...  49
       Circle, Close, ClrGScr, ClrScr, Concat,
       Copy, Cos, Dec  .............................  50
       Delay, Delete, DiskFree, DiskSize, Eof,
       Eoln, Erase  ................................  51
       Exit, Exp, FilePos, FileSize, FillChar, Frac   52
       GetDir, GetMem, GetPixel, GotoXY,
       Halt, Hi, Inc, Insert, Int  .................  53
       IOResult, KeyPressed, Length,
       Line, Ln, Lo, Mark  .........................  54
       MemAvail, Move, New, Odd,
       Ord, ParamCount, ParamStr  ..................  55
       Pi, Pos, Pred, Ptr, PutPixel, Random  .......  56
       Randomize, Read, READ  ......................  57
       ReadKey, ReadKeyExt, Readln,
       Rectangle, Release  .........................  58
       Rename, Reset, Rewrite  .....................  59
       Round, Seek, SeekEof, SeekEoln, SetColor ....  60
       Sin, SizeOf, Sqr, Sqrt, Str,
       Succ, Swap, Trunc, Truncate  ................  61
       UpCase, Val, Write, WRITE, Writeln  .........  62

  Приложение А. ОТЛИЧИЯ ОТ СИСТЕМЫ
                              Turbo PASCAL v.4.0 ...  63

  Приложение Б. СООБЩЕНИЯ OБ ОШИБКАХ  ..............  63


                        ВВЕДЕНИЕ


   Описываемая в этой книге система EXPRESS PASCAL (EP)  есть
система программирования на  языке  PASCAL  для  ПЭВМ  Корвет
ПК8020.
   EP представляет собой интегрированную систему,  включающую
редактор текстов, компилятор и  библиотеку  процедур  времени
исполнения.
   Работая с системой EP, вы можете, не выходя в  ОС,  ввести
текст программы скомпилировать ее и выполнить; вы можете так-
же записать скомпилированную программу на диск, и  далее  ис-
пользовать ее как самостоятельную  программу  -  без  участия
системы EP.
   Если компилятор обнаруживает ошибку в компилируемой  прог-
рамме, то система автоматически переключается в режим  редак-
тирования текста, и текущая пзиция редактора  устанавливается
в той точке, где компилятор обнаружил ошибку.  Все,  что  вам
нужно теперь сделать - это понять, в  чем  причина  ошибки  и
исправить ее. Для небольших программ (до 500 строк  исходного
текста) время, затрачиваемое на цикл  "компиляция-обнаружение
ошибки-исправление  ошибки-повторная  компиляция"  составляет
менее 1 мин.
   При определении входного языка мы выбрали в  качестве  об-
разца входной язык компилятора TURBO PASCAL фирмы BORLAND IN-
TERNATIONAL для IBM PC, версия 4.0 и достигли  здесь  полного
успеха: с точностью до  машиннозависимых  деталей  языка  наш
компилятор совместим с компилятором TURBO PASCAL версия  4.0.
Отличия в машинно-зависимых компонентах языка связаны  в  ос-
новном с тем, что в процессорах серии 8086 полный адрес памя-
ти 4-байтовый, а в процессоре 8080 - 2-байтовый. Если в вашей
программе для IBM PC не используется непосредственная адреса-
ция памяти и нет непосредственных обращений к OС , вы  можете
скомпилировать ее с помощью компилятора EP без всяких переде-
лок.
   Более того, язык EP содержит ряд расширений по сравнению с
языком TURBO PASCAL версия 4.0. Основное  из  них  состоит  в
том, что в языке EP допускаются константные выражения  везде,
где по синтаксиссу PASCAL'я допускается константа. У кого  из
программистов не возникало желание включить в свою  программу
фрагменты вроде:

           const ScreenStr      =16;
                 ScreenCol      =64;

                 ScreenSize     =ScreenStr*ScreenCol;

или:

           const nr-of-elem =10;
           type arr-of-elem=array [0...nr-of-elem-1] of real;

В языке EP это допустимая конструкция.
   Второе расширение, на которое мы хотели бы обратить внима-
ние - это конструкция private. Зарезервированное слово priva-
te может появиться перед описанием констант, типов,  перемен-
ных, процедур или функций в interface-части модуля (init).  В
таком случае идентификаторы, описанные в соответствующем опи-
сании, становятся невидимыми из модулей и программ, использу-
ющих данный модуль. Это полезно, например, в случае, когда  в
модуле вы хотите описать тип, внутреннее устройство  которого
должно быть недоступно использующей модуль  программе  (прог-
рамма может только создавать переменные такого типа,  переда-
вать их в качестве параметров процедурам модуля, но не  может
изменять значения этих переменных).
   Код, генерируемый компилятором EP, на 20 - 30%  компактнее
кода, генерируемого  компилятором  TURBO  PASCAL  версия  2.0
(Z80). Это достигается за счет использования в компиляторе EP
пяти уровней оптимизации: оптимизация частных случаев  струк-
турных операторов, устранение не используемого кода, вычисле-
ние константных подвыражений на этапе компиляции,  совмещение
памяти для локальных переменных процедур и функций и  локаль-
ная оптимизация кода.
   Скорость компиляции составляет около 2000 строк  исходного
текста в мин. при компиляции небольших программ, помещающихся
в памяти, и около 800 строк  в  мин.,  когда  исходный  текст
программы читается с диска.
   Благодаря тому, что память для всех  строящихся  в  период
компиляции таблиц распределяется динамически, EP не  наклады-
вает на программу никаких ограничений  вроде  "не  более  100
процедур и функций" или "не более 50  одновременно  использу-
емых типов" и т.д. Единственное ограничение носит  интеграль-
ный характер: должно хватать памяти для  динамических  таблиц
компилятора. Это означает, что ваша программа может иметь  до
500...1000  одновременно  доступных  идентификаторов  (точную
цифру назвать невозможно, т.к. расходуемая память определяет-
ся длиной и видом  идентификатора).  "Одновременно  доступных
идентификаторов" не то же самое, что "общее количество  иден-
тификаторов": ваша программа, например, может  содержать  100
процедур, в каждой из которых определяется по  100  локальных
идентификаторов; никаких проблем при компиляции  такой  прог-
раммы не возникнет.
   Объем результата компиляции (COM-файла) около 40 Кб близко
к границе возможностей Корвета.
   При работе с системой EP вам не нужен  отдельный  редактор
связей: все необходимые действия выполняет компилятор. Порож-
даемый им при компиляции на диск COM-файл готов к работе  без
всяких дальнейших доделок.
   Редактор текстов, входящий в состав системы EP -  один  из
лучщих на Корвете. Простота работы с ним, богатый набор  опе-
раций над текстом и уникальная быстрота их выполнения достав-
ляет удовлетворение и новичку, и профессионалу.
   Расширения языка EP по сравнению со стандартом языка  PAS-
CAL придают ему гибкость, достаточную для системных  примене-
ний. В целом, мы считаем, что система EP обеспечивает широкий
спектр приложений - от обучения программированию до системно-
го программирования.
   Документация состоит из двух частей и четырех приложений.

   В первой части описывается работа с системой. Мы  рекомен-
дуем сначала прочитать ее целиком - чтобы вы  получили  пред-
ставление о возможностях, которые предоставляет вам  система.
Не нужно стремиться сразу все запомнить - поймите для начала,
что вы можете, и начинайте работать с системой  за  компьюте-
ром; по мере того, как у вас станут возникать вопросы,  обра-
щайтесь снова к этой части.
   Во второй части приводится формальное описание  языка  EP.
Она ни в коей мере не претендует на  роль  учебника  по  PAS-
CAL'ю; для этого воспользуйтесь какой-нибудь  другой  книгой.
Но она дает полную информацию о языке и содержит много приме-
ров - особенно для  конструкций,  являющихся  расширением  по
сравнению со стандартом языка. В этой части следует первооче-
редное внимание уделить описанию стандартных процедур и  фун-
кций, входящих в состав библиотеки времени исполнения.  Озна-
комьтесь также со списком предопределенных типов, констант  и
переменных. Тем, кто собирается писать  системные  программы,
предназначена здесь глава, описывающая внутреннее устройство:
форматы представления данных и способы реализации конструкций
языка.
   Приложения содержат сравнение с языком TURBO PASCAL версия
4.0, список сообщений об ошибках, выдаваемых  компилятором  и
процедурами времени исполнения, список команд редактора  тек-
стов и таблицу ASCII - кодов литер.




                        ЧАСТЬ 1

           Р А Б О Т А   С   С И С Т Е М О Й



   ГЛАВА 1.

   С ЧЕГО НАЧАТЬ

   1.1. Что нужно для работы.

   Итак, вы стали обладателем системы EP. Вы имеете диск,  на
котором находятся три файла:  EP.COM,  EP.MSG,  EP.HLP.  Файл
EP.COM - собственно система; в нем содержится  редактор  тек-
стов, компилятор и библиотека  процедур  времени  исполнения.
Файл EP.MSG содержит  выдаваемые  компилятором  сообщения  об
ошибках. Файл EP.HLP содержит подсказки,  которые  вы  можете
просматривать на экране во время работы с системой.
   Возможно,на вашей дискетте есть  еще  файл  README.DOC.  В
этом файле (если он есть) содержится описание последних изме-
нений в системе, которые еще не нашли  отражения  в  основной
документации.
   Со временем на вашей рабочей дискетте  появится  еще  один
файл - EP.CFG, конфигурационный файл. Что он содержит  и  для
чего нужен, вы узнаете из дальнейшего.


   1.3. Общие замечания о работе системы.

   В процессе работы  система  использует  всю  имеющуюся  на
компьютере память.
   В основной памяти располагается сама система EP. В  остав-
шейся не занятой ею области (около 15 Кб) размещаются:  теку-
щий рабочий файл - исходный текст программы, с которой вы ра-
ботаете; скомпилированная программа и ее  рабочие  поля  (при
компиляции программы в память); рабочие таблицы компилятора в
период выполнения компиляции. Подробно распределение этой па-
мяти описано в главе 13 части 2.
   Кроме этого, EP использует графическую память (память гра-
фического экрана; ее на Корвете имеется 48 К). В период рабо-
ты редактора текстов в графической  памяти  хранится  рабочая
информация редактора: макрокоманды, склад  символов  и  склад
строк. В период работы компилятора в графическую память поме-
щается код скомпилированной программы; только после успешного
завершения компиляциии он переносится в основную  память  или
на диск. В период исполнения скомпилированной программы  гра-
фическая память ничем не занята, и может быть использована по
прямому назначению - для вывода на графический экран. При ра-
боте с графической памятью EP, разумеется, подготавливает  ее
так, чтобы содержимое ее не отображалось на экране,  так  что
ничего лишнего вы там не увидите.


   ГЛАВА 2

   ОСНОВНОЕ МЕНЮ

   Итак, вы начали работать с системой EP. Первым делом у вас
на экране появится заставка:


           E X P R E S S
            P A S C A L

      v.2.0            15.03.91
      Корвет ПК8020    CP/M-80
            (с) mkSoft


include error messages? (Y/N)

   EP сообщает вам, что работа начата, и задает  первый  воп-
рос: нужно ли загружать модуль с сообщениями  об  ошибках.  В
ответ вы должны нажать клавишу Y (модуль  будет  загружаться)
или N (модуль не будет загружаться).
   Появление этого вопроса связано с тем,  что  Корвет  имеет
довольно мало памяти. Модуль сообщений занимает около 1.5 К -
и на эту величину уменьшается при его загрузке доступная  для
размещения исходного текста и скомпилированной программы  па-
мять. Если же вы откажетесь от загрузки модуля сообщений,  то
при обнаружении компилятором ошибки в программе  будет  выда-
ваться только ее номер - без текстового сообщения.  Мы  реко-
мендуем загружать модуль сообщений -  во  всяком  случае,  на
первых порах, пока вы не освоите хорошо  работу  с  системой.
Проблемы с памятью у вас возникнут, если вы захотите  держать
в памяти исходный текст размером 500 строк и  более;  в  этом
случае вам, возможно, придется отказаться от загрузки  модуля
сообщений. Однако, и здесь мы рекомендуем вам воспользоваться
другой возможностью: вынести часть исходного текста в  inclu-
de-файл (include-файлы и необходимая для их использования ди-
ректива компилятора (sI имя файла) описаны в главе  12  части
2.
   Если вы утвердительно ответили на вопрос о загрузке модуля
сообщений, то в третей снизу строке экрана  появится  сообще-
ние:

   Loading EP.MSG

система информирует вас о том, что в данный момент выполняет-
ся загрузка файла EP.MSG. Как только загрузка завершится, это
сообщение исчезнет. (EP всегда информирует вас о  том,  какие
действия в данный момент он выполняет - особенно если  выпол-
нение дествия требует заметного времени).
   Если на дискетте нет файла EP.MSG, то в двух нижних  стро-
ках экрана появится сообщение:

   Error 4
   Press Esc

это сообщение о том, что файл не найден. Поскольку модуль со-
общений не загружен, это сообщение не расшифровано: узнать  в
такой ситуации, что означает сообщение об ошибке,  вы  можете
из  приложения Б. Для продолжения работы нажмите клавишу Esc.
   Далее EP пытается загрузить конфигурационный файл  EP.CFG.
При этом на экране появляется сообщение:

   Loading EP.CFG

Если вы запускаете систему в первый раз, то  такого  файла  у
вас на дискетте еще нет; поэтому ниже появится  сообщение  об
ошибке:

   Error 4: File not found (EP.CFG)
   Press Esc

Не беспокойтесь: ничего страшного в этом нет; нажмите клавишу
Esc (сообщение об ошибке исчезнет) и продолжайте работу.
   После окончания первого сеанса работы  с  редактором  файл
EP.CFG будет записан на диск, и при следующих  вызовах  такой
ошибки возникать уже не будет.
   Есливы работаете не в первый раз и  конфигурационный  файл
на дискете у вас есть, то после его загрузки  (скорее  всего)
начнется загрузка исходного текста программы,  с  которой  вы
работали последний раз. Это одно из удобств  работы,  которое
обеспечивает вам EP. Программа, с которой вы работали в  пос-
ледний раз, будет загружена; более того, текущая позиция  ре-
дактора останется там же, где она была - вы можете продолжать
работу, как будто вы и не покидали компьютер.
   О том, как выполняется загрузка исходного текста  програм-
мы, написано дальше в этой главе.
   После того, как выполнены все описанные действия, на экра-
не появляется основное меню системы. Описание  того,  что  вы
можете делать в этом режиме, посвящена настоящая глава.


   2.1. Что вы видите на экране.

   В режиме работы с основным меню вы видите на экране  такую
картинку:

     Express Pascal v.2.0 Корвет-CP/M-80 (c) mkSoft

Initialize disk system    /\Compile to Memory (Disk)
Default drive user: duu:
Main file: имя файла      /\Parameter string
Work file: имя файла        строка параметров

Edit Pic Save Varify      /\Bak-copy: np    /\Verify: np
Compile Run Quit Help     /\Autosave EP.CFG: np

Find run-time error       /\Default//\Restore//\Save EP.CFG


   Эта картинка занимает верхние 13 строк  экрана;  нижние  3
строки пустые (в процессе выполнения некоторых команд  основ-
ного меню в нижних строчках может появляться информация).
   Те поля, которые выделены на картинке кириллицей, содержат
переменную информацию (зависящую от  текущего  состояния).  В
полях, обозначенных np (Bak-copy, Verify, Autosave) может на-
ходиться либо On- режим включен, либо Off- режим выключен.  О
том, что может находиться в остальных полях,  выделенных  ки-
риллицей, сказано дальше при описании соответстсвующей коман-
ды основного меню.
   В основном меню представлены все  команды,  которые  умеет
выполнять EP. Основное меню разделено на две половины:  левую
и правую. На экране в названии каждой команды первая буква (в
левой половине) или литера /\ и первая буква (в правой  поло-
вине) выделены инвертированным цветом. Это означает. что  для
выполнения команды необходимо  нажать  клавишу  с  выделенной
буквой (при прижатой клавише Ctrl, если есть /\).  При  вводе
команды несущественно, какой регистр (РУС, ЛАТ, ВЕРХНИЙ, НИЖ-
НИЙ) включен в данный момент.
   При выполнении некоторых команд выдаются  вопросы,  иногда
может требоваться ввод параметров.  Во  всех  случаях,  когда
ожидается ввод с клавиатуры, вы можете нажать Esc: это приве-
дет к прекращению выполнения команды; никаких действий по на-
чатой команде выполнено не будет.
   При выполнении команд чтения с диска или записи  на  диск,
компиляции программы, поиска позиции ошибки времени  исполне-
ния и при выполнении скомпилированной программы вы  можете  в
произвольный момент прервать выполнение команды, нажав Ctrl+C
при этом операция остается выполненной частично.
   В настоящей главе описаны все команды системы EP,  которые
вы можете выполнить, находясь в основном меню. Команды описа-
ны в том порядке, в котором они перечислены в основном  меню.
Все необходимые понятия вводятся при описании соответствующих
команд.

   2.2. Файл EP.CFG

   При работе система EP находится в  каком-то  состоянии.  К
состоянию системы относится: имя главного файла; имя редакти-
руемого файла и позиция в нем; содержимое pick-таблицы; режим
компиляции (в память или на диск); строка  параметров;  режим
создания Bak-копий; режим проверки  текста  после  записи  на
диск; режим сохранения файла EP.CFG.
   При завершении работы системы EP состояние запоминается на
диске в файле EP.CFG. В начале  следующего  сеанса  работы  с
системой файл EP.CFG считывается с диска  и  EP  переходит  в
состояние, запомненное в этом файле. При этом в память считы-
вается исходный текст программы  (если  запомненное  в  файле
EP.CFG имя рабочего файла не пусто).  Т.о.,после  перерыва  в
работе вам нет нужды вспоминать, на чем вы закончили предыду-
щий сеанс: вы окажетесь ровно в том же состоянии,  в  котором
были перед завершением работы.
   Файл EP.CFG при загрузке системы ищется на текущем  диске,
и при выходе из системы записывается на текущий диск.  Будьте
поэтому внимательны, и, если вы в процессе работы меняете те-
кущий диск (командой Default drive user) , то перед  выполне-
нием команды выхода (Quit) убедитесь, что текущий диск - тот,
на котором вы хотите сохранить файл EP.CFG. Если вы вызываете
EP так:

А>b:ep

то EP будет загружен с диска b:, а файл EP.CFG  будет  искать
на диске а:. Если же вам нужно, чтобы файл EP.CFG  считывался
с диска b:, то введите:

А>b:
B>ep

- сначала сделайте дисковод b: ведущим, а затем  загрузите  с
него EP.
   Если в начале своей работы EP не находит файла EP.CFG,  то
формируется состояние по умолчанию: главный файл не объявлен,
исходного текста программы  нет,  pick-таблица  пуста,  режим
компиляции- в память, строка параметров пуста, режим создания
Bak- копий - не создавать, режим проверки текста после записи
на диск - проверять, режим сохранения файла EP.CFG  -  сохра-
нять.
   Вы можете отказаться от сохранения EP.CFG в  конце  работы
системы; такое мы вам рекомендуем делать, если возникшее сос-
тояние не представляет для вас интереса в дальнейшем.

   2.3. Команды основного меню.

   2.3.1. Initialize disk system
           - инициализировать дисковую систему.

   Для выполнения этой команды нужно нажать клавишу I.
   Наличие этой команды связано с некоторыми особенностями ОС
CP/M. CP/M следит за тем, какая дискетта находится в дисково-
де, и при смене дискетты автоматически переводит  дисковод  в
состояние "только чтение" (чтобы случайно не  испортить  дис-
кетту). Поэтому, если вам действительно необходимо записывать
отредактированный текст программы или скомпилированную  прог-
рамму на другую дискетту, вы  должны  после  установки  новой
дискетты выполнить команду Initialize disk system.
   Кроме того, дисковод  может  быть  переведен  в  состояние
"только чтение" и в результате некоторых ошибок при работе  с
диском. В этом случае для того,  чтобы  продолжить  работу  с
дискеттой, также нужно выполнить команду Initialize disk sys-
tem. Однако,в такой ситуации рекомендуем сначала  разобраться
в причине ошибки - иначе вы можете потерять данные.


   2.3.2. Default drive user
           - установить дисковод и номер пользователя,
             используемые по умолчанию

   Для выполнения этой команды нужно нажать клавишу D.
   При работе ОС CP/M определено понятие текущего дисковода -
т.е. того дисковода, на который  будет  производиться  запись
файлов и на котором будут искаться файлы для чтения, если яв-
но не указан другой. Также определено понятие текущего номера
пользователя. Команда Default drive user служит для изменения
этих параметров. В начале работы редактора текущие дисковод и
номер пользователя те, которые были определены при  работе  с
CP/M.
   Текущие дисковод и номер пользователя, которые установлены
в настоящий момент, указаны в строке  Default  drive  user  в
формате dnn: , где
   d - дисковод (обычно А или B,
   nn- номер пользователя.

   После того, как вы нажали D, вам предлагается отредактиро-
вать это 4-литерное поле; признак этого - появление курсора в
первой позиции поля. В процессе редактирования  вам  доступны
все возможности редактирования текста, они описаны  в  следу-
ющей главе. Если вам нужно полностью все поменять, то удобнее
будет сначала нажать /\D (команда редактора "стереть от теку-
щей позиции до конца строки") -  поле  при  этом  очистится,и
после этого ввести то, что вам нужно. Если же вам нужно поме-
нять одну литеру, подведите курсор к этой литере  и  замените
ее. Предостережем вас от одной ошибки. Редактор после загруз-
ки находится в режиме Insert - "вставка". В этом режиме, если
строка полностью заполнена, вставка символа при нажатии  бук-
венно-цифровой клавиши не производится - а у вас  всегда  ре-
дактируемое 4-литерное поле заполнено. Чтобы выполнить  необ-
ходимое вам действие, используйте Del (удалить  символ),  или
/\Del (режим "замена").
   Завершив редактирование поля, нажмите Cr - после этого бу-
дут установлены новые дисковод и номер пользователя. При  на-
жатии на Esc выполнение  команды  будет  прекращено;  текущие
дисковод и номер пользователя останутся прежними.
   Двоеточие в конце обязательно должно присутствовать.  Если
вы допустили какие - либо ошибки, то изменение параметров вы-
полнено не будет. Букву - обозначение дисковода можно вводить
на ВЕРХ и НИЖН регистрах, но  обязательно  на  ЛАТ.  Диапазон
букв А...P, номер пользователя - 0...15. Если будет определен
не существующий физически дисковод или в существующем не  бу-
дет дискетты, то произойдет зависание ОС и  исходные  данные,
не сохраненные на диск будут потеряны.

   2.3.3. Main file
           - главный файл

   Для выполнения этой команды нужно нажать клавишу М.
   Главный файл - это файл, содержащий исходный  текст  прог-
раммы, с которого должна начаться компиляция. При  выполнении
команды Compile проверяется, задан ли  главный  файл;  еслион
задан, то сначала главный файл делается рабочим (как это  де-
лается описано в следующем разделе) и только потом происходит
компиляция.
   Главный файл удобно использовать в тех случаях, когда ваша
программа разбита на несколько файлов, включаемых  в  один  с
помощью директивы компилятора {s1 имя файла}. В  этом  случае
файл, содержащий директивы {s1 имя  файла}  следует  объявить
главным, а тот файл, в который вы вносите изменения в  данный
момент - рабочим. Если же программа, с которой вы  работаете,
содержится в единственном файле, то необходимости пользовать-
ся командой Main file у вас нет; вам вполне будет  достаточно
команды Work file.
   Имя текущего главного файла находится в  основном  меню  в
строчке со словами Main file.
   После того, как вы нажали М, вам предлагается отредактиро-
вать 16-литерное поле с именем файла; признак этого - появле-
ние курсора в первой позиции поля. В процессе  редактирования
имени файла вам доступны все возможности редактирования  тек-
ста. Если вам нужно полностью  все  поменять,  удобнее  будет
воспользоваться /\D (команда редактора  "стереть  от  текущей
позиции до конца строки")- поле  при  этом  очистится,  после
этого введите новое имя.
   Завершив редактирование поля, нажмите Cr;  выполнение  ко-
манды на этом завершится, новое, введенное вами, имя главного
файла будет запомнено. При нажатии Esc выполнение команды бу-
дет прекращено, сохранится ранее установленное  имя  главного
файла.
   Если вы хотите работать без главного файла, а он до  этого
был у вас объявлен, то сделайте  имя  главного  файла  пустым
(для этого после М нажмите /\D, потом Cr).
   Формат, в котором должно быть задано имя файла:

   [[d][nn]:]aaaaaaaa.bbb       где

   d        - дисковод,
   nn       - номер пользователя,
   aaaaaaaa - имя файла (не более 8 латинских букв и цифр),
   bbb      - расширение (не более 3 латинских букв и цифр).

   Строчные и прописные буквы отождествляются. Если  расшире-
ние (вместе с разделительной точкой) опущено, то автоматичес-
ки добавляется расширение .PAS . Если вам  необходимо,  чтобы
расширения не было, поставьте после имени точку и более ниче-
го, например: TEXT.
   Для исходных текстов Pascal-программ  мы  рекомендуем  ис-
пользовать расширение .PAS:  во-первых,  оно  общепринято,  а
во-вторых, система EP всегда использует  по  умолчанию  такое
расширение.


   2.3.4. Work file
           - рабочий файл.

   Для выполнения этой команды нужно нажать клавишу W.
   Рабочий файл - это файл, содержащий исходный  текст  прог-
раммы, которую вы хотите редактировать. Команду Work file вам
следует использовать всякий раз, когда вы хотите начать рабо-
тать с новым файлом. Имя текущего рабочего файла - файла, ко-
торый вы редактируете, - находится в основном меню в  строчке
со словами Work file.
   После того, как вы нажали W, вам предлагается отредактиро-
вать 16-литерное поле с именем файла; признак этого - появле-
ние курсора в первой позиции поля. В процессе  редактирования
имени файла вам доступны все возможности редактирования  тек-
ста. Если вам нужно полностью  все  поменять,  удобнее  будет
воспользоваться /\D (команда редактора  "стереть  от  текущей
позиции до конца строки")- поле  при  этом  очистится,  после
этого введите новое имя.
   Завершив редактирование поля, нажмите Cr - после  этого  с
диска будет считан указанный вами файл; находившийся до этого
в памяти текст оттуда удаляется. При нажатии  Esc  выполнение
команды будет прекращено, в памяти останется  тот  же  текст,
который был там до нажатия W.
   В процессе считывания файла с диска на экран под основным-
меню выводится сообщение:

   Loading имя файла

и в этой же строке правее - количество строк, прочитанных  из
этого файла.
   Если файла, указанного вами, не оказалось на диске,  то  в
нижней части экрана появится сообщение:

   Error 4: File not found (имя файла)
   Press Esc

Вам нужно нажать Esc; после этого редактор вернется в  состо-
яние ожидания команды из основного меню. Редактируемый  текст
в памяти сохранится, и тем самым  станет  исходным  вариантом
нового текста. Последнее обстоятельство может быть  использо-
вано вами,если во вновь создаваемый файл должны  войти  фраг-
менты существующего. Если же вам ничего не нужно  из  старого
файла, начните редактирование нового с того, что удалите весь
старый текст. Быстрее всего это получится, если вы установите
курсор в конец текста и  прижмете  Sh+Bs  (команда  редактора
"удалить предыдущую строку").
   Если вы перед тем, как выполнить команду Work file, внесли
изменения в предыдущий исходный текст программы и не сохрани-
ли его на диске (EP следит за этим), то после нажатия клавиши
W в нижней части экрана появится вопрос:

   Work file имя файла not saved. Save? (Y/N)

Вы можете нажать в ответ Y - тогда  сначала  будет  выполнено
сохранение файла (точно так же, как по команде Save), а потом
продолжено выполнение команды Work file; или N -  тогда  про-
должится выполнение команды Work file, изменения, внесенные в
текущий файл, будут потеряны; или Esc  -  выполнение  команды
Work file  будет прекращено.
   Формат, в котором должно быть задано имя файла:

   [[d][nn]:]aaaaaaaa.bbb       где

   d        - дисковод,
   nn       - номер пользователя,
   aaaaaaaa - имя файла (не более 8 латинских букв и цифр),
   bbb      - расширение (не более 3 латинских букв и цифр).

   Строчные и прописные буквы отождествляются. Если  расшире-
ние (вместе с разделительной точкой) опущено, то автоматичес-
ки добавляется расширение .PAS . Если вам  необходимо,  чтобы
расширения не было, поставьте после имени точку и более ниче-
го, например: TEXT.
   Для исходных текстов Pascal-программ  мы  рекомендуем  ис-
пользовать расширение .PAS:  во-первых,  оно  общепринято,  а
во-вторых, система EP всегда использует  по  умолчанию  такое
расширение.
   Рабочий файл, с которым вы работали  в  предыдущем  сеансе
работы с системой, автоматически  считывается  в  память  при
следующей ее загрузке (имя рабочего файла сохраняется в файле
EP.CFG).


   2.3.5. Edit
           - редактировать текст

   Для выполнения этой команды нужно нажать клавишу E.
   По этой команде EP переходит  к  редактированию  исходного
текста программы, который в данный момент находится в памяти.
Как редактировать текст - описано в следующей главе.


   2.3.6. Pick
           - выбрать очередной исходный текст
           программы из pick-таблицы

   Для выполнения этой команды нужно нажать клавишу P.
   Pick-таблица - очень удобный инструмент в ситуации,  когда
вам нужно работать с несколькими программами. С  помощью  нее
вы можете легко переходить от работы с одной программой к ра-
боте с другой. При переходе к работе с новой программой через
pick-таблицу текущая позиция редактора  текстов  сохраняется:
вы попадаете в то место текста, в котором вы  прервали  ранее
редактирование.
   В pick-таблице хранится информация о 12 последних  файлах,
с которыми шла работа. Для каждого файла хранится: имя файла,
положение курсора и маркера в тексте, положение текста на эк-
ране. При завершении работы системы pick-таблица  сохраняется
в файле EP.CFG.
   После того, как вы нажмете клавишу P, в трех нижних  стро-
ках экрана появляется список  имен  файлов  из  pick-таблицы.
Второе имя в таблице помечено указателем - выведено  инверти-
рованным цветом. Вы можете перемещать указатель по  pick-таб-
лице , нажимая клавиши  дополнительной  клавиатуры.  Поместив
указатель на нужное имя, нажмите Cr.  После  этого  выбранный
вами файл будет сделан рабочим и загружен в память, и вы  мо-
жете приступить к его редактированию или компиляции. Загрузка
файла в память выполняется так же, как и при  выполнении  ко-
манды Work file.
   Во время просмотра pick-таблицы  вы  можете,  как  обычно,
прекратить выполнение команды pick,  нажав Esc .
   Если вы перед тем, как выполнить команду  Pick,     внесли
изменения в предыдущий исходный текст программы и не сохрани-
ли его на диске (EP следит за этим), то после нажатия клавиши
P в нижней части экрана появится вопрос:

   Work file имя файла not saved. Save? (Y/N)

Вы можете нажать в ответ Y - тогда  сначала  будет  выполнено
сохранение файла (точно так же, как по команде Save), а потом
продолжено выполнение команды  Pick;     или N -  тогда  про-
должится выполнение команды Pick,      изменения, внесенные в
текущий файл, будут потеряны; или Esc  -  выполнение  команды
Pick  будет прекращено.


   2.3.7. Save
           - записать исходный текст программы
           на диск

   Для выполнения этой команды нужно нажать клавишу S.
   По этой команде выполняется запись исходного текста  прог-
раммы, который находился в памяти, на диск. Эту команду необ-
ходимо использовать всегда, когда вы завершили  создание  или
изменение вашей программы. Кроме того, мы  рекомендуем  пери-
одически выполнять эту команду, если ваш  компьютер  работает
ненадежно.
   После того, как вы нажмете S, на экране в  имени  рабочего
файла (в строке Work file) появится курсор - вам предлагается
сформировать имя, под которым файл будет записан на диск. Для
записи под тем же именем просто нажмите Cr. Иначе введите но-
вое имя (по обычным правилам редактирования). При нажатии Esc
выполнение команды  Save  будет прекращено.
   В процессе записи файла на диск на экран под основным меню
выводится сообщение:

   Saving имя файла

и в этой же строке правее -  количество  строк  записанных  в
этот файл.
   В режиме Bak-copy On, если на диске уже имелся файл с  за-
данным именем, то он предварительно переименовывается: в  его
имени расширение заменяется на расширение BAK;  если  файл  с
таким именем и расширением BAK уже существовал, то перед  пе-
реименованием он уничтожается. В режиме Bak-copy Off, если на
диске уже имелся файл с заданным именем, то перед записью но-
вого файла он уничтожается.
   В режиме Verify On после записи файла на диск автоматичес-
ки выполняется сравнение содержимого файла на диске и  текста
в памяти. Сравнение выполняется так же, как и при  выполнении
команды Verify. В режиме Verify Off такого сравнения не  про-
изводится. Мы рекомендуем выполнять сохранение файлов в режи-
ме  Verify On,  если ваши диски работают ненадежно.


   2.3.8. Verify
           - сравнить текст в памяти с текстом
           записанным на диск

   Для выполнения этой команды нужно нажать клавишу V.
   По этой команде выполняется сравнение текста, находящегося
в памяти, с содержимым файла на диске.
   После нажатия клавиши V, на экране в имени рабочего  файла
(в строке Work file) появляется  курсор  -  вам  предлагается
сформировать имя файла, с содержимым которого  будет  сравни-
ваться текст в памяти. Для сравнения  текущего  файла  просто
нажмите Cr. Иначе введите новое имя (по обычным правилам  ре-
дактирования). При нажатии Esc выполнение команды Verify  бу-
дет прекращено. 
   В процессе сравнения на экран под основным меню  выводится
сообщение:

   Verifing имя файла

и в этой же строке правее - количество строк, сравнение кото-
рых выполнено.
   Если обнаружится несовпадение , то в нижней  части  экрана
появится сообщение:

   Error 23: Verify error
   Press Esc

   В строке Verifing имя файла в этот  момент  находится  но-
мер строки, в которой обнаружено несовпадение. После  нажатия
Esc система вернется в состояние ожидания  команды  основного
меню.


   2.3.9. Compile
           - компилировать

   Для выполнения этой команды нужно нажать клавишу C.
   По этой команде  выполняется  компиляция  вашей  программы
(или модуля - в зависимости от того , что представляет  собой
компилируемый текст).
   Если вы перед тем, как выполнить команду  Compile,  внесли
изменения в вашу программу и не сохранили  ее  на  диске,  то
после нажатия C  в нижней части экрана появится вопрос:

   Work file имя файла not saved. Save? (Y/N)

Вы можете нажать в ответ Y - тогда  сначала  будет  выполнено
сохранение файла (точно так же, как по команде Save), а потом
продолжено выполнение команды  Compile;  или N -  тогда  про-
должится выполнение команды Compile,   изменения, внесенные в
текущий файл, будут потеряны; или Esc  -  выполнение  команды
Compile  будет прекращено.
   Если вы не сохранили рабочий файл перед компиляцией, изме-
нения могут оказаться потерянными в двух случаях.  Во-первых,
если объявлен главный файл и он не совпадает с рабочим -  пе-
ред началом компиляции главный файл будет  тогда  загружен  в
память. Во-вторых, если компилируемая программа содержит  in-
clude-файлы, и при компиляции одного из них будет  обнаружена
ошибка - в этом  случае  автоматически  выполняется  загрузка
файла, содержащего ошибку, в память.
   После того,как (возможное) сохранение исходного текста вы-
полнено, проверяется,  объявлен  ли  главный  файл.  Если  он
объявлен и если его имя не совпадает с именем рабочего файла,
то главный файл делается рабочим, и выполняется его загрузкав
память. Здесь все происходит так же, как и при выполнении ко-
манды Work file - с той лишь разницей, что от вас не требует-
ся вводить имя файла, поскольку оно уже известно.
   После этого начинается компиляция программы (или  модуля).
Компилируется всегда программа, находящаяся в памяти. Возмож-
но, эта программа содержит директивы {$1 имя файла)  -  тогда
во время компиляции содержимое этих include-файлов будет  чи-
таться с диска. Если вы компилируете очень большую  программу
и вам нужно освободить  максимальное  количество  памяти  для
таблиц  компилятора,  сделайте  главный  файл  состоящим   из
единственной директивы {$ 1 имя файла} ( директивы {$  1  имя
файла } могут быть вложенными ). Задаваемое в  директиве  имя
include - файла может содержать обозначение дисковода и номер
пользователя.
   Кроме include - файлов, в период компиляции с диска  могут
считываться скомпилированные модули (unit). Если в компилиру-
емой программе имеется предложени:

   uses UnitName;

то скомпилируемый модуль должен находиться в файле  с  именем
UNITNAME.EPU; этот файл должен находиться на текущем диске  в
области с текущим номером пользователя.
   В процессе компиляции в третью снизу строку  экрана  выво-
дится сообщение:

   Compiling nnnn (имя файла kkkk)

Здесь: nnnn - номер компилируемой  строки  программы,  считая
строки всех iclude - файлов; имя файла в скобках присутствует
только в тот период, когда идет чтение строк из iclude - фай-
ла, и тогда kkkk есть текущий номер строки в  этом  iclude  -
файле; если же идет чтение строк из памяти, то в скобках  на-
ходится только kkkk - текущий номер строки текста  в  памяти.
Если компилируемая программа не имеет  iclude  -  файлов,  то
nnnn и kkkk будут всегда совпадать.
   Компиляция завершается  либо  успехом,  либо  обнаружением
ошибки. В обоих случаях об этом выдается сообщение.  Подробно
процесс компиляции и его результаты описаны в главе 4.
   Если в процессе компиляции  обнаруживается  ошибка,  то  в
нижние строчки экрана выводится сообщение:

   Error nn: сообщение об ошибке
   Press Esc.
("Ошибка nn: сообщение об ошибке. Нажмите Esc.") Сообщение об
ошибке будет присутствовать только  в  том  случае,  если  вы
включили при загрузке модуль сообщений об ошибках; иначе  бу-
дет выдан только номер ошибки nn. После того, как вы  нажмете
Esc, система автоматически перейдет  в  режим  редактирования
текста, и текущая позиция редактора текстов будет  находиться
в той точке, где обнаружена ошибка. Если ошибка была  обнару-
жена в iclude - файле, то предварительно этот файл будет сде-
лан рабочим и загпужен в память. Маркер в тексте устанавлива-
ется в позицию ошибки - так что вы можете спокойно, не опаса-
ясь потерять место ошибки, отправиться в другие части  текста
программы, посмотреть там все, что вам нужно,  а  затем  вер-
нуться в точку ошибки с помощью команды  редактора  "обменять
маркер и курсор".
   Скомпилированная программа (или модуль) либо размещается в
оперативной памяти, либо записывается на диск - в зависимости
от состояния, указанного в строке "Compile  to  Memoruy/Disk"
основного меню.
   Если программа записывается на диск, то она записывается в
файл, имя которого совпадает с именем рабочего файла, а  рас-
ширение есть "Com". Это обычный программный файл CP/М,  и  он
полностью готов к выполнению. Если на диск записывается ском-
пилированный модуль , то он записывается в файл, имя которого
есть идентификатор из предложения unit (если этот идентифика-
тор состоит из более чем 8 литер, то используются первые  8),
а расширение есть ".EPU". Этот файл имеет  специальный  внут-
ренний формат, и может быть использован только  системой  Ex-
press Pascal.
   Если скомпилированная программа  размещена  в  оперативной
памяти, то она далее может быть выполнена с  помощью  команды
"Run" основного меню, описанной в следующем разделе.  Если  в
память компилируется модуль, то результат компиляции никак не
может быть использован далее. Компиляция модуля в память име-
ет смясл только в тех случаях, когда она выполняется с  целью
поиска синтаксических ошибок.
   Компиляция программ (модуля) может быть прервана  нажатием
/\C.










































   2.3.10. Run
           - выполнить программу

   Для выполнения этой команды нужно нажать R.
   По этой команде производится выполнение скомпилированной в
память программы. Подробно процесс выполнения программы  опи-
сан в главе 5.
   При выполнении программы Run компиляция  автоматически  не
выполняется. Поэтому, если вы нажмете R, не выполнив до этого
команду Compile, появится сообщение об ошибке:

   Error 99: No program to run
   Press Esc

   Нажмите Esc, система вернется в состояние ожидания команды
основного меню. Выполните компиляцию программы, и после этого
запустите ее.
   Однажды скомпилированную  программу  вы  можете  запускать
несколько раз - но до тех пор, пока вы не изменили ее.  После
внесения изменений в программу ее нужно  цначала  скомпилиро-
вать и только после этого выполнять.


   2.3.11. Quit
           - выход

   Для выполнения этой команды нужно нажать Q.
   По этой команде EP завершает свою работу.  Если  вы  перед
тем, как выполнить команду Quit , внесли изменения в предыду-
щую программу и не сохранили ее на диске (EP следит за этим),
то после нажатия Q в нижней части экрана появится вопрос:

   Work file имя файла not saved Save? (Y/N)

   Вы можете нажать в ответ Y - тогда сначала будет выполнено
сохранение файла (как по команде Save),  а  потом  продолжено
выполнение команды Quit; или N - тогда продолжится выполнение
команды Quit, изменения, внесенные в текущий файл, будут  по-
теряны; или Esc - выполнение команды Quit будет прекращено.
   Если в такой ситуации при проверке файла после его  сохра-
нения возникнет ошибка Verify error,  то  выполнение  команды
Quit будет прекращено - после Esc редактор вернется в  состо-
яние ожидания команды основного меню. Выполнение команды Quit
также будет прекращено, если вы  прервете  сохранение  текста
нажатием /\C.
   В режиме Autosave EP.CFG On (после  возможного  сохранения
рабочего файла) на диск записывается новый файл EP.CFG;  ста-
рый файл EP.CFG при этом удаляется. Файл EP.CFG  записывается
на текущий диск; поэтому, если вы пользовались командой Defa-
ult drive user, позаботьтесь о том, чтобы  перед  выполнением
команды Quit текущий диск был установлен правильно. В  режиме
Autosave EP.CFG Off  файл EP.CFG на диск не записывыется.


   2.3.12. Help
           - подсказка

   Для выполнения этой программы нужно нажать H.
   По этой команде на экран выводится подсказка - краткая ин-
формация о командах основного меню  и  о  командах  редактора
текстов. Выполнение этой команды никак не влияет ни на исход-
ный текст программы, ни на (возможно)  находящуюся  в  памяти
скомпилированную программу.
   Подсказка состоит из нескольких страниц. Листать их  можно
с помощью клавиш двойная  стрелка  вверх  и  двойная  стрелка
вниз. Для возвращения в основное меню нажмите Esc.
   Для выполнения команды Help необходимо наличие на  текущем
диске файла EP.HLP. Если файла EP.HLP на текущем  диске  нет,
то будет выдано сообщение:

   Error 4: File not found (EP.HLP)
   Press Esc

Нажмите Esc для возврата в основное меню.


   2.3.13. Find run-time error
           - найти ошибку периода исполнения

   Для выполнения этой программы нужно нажать F.
   По этой команде выполняется поиск точки в исходном  тексте
программы, в котором возникла ошибка времени исполнения. Под-
робно поиск ошибки времени исполнения описан в главе 4. Здесь
отметим, что для выполнения поиска ошибки времени  исполнения
необходимо знать адрес точки, в которой возникла ошибка (этот
адрес выводится на экран, если при выполнении программы  воз-
никает ошибка).
   После нажатия F, в строке основного меню, содержащей  Find
run-time error появляется:

   PC=aaaa

aaaa есть 4-х разрядный шестнадцатеричный адрес точки, в  ко-
торой возникла ошибка; исходное  значение  этого  поля  равно
действительному адресу ошибки, если  перед  этим  выполнялась
ваша программа (по команде Run) и при ее выполнении  возникла
ошибка - иначе содержимое этого поля есть 0000. В первой  по-
зиции этого 4-литерного поля появляется курсор - вам  предла-
гается отредактировать адрес. Вы можете  пользоваться  здесь,
как обычно, всеми возможностями редактора.
   После ввода адреса нажмите Cr. При нажатии Esc  выполнение
команды прекращается.
   После этого начинается поиск ошибки. Он во многом похож на
компиляцию, но в отличие от нее выполняется  в  два  прохода.
Это связано с тем, что при оптимизации компилятор мог удалить
код неиспользуемых процедур - а определить,  какие  процедуры
являются неиспользуемыми, можно только  просмотрев  программу
до конца.
   В процессе поиска позиции ошибки в треью снизу строку  эк-
рана выводится сообщение:

   Finding error 1 nnnn (имя файла kkkk)

Смысл всех элементов этого сообщения такой же, как и в  сооб-
щении "Compiling..." при компиляции; 1 указывает номер прохо-
да (1 или 2).
   После того, как позиция ошибки найдена,  в  нижние  строки
экрана выводится сообщение :

   Run-time error position found.
   Press Esc.

После нажатия Esc система автоматически перейдет в пежим  ре-
дактирования текста, а текущая позиция педактора будет  уста-
новлена в точку, соответствующую ошибке (если ошибка  найдена
в include- файле, то предварительно этот  файл  будет  сделан
рабочим и загружен в память). Как и в случае ошибки при  ком-
пиляции, маркер редактора текстов удет установлен в ту же по-
зицию, что и курсор.
   Если в программе используются  модули,  и  ошибка  периода
исправления возникла в одном из модулей, то будет выдано  со-
общение:

   Run-time error position found.
   Error in unit UnitName, PC=aaaa
   PressEsc.

Нажмите Esc, система перейдет в режим ожидания команды основ-
ного меню. Вам нужно загрузить в память исходный  текст  ука-
занного модуля (т.е. сделать его рабочим файлом) и снова  вы-
полнить операцию поиска ошибки времени исполнения,  указав  в
качестве PC аааа. (Если вы выполняете эту операцию  сразу  же
после того,как при поиске ошибки в главной программе вам было
сообщено, что позиция ошибки в модуле, вам не  придется  вво-
дить аааа; этот адрес будет исходным значением поля для ввода
РС.)
   Программа, в которой ищется ошибка, не должна быть измене-
на со времени последней компиляции - иначе позиция ошибки бу-
дет определена неправильно (ведь поиск позиции ошибки времени
исполнения фактически есть поиск  точки  в  программе,  соот-
ветствующей указанному вами адресу).
   Если в период поиска ошибки времени исполнения будет обна-
ружена синтаксическая ошибка в программе, то будут  выполнены
те же действия, что и при компиляции: будет выдано  сообщение
об ошибке, и после того, как вы нажмете Esc, система перейдет
в режим редактирования текста (возможно загрузив  перед  этим
include-файл). Отметим, что такое событие возможно  только  в
результате  некорректного  использования  вами  команды  Find
run-time error: поскольку вам удалось успешно  скомпилировать
программу перед запуском, появление синтаксической ошибки мо-
жет объясняться только последующими изменениями.
   Если вы неправильно зададите адрес ошибки (так, что он вы-
ходит за пределы адресов кода  прогпаммы),  после  выполнения
обоих проходов будет выдано сообщение:

   Error 120: Wrong PC.
   Rress Esc.

После того, как вы нажмете Esc, система вепнется в  состояние
ожидания команды основного меню.
   Выполнение поиска ошибки  времени  исполнения  может  быть
прервано нажатием /\C.


   2.3.14. Compile to Disk/Memory
           - установить режим компиляции
           на диск/в память

   Для выполнения этой команды нужно нажать C+Ctrl.
   Эта команда устанавливает, куда будет помещаться результат
компиляции: на диск или в память. Если в основном меню Compi-
le to Disk (Memory), то скомпилированная программа  (или  мо-
дуль)  будет  записана  на  диск  в  COM-файл  (модуль  -   в
EPU-файл); если в основном меню Compile to Memory (Disk) , то
то программа (или модуль) будет размещена в памяти.


   2.3.15. Parameter string
           - строка параметров

   Для выполнения этой команды нужно нажать P+Ctrl.
   Эта команда позволяет вам отредактировать строку  парамет-
ров, передаваемую программе при ее запуске. Эта строка  пара-
метров является аналогом командной строки, вводимой  операто-
ром при запуске программы  из  ОС  CP/M.  Подробно  структура
строки параметров и возможности ее  использования  описаны  в
главе 5.
   После нажатия /\P, вам предлагается  отредактировать  поле
со строкой параметров (оно расположено в основном меню  стро-
кой ниже Parameter string); признак этого - появление курсора
в первой позиции поля. Вам доступны все возможности  редакти-
рования текста. Если вам нужно полностью все  поменять,  вос-
пользуйтесь /\D (команда "стереть от текущей позиции до конца
строки") - поле при этом очистится, и введите новое  содержи-
мое.
   Максимальная длина строки параметров - 127 литер,  а  окно
на экране имеет ширину 30 позиций. Поэтому, когда вы  дойдете
до правой границы окна и будете продолжать  ввод,  содержимое
окна будет смещаться влево - как и при редактировании  текста
с длинными строками.
   Для завершения ввода строки параметров нажмите Cr. При на-
жатии на Esc выполнение команды будет прекращено, все внесен-
ные изменения отменены, а строка параметров сохранит  прежний
вид. Строка параметров сохраняется в EP.CFG-файле;  в  начале
очередного сеанса работы ее содержимое будет таким же, как  и
в конце предыдущего.


   2.3.16. BAK-copy on/off
             - включить/выключить создание BAK-копии

   Для выполнения этой команды нужно нажать клавишу  "B"  при
нажатой клавише Ctrl.
   Эта команда переключает режим соэдания BAK-копии,  исполь-
зуемой при выполнении команды "Save".


   2.3.17. Verify on/off
             - включить/выключить автоматическую проверку при
             записи редактируемого файла на диск

   Для выполнения этой команды нужно нажать клавишу  "V"  при
нажатой клавише Ctrl.
   Эта команда переключает  режим  выполнения  автоматической
проверки файла после его записи на диск, используемый при вы-
полнении команды "Save".


   2.3.18. Autosave EP.CFG on/off
             - включить/выключить автоматическое сохранение
             файла EP.CFG на диске при выходе из системы

   Для выполнения этой команды нужно нажать клавишу  "А"  при
нажатой клавише Ctrl.
   Эта команда переключает режим  автоматического  сохранения
файла EP.CFG при выходе из редактора, используемый при выпол-
нении команды "Quit".


   2.3.19. Default EP.CFG
             - сбросить все параметры системы,
             хранящейся в файле EP.CFG

   Для выполнения этой команды нужно нажать клавишу  "D"  при
нажатой клавише Ctrl.
   Поэтой команде параметрам  системы,  сохраняемым  в  файле
EP.CFG, придается значение их по умолчанию: имя главного фай-
ла не указано, рабочего файла нет pick-таблица  пуста,  режим
компиляции - в память, строка параметров пуста, режим  созда-
ния BAK-копий - не создавать, режим проверки текста после за-
писи на диск - проерять, режим сохранения файла EP.CFG - сох-
ранять.


   2.3.20. Restore EP.CFG
           - прочитать с диска файл EP.CFG

   Для выполнения этой команды нажмите R+Ctrl.
   По этой команде выполняется считывание файла EP.CFG с  те-
кущего диска.
   Эту команду удобно мспользовать по меньшей мере в двух си-
туациях. Во-первых, если вы выполняли разовое обращение к не-
которой программе, и не хотите, чтобы ее  имя  сохранилось  в
pick-таблице. Во-вторых, если вы перешли к  работе  с  другим
диском и хотите воспользоваться pick-таблицей, записанной  на
нем.
   В результате выполнения этой команды  изменяется,  в  час-
тности имя рабочего файла - будьте внимательны, не  ошибитесь
теперь при задании имени записываемого по команде Save файла.


   2.3.21. Save EP.CFG
           - записать на диск файл EP.CFG

   Для выполнения этой команды нажмите S+Ctrl.
   По этой команде выполняется  запись  текущего  содержимого
файла EP.CFG на текущий диск.
   Эту команду  уместно  использовать  в  случае,  когда  ваш
компьютер работает ненадежно - для того, чтобы после  сбоя  в
вашем распоряжении оказалась  не  слишком  устаревшая  версия
конфигурационного файла.


   2.4. Возможные ошибки при работе с диском
        и их обработка.

   При выполнении записи файлов на диск или чтении  файлов  с
диска могут возникать  различные  ошибки.  При  возникновении
ошибки в нижнюю часть экрана выводится сообщение  (в  том  же
формате, что и сообщение компилятора об ошибке):

   Error nn: наименование ошибки (имя файла)
   Press Esc

nn - номер ошибки;
имя файла - файл, при записи  или  чтении  которого  возникла
            ошибка
   При появлении такого сообщения  постарайтесь  понять,  что
явилось причиной ошибки, инажмите Esc. После возвращения сис-
темы в основное меню, примите меры для ликвидации последствий
сбоя.
   Список всех возможных сообщений об ошибках и описание спо-
собов ликвидации их последствий приведен в приложении А.





























































































   ГЛАВА 4
   КОМПИЛЯЦИЯ ПРОГРАММЫ И ПОИСК ОШИБОК


   Компиляция программы начинается после того, как вы из  ос-
новного меню запустите команду Compile.
   В этой главе мы подробно опишем , как  происходит  процесс
компиляции. Много внимания будет уделено вопросам  внутренней
реализации процесса компиляции;  знание  этого  позволит  вам
лучше понимать, что происходит, и более эффективно - особенно
в случае работы со сложными и большими программами -  органи-
зовать свою работу. В основном эта  глава  предназначена  для
программистов, которые  хорошо  знают  внутреннее  устройство
компьютера. При отсутствии интереса эту главу  можно  пропус-
тить.


   4.1. Компиляция программы.

   Компилятор EP является однопроходным. Это означает, что он
просматривает компилируемую программу один раз, от начала  до
конца, никогда не возвращаясь к уже просмотренным частям.
   Компилируется всегда текст, расположенный в текущий момент
в памяти. Если у вас не задан главный  файл,  то  этот  текст
есть содержимое текущего рабочего файла. Если же  задано  имя
главного файла, то перед началом компиляции этот файл делает-
ся рабочим, и его содержимое считывается в память.
   Если исходный текст вашей программы большой (не помещается
целиком в память), то можно разбить его на  несколько  файлов
так, чтобы каждый из них помещался в памяти, и затем включить
их в компилируемую программу с помощью  директив  компилятора
{$1 имя файла}. Глубина вложенности директив {$1  имя  файла}
не ограничена (т.е. файл , включаемый с помощью директивы {$1
имя файла}, сам может содержать  такую  директиву,  и  т.д.).
Единстенное ограничение для глубины вложенности директив  {$1
имя файла} - это объем  памяти,  находящийся  в  распоряжении
компилятора. Память, отводимая компилятором под  стек  inclu-
de-файлов, используется и для других целей, поэтому невозмож-
но точно сказать каково ограничение; во всяком случае, компи-
ляция программ с глубиной вложенности до 5 не должна  вызвать
проблем.
   Для отслеживания процесса компиляции, в строку под  основ-
ным меню выводится:

   Compiling   nnnn     (имя файла kkkk)

nnnn - номер компилируемой строки  программы,  считая  строки
       всех include-файлов;
имя файла - в скобках присутсвует только в тот период,  когда
            идет чтение строк из include-файлов, и тогда kkkk
            есть текущий номер строки в  этом  include-файле;
            если же идет чтение строк из памяти, то в скобках
            находится только  kkkk  -  текущий  номер  строки
            текста в памяти.
   Если компилируемая программа не имеет  include-файлов,  то
nnnn и kkkk будут всегда совпадать.
   Процесс компиляции состоит в проверке синтаксической  пра-
вильности программы и генерации кода.  Если  в  компилируемой
программе обнаруживается синтаксическая ошибка,то в две  ниж-
них строки экрана выводится сообщение:

   Error nn: сообщение об ошибке
   Press Esc.

Сообщение об ошибке будет присутствовать только  в  том  слу-
чае,если вы включили при загрузке модуль сообщений  об  ошиб-
ках; иначе будет выдан только номер ошибки  nn.  После  того,
как вы нажмете Esc, система автоматически  перейдет  в  режим
редактирования текста, и текущая  позиция  редактора  текстов
будет находиться в той точке,  где  обнаружена  ошибка.  Если
ошибка была обнаружена  в  include-файле,  то  предварительно
этот файл будет сделан рабочим и загружен в память. Маркер  в
тексте устанавливается также в позицию ошибки -  так  что  вы
можете спокойно, не опасаясь потерять  место  ошибки,  отпра-
виться в другие части текста программы, посмотреть  там  все,
что вам нужно, а затем вернуться в точку ошибки с помощью ко-
манды редактора "обменять маркер и курсор".
   Полный список сообщений об ошибках, которые выдает  компи-
лятор, приведен в приложении Б. Здесь мы  остановимся  только
на основных  принципах  выяснения  причин,  которыми  вызваны
ошибки.
   Позиция ошибки в тексте программы - это всегда первая  ли-
тера лексемы,  при  обработке  которой  компилятор  обнаружил
ошибку. Часто причина ошибки находится за несколько лексем до
этой позиции, а иногда - и за много строк программы до нее.
   Например, при компиляции выражения:

           S + (21 + 3*5) - 1
(где S - переменная строкового типа)  ошибка  "несоответствие
типов операндов" будет диагностирована только после  заверше-
ния компиляции подвыражения в скобках (курсор будет  установ-
лен на следующей за этим подвыражением лексеме - знаке "-", в
то время как действительная причина ошибки может  состоять  в
том, что вы указали переменную S вместо переменной  арифмети-
ческого типа. 
   Особенно неприятными являются ошибки, связанные  с  разба-
лансировкой операторных скобок begin и end.Как правило, такая
ошибка может быть обнаружена много позже того места, где про-
пущена (или стоит лишняя) операторная  скобка.  (Если  вы  не
следуете принципам структурного программирования и любите пи-
сать длинные процедуры, то  фактическая  точка  ошибки  может
отстоять от места ее обнаружения на  несколько  страниц  тек-
ста.) Чтобы по возможности избежать таких ошибок,мы  рекомен-
дуем вам при при вводе текста  программы  сразу  после  ввода
слова begin вводить слово end - и только после этого  вводить
операторы, которые должны быть размещены между ними. Редактор
текстов системы Express Paskal устроен так,  что  этот  метод
ввода программ не потребует у вас дополнительных усилий.
   Если компиляция завершается успешно, то на экран выводится
сообщение:

   Code:0000h    Data:0000h    Stack:0000h   Heap:0000h
   (0000h-0000h) (0000h-0000h) (0000h-0000h) (0000h-0000h)
   Press Esc.

   В этом сообшении указываются размеры и адреса 4-х областей
памяти, отведенных для Pascal-программы: кода, данных,  стека
и кучи (подробно назначение и  способ  размещения  каждой  из
этих областей описаны в главе 13 части 2). В верхней  строчке
указан размер, в нижней - начальный и конечный  адреса  соот-
ветствующей области. Это сообщение является также информацией
о том, что компиляция завершилась успешно.
   Текст Pascal-программы определяет размеры кода,  данных  и
стека; вся оставшаяся память отводится под кучу. Как правило,
информация о расположении областей для вас  не  будет  сущес-
твенной; соотношение размеров кучи и остальных областей  дает
информацию о том, какие резервы памяти у вас еще имеются.
   Более подробно остановимся на одной ошибке, которая  может
возникнуть в процессе компиляции: Out of memory.
   В период компиляции используются две области свободной па-
мяти: область основной памяти, оставшаяся незанятой  исходным
текстом программы, и графическая память.  В  основной  памяти
компилятор строит свои таблицы; в графическую память  помеща-
ется генерируемый код.
   В процессе генерации кода он помещается в графическую  па-
мять всегда - независимо от того, куда  должен  быть  помещен
окончательный результат компиляции: в память или на диск  (на
окончательное место код перемещается после завершения  компи-
ляции). Размер графической памяти - 48 К, а  размер  кода  не
может превосходить 40 К (CP/M занимает 13К, и библиотека про-
цедур времени исполнения занимает около 11К); поэтому  графи-
ческой памяти всегда достаточно для размещения кода. Если все
же окажется, что графическая память переполнена (первая  воз-
можная причина возникновения ошибки Out of  memory),  то  это
значит, что вы написали настолько большую программу, что  она
не может работать на Корвете.
   Объем памяти, требуемой для таблиц компилятора существенно
зависит от компилируемой  программы;  текущий  размер  таблиц
приблизительно пропорционален количеству доступных  в  данный
момент идентификаторов. Может оказаться, что имеющейся памяти
недостаточно для размещения таблиц. Это вторая возможная при-
чина возникновения ошибки Out of memory. Если возникла  такая
ситуация, то вынесите часть исходного текста  программы  (или
даже весь текст) в include-файлы; если  это  не  поможет  -не
включайте при запуске системы EP модуль сообщений об ошибках;
если же и это не поможет - попытайтесь уменьшить количество и
длину используемых идентификаторов (в EP все литеры идентифи-
катора являются значимыми, и чем  длинне  идентификатор,  тем
больше места он занимает в таблице).
   Третья причина возникновения ошибки Out of memory  -  если
размер поля локальных переменных процедуры превысит 64К.  Та-
кая программа не может быть выполнена на Корвете и ее следует
как-то переделать.
   Если ни одна из перечисленных причин не возникла в процес-
се компиляции (и если, разумеется , в программе не обнаружи-
лось какой-нибудь другой синтаксической ошибки), то  компиля-
ция доходит до конца. После завершения этого  этапа  произво-
дится распределение памяти для Paskal-программы.  Та память,
которая доступна для размещения Paskal-программы, зависит  от
того, куда выполняется компиляция (на диск или  в  память)  и
может быть уточнена с помощью директив {$M...} и {$S...} (эти
директивы описаны в главе 12 части 2). Здесь может  выяснить-
ся, что имеющейся памяти  недостаточно  для  размещения  Pas-
kal-программы. Это - четвертый случай, когда может возникнуть
ошибка "Out of memory". Если такое случится, то на экран  вы-
водится сообщение:
   Code:0000h     Data:0000h     Stack:0000h
   Error 24: Out of memory
   Press Esc.
Здесь обозначенное "0000h" есть размеры, которые должны иметь
соответствующие области. По этим значениям вы можете  опреде-
лить, сколько памяти не хватает для вашей программы.
   Компилятор Express Paskal выполняет оптимизацию  генериру-
емого кода.Подробно выполняемые оптимизации описаны  в  главе
6. Для выполнения некоторых  оптимизаций  требуется  заметное
время (оптимизация, выполняемая в  конце  компиляции  большой
программы может продолжаться до 10 секунд). Во время выполне-
ния долгих оптимизаций в строку под основным меню вместо сло-
ва "Compiling" выводится слово "Optimizing".
   Вы можете прервать выполнение  компиляции,  нажав  /\C.  В
этом случае в нижних строках экрана появится сообщение:

   User break.
   Press Esc.
После того, каквы  нажмете  Esc,  будут  выполнены  действия,
обычно выполняемые при обнаружении ошибки: система перейдет в
режим редактирования и курсор будет установлен на ту лексему,
при обработке которой было нажато /\C.


   4.2. Поиск позиции
        Ошибки периода исполнения

   Если при выполнении Paskal-программы возникает ошибка,  то
о ней выдается сообщение. Сообщение об ошибке времени  испол-
нения имеет формат:
   Run-time error   nn.PC=aaaa. сообщение об ошибке
   Press Esc.
Число aaaa, указанное в сообщении есть адрес точки, в которой
возникла ошибка (PC=Program Counter - Счетчик  Адреса).  Этот
адрес задаетсяотносительно начала кода (а не  является  абсо-
лютным адресом), и поэтому не зависит от того, в каком режиме
компилировалась программа - на диск или в память. Эта  инфор-
мация поможет вам найти соответствующую  позицию  в  исходном
тексте.
   Для того, чтобы найти позицию ошибки,  нужно,  находясь  в
основном меню, нажать клавишу "F" (команда Find run-time  er-
ror" - Найти позицию ошибки времени исполнения"). После этого
вам предлагается ввести PC ошибки - то, что было сообщено вам
в момент обнаружения ошибки. После того, как вы нажмете Cr (в
завершение ввода адреса), начнется поиск позиции ошибки.
   Если ошибка времени исполнения в программе, скомпилирован-
ной в память, и вы начинаете поиск позиции  ошибки  сразу  же
после ее возникновения (без перезагрузки системы),  то  после
нажатия F вы обнаружите, что адрес ошибки уже находится в по-
ле для ввода адреса - и вы можете сразу же нажать Cr.
   Поиск позиции ошибки времени исполнения фактически являет-
ся компиляцией программы, выполняемой до тех пор, пока не бу-
дет сгенерирована команда с адресом, совпадающим  с  заданным
(код, генерируемый здесь, никуда не заносится - ни  на  диск,
ни в память). Есть, однако, одно  существенное  отличие.  При
компиляции программы (в которой ищется ошибка), возможно, вы-
полнялось устранение кода  неиспользуемых  процедур.  Устано-
вить, был ли устранен код какой-нибудь процедуры, можно толь-
ко просмотрев программу до конца. Поэтому поиск ошибки време-
ни исполнения выполняеися в 2 прохода. На первом проходе сос-
тавляется таблица устраненного кода;  на  втором  выполняется
собственно поиск позиции ошибки.
   В процессе поиска позиции ошибки в третью снизу строку вы-
водится сообщение:

   Finding error 1 nnnn (имя файла kkkk)

Смысл всех элементов nnnn (имя файла kkkk) в  этом  сообщении
такой же, как и в сообщении Compiling...  при  компиляции;  1
указывает номер прохода (1 или 2).
   После того, как позиция ошибки найдена,  в  нижние  строки
экрана выводится сообщение:

   Run-time error position found
   Press Esc

После нажатия Esc система автоматически перейдет в режим  ре-
дактирования текста, и текущая позиция редактора будет  уста-
новлена в точку, соответствующую ошибке (если ошибка  найдена
в include-файле, то предварительно этот файл будет сделан ра-
бочим и загружен в память). Как и в случае ошибки при  компи-
ляции, маркер редактора текстов будет установлен в ту же  по-
зицию, что и курсор.
   Если в программе используются модули, и ошибка периода ис-
полнения возникла в одном из модулей, то будет выдано сообще-
ние:

   Run-time error position found
   Error in unit UnitName, PC=aaaa
   Press Esc

Здесь 16-ричное число aaaa есть адрес точки, в которой  обна-
ружена ошибка, относительно начала модуля UnitName. После на-
жатия Esc система перейдет в режим основного меню. Вам  нужно
загрузить в память исходный текст модуля UnitName (т.е.  сде-
лать его рабочим файлом) и снова  выполнить  операцию  поиска
ошибки времени исполнения, указав в качестве PC  aaaa.  (Если
вы выполните эту операцию сразу же после того, как при поиске
ошибки в главной программе вам  было  сообщено,  что  позиция
ошибки в модуле, вам не придется вводить aaaa: этот адрес бу-
дет исходным значением поля для ввода PC).
   Программа, в которой ищется ошибка, не должна быть измене-
на со времени последней компиляции - иначе позиция ошибки бу-
дет определена неправильно (ведь поиск позиции ошибки времени
исполнения фактически есть поиск  точки  в  программе,  соот-
ветствующей указанному вами адресу).
   Если в период поиска ошибки времени исполнени будет  обна-
ружена синтаксическая ошибка в программе, то будут  выполнены
те же действия, что и при компиляции: будет выдано  сообщение
об ошибке , и после нажатия Esc , система  перейдет  в  режим
редактирования текста (возможно, загрузив перед  этим  inclu-
de-файл). Отметим, что такое событие возможно  только  в  ре-
зультате некорректного испоьзования вами команды Find run-ti-
me error : поскольку вам удалось успешно скомпилировать прог-
рамму перед запуском, появление синтаксической  ошибки  может
обьсняться только последующими изменениями.
   Если вы неправильно зададите адрес ошибки (так, что он вы-
ходит за пределы адресов кода  программы),  после  выполнения
обоих проходов будет выдано сообщение:

   Error 120: Wrong PC
   Press Esc

После нажатия Esc система вернется в режим  команд  основного
меню.
   Можно прервать выполнение поиска  позиции  ошибки  времени
исполнения, нажав /\C. В этом случае в нижних строках  экрана
появтся сообщение:

   User break
   Press Esc

После нажатия Esc будут выполнены действия,  обычно  выполня-
емые при обнаружении ошибки: система перейдет в режим  редак-
тирования и курсор будет установлен на ту лексему, при  обра-
ботке которой было нажато /\C.
   Возникновение некоторых ошибок  периода  исполнения  может
быть вызвано не ошибкой в программе, а неправильным ее запус-
ком.
   В заключении отметим, что поиск позиции ошибки времени ис-
полнения должен выполняться с помощью той же версии  компиля-
тора, с помощью которой была получена  программа,  в  которой
обнаружилась ошибка.


   Глава 5
   ВЫПОЛНЕНИЕ СКОМПИЛИРОВАННОЙ ПРОГРАММЫ

   Система Express Paskal позволяет вам  выполнить  программу
немедленно после ее компиляции - без  предварительной  записи
скомпилированной программы на диск и затем загрузки ее  отту-
да.
   Для этого программу нужно скомпилировать в режиме "Compile
to Memory" ("Компиляция в память") и затем, находясь в основ-
ном меню,нажать клавишу "R" - команда "Run" ("Выполнить прог-
рамму").
   Система EP при выполнении команды "Run" не предусматривает
автоматической компиляции программы. Поэтому перед выполнени-
ем команды "Run" обязательно должна  быть  выполнена  команда
"Compile" и между командами "Run" и "Compile" не должны  вно-
ситься изменения в исходный текст программы в памяти  (но  вы
можете просматривать в это время исходный текст с помощью ре-
дактора). Один раз скомпилированная  программа  может  выпол-
няться неоднократно.
   Если вы попытаетесь выполнить программу, не  скомпилировав
ее предварительно, вам будет выдано сообщение об ошибке:

   Error 99: No program to run
   Press Esc.

Нажмите Esc; система вернется в режим ожидания команды основ-
ного меню. Выполните компиляцию программы, и после этого  за-
пустите ее.
   После того, как вы нажали клавишу  "R",  экран  очищается,
курсор устанавливается в левый верхний угол и начинается  вы-
полнение программы.
   Выполнение программы, запущенной по команде  "Run",  может
закончиться одним из трех способов:
   * нормальное завершение работы Paskal-программы  (выполнен
     эавершающий главную программу end или была вызвана
     процедура Halt)
   * возникла ошибка периода исполнения
   * выполнение программы прервано пользователем с помощью
     нажатия /\C
   В любом из случаев в две нижние строчки  экрана  выводится
сообщение о завершении работы. При этом, если курсор находит-
ся в одной из нижних строк, то экран предварительно сдвигает-
ся на две строчки ввепх (так, чтобы нижние строчки  оказались
свободными).
   При нормальном завершении работы выводится сообщение:

   Press Esc.

После того, как вы нажмете Esc, система перейдет в  состояние
ожидания ввода команды основного меню. Вывод этого  сообщения
о ожидание нажатия Esc выполняются для того, чтобы  вы  могли
рассмотреть результаты выполнения вашей программы, выведенные
на экран; после нажатия Esc, на экране появится основное  ме-
ню, и вы уже не сможете увидеть информацию, выводившуюся  ва-
шей программой на экран.
   При возникновении ошибки на экран выводится сообщение:

   Run-time error nn. PC=aaaa: сообщение об ошибке
   Press Esc.

Сообщение об ошибке присутствует, если загружен модуль с  со-
общениями об ошибках; иначе вам будет  сообщен  только  номер
ошибки nn. Шестнадцатиричное число  aaaa  задает  адрес  точ-
ки(относительно начала кода), в которой вознмкла ошибка. Этот
адрес пригодится вам при выполнении операции  "поиск  позиции
ошибки времени исполнения". Для того, чтобы вернуться в  сос-
тояние ожидания команды основного меню,  вам  следует  нажать
Esc (но не спешите этого делать: сначала попытайтесь  понять,
в чем причина возникновения ошибки; то, что находится в теку-
щий момент на экране, может помочь вам это  сделать).  Полный
список сообщений об ошибках приведен в приложении Б. 
   В любой момент работы программы вы  можете  прекратить  ее
выполнение, нажав /\C. В этом случае на экран выводится сооб-
щение: 

   User break. PC=aaaa
   Press Esc

16-ричное число aaaa задает адрес точки (относительно  начала
кода), в которой выполнение программы было прервано. Этот ад-
рес полезен в том случае, когда ваша программа зациклилась, и
необходимо определить, какой цикл не заканчивается.  Восполь-
зуйтесь командой "поиск позиции ошибки  времени  исполнения",
чтобы найти место программы, в котором она была прервана. Для
возврата в основное меню нажмите Esc.
   Выполнение программы может быть приостановлено в любой мо-
мент нажатием /\S (чтобы, например, рассмотреть выводимую  на
экран информацию). После нажатия /\S в  правый  верхний  угол
экрана будет выведено

   PAUSE

Эта надпись информирует о том, что работа приостановлена. При
этом все нажатия клавиш, кроме /\Q и /\C игнорируются.  Нажа-
тие /\C вызывает те же действия, что и в период работы  прог-
раммы. Нажатие /\Q  вызывает  продолжение  работы  программы;
правый верхний угол экрана восстанавливается.
   Обработка клавиш /\C, /\S, /\Q системой EP несколько отли-
чается от обработки их ОС CP/M. В CP/M нажатие  /\S  приоста-
навливает только вывод на экран; если программа на экран  ни-
чего не выводит, то она продолжает работать и  после  нажатия
на /\S. В EP нажатие /\S приостанавливает работу всегда - не-
зависимо от того, идет вывод на экран или нет. В  CP/M  после
приостановки с помощью /\S работу можно  продолжить  нажатием
любой клавиши - в EP только нажатием /\Q. Наконец, /\C  обра-
батывается CP/M только в моменты вывода на экран или ввода  с
клавиатуры - в EP эта клавиша в любой момент прерывает работу
программы.
   В системе EP /\C, /\S, /\Q срабатывают в  любой  момент  -
если только выполняемая Pascal- программа не запрещает преры-
вания или каким-либо другим способом не изменяет систему  об-
работки прерываний (это может быть сделано  с  помощью  inli-
ne-операторов).  Поскольку  прерывание  и  даже  приостановка
функций BDOS и BIOS может привести к неприятным последствиям,
EP обеспечивает их неделимость: если /\C или /\S были  нажаты
в период выполнения функций BDOS или BIOS , то система снача-
ла дожидается завершения работы этой функции, и только  потом
выполняет дествия по нажатой клавише.
   Те же возможности приостановить, продолжить и прервать ра-
боту программы имеются и в том случае, когда Pascal-программа
была скомпилирована на диск и запущена на  выполнение  непос-
редственно из OС.
   Если вы разрабатываете программу, которая должна далее ра-
ботать как самостоятельная программа CP/M, то, возможно, пот-
ребуется, чтобы ваша программа получала параметры  из  коман-
дной строки. ОС CP/M размещает  содержимое  командной  строки
(без имени программы) по адресу 80h;  оттуда  эту  информацию
может извлечь ваша программа (проще всего это сделать  с  по-
мощью стандартных функций ParamCount и ParamStr; см. их  опи-
сание в главе 14 ч.2)...
   Если ваша программа не слишком большая и помещается в  па-
мяти вместе с системой EP, то удобнее для отладочных запусков
скомпилировать программу в память  и  запускать  ее  командой
Run. В системе EP предусмотрена возможность формирования  ко-
мандной строки (по адресу 80h) при таком способе запуска. Для
этого нужно с помощью команды Parameter string ввести  требу-
емое содержимое командной строки (то, что вы должны ввести  в
ответ на запрос CP/M, но без имени программы и следующего  за
ним пробела). Система EP размещает эту информацию  по  адресу
80h при каждом выполнении команды Run. Строка параметров сох-
раняется между запусками  программы  (и  даже  сохраняется  в
EP.CFG-файле), так что вы  можете,  введя  строку  параметров
один раз, многократно запускать вашу программу с этитми пара-
метрами.
   Если Paskal-программа выполняет вывод на экран  с  помощью
стандартных процедур ввода-вывода,  то вывод выполняется с
помощью функций BDOS. При этом вам доступны  все  управляющие
символы и escape-последовательности, которые отрабатывают эти
функции; подробно об этих воэможностях вы  можете  узнать  из
описания операционной системы. Кроме того на Корвете имеется
возможность выполнять вывод на экран  путем  непосредственной
записи информации в память экрана. Работа системы EP, как ра-
бота CP/M, происходит в конфигурации 1Ch - со всеми следующи-
ми из этого возможностями обращения к памяти и портам экрана.
Подробно узнать о том, как это делать, вы можете из  докумен-
тации, описывающей устройство компьютера.
   Описываемая версия системы  EP  содержит  некоторый  набор
стандартных процедур, работающих с  графическим  экраном.  Но
при  необходимости  ваша  программа  может  выполнять  непос-
редственные обращения к портам  памяти  графического  экрана.
При этом вам необходимо позаботиться о том, чтобы  процедуры,
работающие с графическим экраном, не были расположены по  тем
адресам, на которые включается графическая  память;  один  из
инструментов, который имеется для этого в вашем распоряжении,
- это директива компилятора {$M...}.  Система  EP  использует
для своих внутренних нужд графическую память, но это  исполь-
зование всегда временное: в период выполнения  скомпилирован-
ной программы в графической памяти ничего не хранится,  и  вы
можете спокойно использовать ее для нужд вывода  изображения.
В период работы системы EP таблица присвоения  цветов  переп-
рограммируется так, чтобы информация, хранящаяся в  графичес-
кой памяти, не отображалась на экране. Поэтому, если вам нуж-
но выполнять вывод на графический экран, вы должны запрограм-
мировать таблицу присвоения цветов так, как это вам нужно  (и
не забудьте очистить графическую память, иначе вы увидите  на
экране мусор). После завершения  выполнения  Paskal-программы
система снова перепрограммирует  таблицу  присвоения  цветов,
так что вам нет нужды беспокоиться о ее восстановлении  перед
завершением программы.
   Микропроцессор 8080 не имеет средств защиты памяти. Поэто-
му, если выполняемая Paskal-программа  содержит  ошибки,  она
может испортить систему EP или операционную систему.  Если  у
вас есть подозрение, что так и случмлось, то вам лучше  пере-
загрузить операционную ситему и вызвать заново EP:  работа  с
испорченными программами может привести к непредсказуемым,  а
иногда к катострофическим последствиям.  Но  даже  выполнение
неотлаженной Paskal-программы может привести к порче  системы
только в том случае, если в программе используются возможнос-
ти, выходящие за рамки стандартного Paskal'я (inline-операто-
ры, absolute-переменные, ретипирование  и  т.п.).  Если  ваша
программа написана на стандартном Pascal'е и скомпилирована с
лирективой {$R+} ("контроль за границами отрезков типов и ин-
дексами массивов"), то никакие ошибки в ней не могут привести
к неприятностям.
   Как мы уже упоминали, однажды  скомпилированная  в  память
программа может быть выполнена несколько раз.  Но  есть  одно
замечание. Если вы используете типизированные  константы  как
переменные с начальными значениями, то помните, что начальные
значения присваиваются им при компиляции - а не в начале каж-
дого выполнения. Поэтому, если при первом выполнении програм-
мы значения каких-либо типизированных констант были изменены,
то повторное выполнение начнется  с  измененными  значениями.
Если же нужно, чтобы переменным каждый раз в начале  выполне-
ния присваивались  начальные  значения,  то  поместите  соот-
ветствующий набор  операторов  присваивания  в  начало  вашей
программы.
   Если ваша программа выполняла операции с файлами на диске,
то при прерывании ее работы по /\C или в результате возникно-
вения ошибки нужно учитывать следующее. Файлы, которые только
читались, будут закрыты  нормально  (поскольку  для  закрытия
файла, в который не производилась запись, никаких специальных
действий не требуется). Фалы, в которые производилась запись,
окончательно оформляются только в момент их закрытия.  Поэто-
му, если программа была прервана до того, как один из записы-
ваемых файлов был закрыт, то не всю информацию, которую  ваша
программа успела вывести в этот файл, вы найдете в нем. Одна-
ко, оформлен файл на диске будет корректно, и у вас  не  воз-
никнет проблем при дальнейшей работе с диском.
   У вас есть возможность выполнить в программе закрытие всех
открытых файлов при любом способе ее  завершения.  Для  этого
следует воспользоваться аппаратом exit-процедур (подробно это
описано в главе 13 ч.2).  Цепочка  exit-процедур  выполняется
всегда - и при нормальном завершении программы, и при  преры-
вании ее работы с помощью /\C, и при возникновении ошибки пе-
риода исполнения.
   Система EP не содержит спецсредств запуска программ, ском-
пилированных на диск. Для того, чтобы запустить  такую  прог-
рамму, нужно закончить работу с системой EP (команда Quit), и
затем выполнить вашу программу из ОС. Если вы выполняете  от-
ладочные запуски, то после  обнаружения  ошибки  нужно  снова
вызвать EP, внести необходимые изменения в программу, скрмпи-
лировать ее, выйти из EP, снова выполнить  программу  и  т.д.
Это не совсем удобно, но при работе с большой программой луч-
шего не придумаешь. Наличие pick-таблицы несколько  облегчает
работу такого рода: возвращаясь в EP , вы попадете  в  то  же
место исходного текста, в котором завершили предыдущий этап.
   Выполнение программы, скомпилированной на диск, во  многом
похоже на выполнение программы,  скомпилированной  в  память.
Так же обрабатываются клавиши /\C, /\S, /\Q; в частности, вы-
даются те же сообщения, и так же при прерывании по /\C  будет
сообщен адрес точки, в кторой выполнение программы было прер-
вано. При возникновении ошибки  периода  исполнения  выдается
сообщение такого же формата, как и при выполнении  программы,
скомпилированной в память. Правда, при  ошибке  в  программе,
скомпилированной на диск, никогда не  выдается  сообщение  об
ошибке: только ее номер (см. приложение Б).
   При возникновении ошибки периода исполнения и при прерыва-
нии программы с помощью /\C адрес (PC) вылается  не  абсолют-
ный, а относительно начала кода; поэтому вы  будете  получать
один и тот же адрес и при запуске из памяти, и при запуске  с
диска.


















































   ГЛАВА 6
   ОПТИМИЗАЦИЯ КОДА


   Компилятор EP выполняет ряд оптимизаций кода; эти  оптими-
зации значительно повышают качество (компактность кода и ско-
рость выполнения) резултирующей программы.
   EP выполняет следующие 5 типов оптимизаций:
- оптимизация кода операторов if, while, repeat, for, case
- устранение кода неиспользуемых процедур
- совмещение памяти для локальных переменных независимых про-
  цедур
- вычисление константных подвыражений
- локальная оптимизация кода


   6.1. Оптимизация кода операторов
           if, while, repeat, for, case

   При компиляции этих операторов особым образом  обрабатыва-
ются случаи, когда их параметры являются константными выраже-
ниями.
   Операторы if, while, repeat имеют единственный  параметр  -
выражение типа boolean. Если это выражение является  констан-
тным, то EP генерирует упрощенный код. Именно,  код  проверки
условия никогда не генерируется, и:
- для оператора if True then S1 else S2; генерируется  только
  код оператора S1 ( и так же при отсутствии альтернативы el-
  se ). Для оператора if False then S1 else S2;  генерируется
  только код оператора S2 (если альтернатива else  отсутству-
  ет, никакого кода не генерируется).
- для оператора while True  do  S;  генерируется  бесконечный
  цикл выполнения оператора S (никаких команд проверки  усло-
  вия конца цикла при этом  не  порождается).  Для  оператора
  while False do S; никакого кода не генерируется.
- для оператора repeat S1;...; Sn  until  True;  генерируется
  код однократного выполнения  последовательности  операторов
  S1;...; Sn. Для оператора repeat S1;...; Sn until False ге-
  нерируется бесконечный цикл  выполнения  последовательности
  операторов S1;...;Sn (никаких команд проверки условия конца
  цикла при этом не пораждается)

   Тот факт , что при компиляции оператора if  с  константным
условием генерируется код только для одной альтернативы, соз-
дает возможность условной компиляции программы. Пусть, напри-
мер, вы разрабатываете сложную программу и предполагаете, что
ее отладка может потребовать значительных усилий. Для  облег-
чения отладки удобно вставить в программу операторы,  которые
будут выводить полезную для отладки информацию; в рабочем ва-
рианте такие операторы вам, конечно, не нужны. Чтобы  не  вы-
полнять вставку отладочных операторов всякий раз, при обнару-
жении ошибки, и их удаления после исправления  ошибки,  можно
поступить следующим образом. Заведите константу  Debug  (типа
boolean) и во всех местах, где  вы  хотите  иметь  отладочные
операторы, напишите:

   if Debug
   then begin отладочные операторы end;

Теперь, если вы в начале программы поместите:

   const Debug=True;

то в результате компиляции  вы  получите  отладочный  вариант
программы, в котором отладочные операторы присутствуют.  Если
же вы замените это описание на:

   const Debug=False;

то в результате компиляции получите рабочий вариант  програм-
мы, в котором отладочных операторов нет.
   Оператор while True do S; употребляется довольно часто  (в
тех случаях, когда необходимость прекращения цикла  определя-
ется внутри тела цикла, и выход из цикла  выполняется  с  по-
мощью оператора goto);точно также может быть использован опе-
ратор repeat S1;...; Sn until  False;  оптимизация  вариантов
while False do S; и repeat S1;...; Sn until True; введена для
единообразия - хотя, возможно, вам удастся найти какое-нибудь
применение для них.
   При компиляции оператора for отдельно рассматриваются слу-
чаи, когда одна или обе из границ диапазона  изменения  пере-
менной цикла заданы константными выражениями. В таких случаях
компилятор генерирует существенно более компактную последова-
тельность команд входа в цикл. Это дает  заметный  выигрыш  в
длине программы, т.к. обычно  большинство  операторов  for  в
программе имеют константные границы. Других оптимизаций цикла
(как, например, вынесение вычисления инвариантных  подвыраже-
ний за пределы цикла) не выполняется - мы  не  нашли  способа
реализовать такие оптимизации в однопроходном компиляторе.
   При компиляции оператора case выражение  of  ...  отдельно
рассматриваются случаи, когда значение выражения является од-
нобайтовым и когда оно является двухбайтовым. В тех  случаях,
когда значение выражения является однобайтовым,  генерируется
более компактный код сравнения его с альтернативами.  Случай,
когда выражение в операторе case является константным,  никак
специально компилятором не обрабатывается.

   6.2. Устранение кода неиспользуемых
        процедур и функций

   Если какая-либо процедура или функция  не  используется  в
программе, то ее код не будет включен в результат компиляции.
Это оказывается полезным в тех случаях, когда  вы  заготовили
некоторые пакеты процедур и включаете их в свою программу ди-
рективами {$1 имя файла}. В конкретной  программе  могут  ис-
пользоваться не все процедуры пакета; удалять  вручную  неис-
пользуемые в данной программе процедуры из inklude-файла  не-
удобно, да и приводит к возникновению многочисленных вариан-
тов одного файла, что не облегчает работу. Система EP  выпол-
няет необходимые действия автоматически. Если ваша  программа
использует только часть процедур какого-либо модуля, то  ком-
пилятор автоматически исключит остальные процедуры из резуль-
тата компиляции.
   Процедура (функция) A является используемой, если выполне-
но хотя бы одно из условий:
   - идентификатор A встречается в описаниях типизированных
     констант или в неустраненных операторах главного блока
   - идентификатор A встречается в описаниях типизированных
     констант или в неустраненных операторах процедуры
     (функции) B, и B есть используемая процедура (функция)
(Устраненные операторы - это операторы, находящиеся  в  невы-
полняемой альтернативе оператора if  с  константным  условием
или в теле оператора while False do S;. Таким  образом,  если
идентификатор A встречается лишь в конструкции вида:

   if False then A;

то процедура A будет неиспользуемой. Одним из следствий этого
будет то, что если вы вставляете в программу отладочные  опе-
раторы так, как это было описано в предыдущем  разделе,  и  у
вас имеются процедуры, используемые только  для  отладки,  то
при компиляции рабочего варианта программы они будут  автома-
тически исключены.)
   Для того, чтобы процедура считалась  используемой,  доста-
точно  любого  вхождения  ее  идентификатора  в  используемую
часть. В частности, достаточно появления идентификатора в ка-
честве аргумента операции @. Поэтому даже если вы не  вызыва-
ете явно в своей программе какую-либо процедуру, а только пе-
редаете адрес входа в нее в какую-то другую  процедуру  (воз-
можно, написанную на ассемблере), компилятор все  равно  рас-
познает такую процедуру как используемую. Пожалуй, единствен-
ный способ обмануть компилятор представляет собой что-то вро-
де:

   procedure p1;
           begin                {это команда перехода на}
           inline ($C3/*+3); {команду, расположенную сразу}
   end;                     {вслед за процедурой Р1}
   procdure p2;    {идентификатор p2 не упоминается в p1}
           begin ... end;  {но из p1 выполняется перход в p2}

- но упаси вас бог от такого стиля программирования!
   По синтаксису  Pascal'я  процедура  P',  описанная  внутри
блока процедуры P, может использоваться только в блоке проце-
дуры P (включая вложенные в него блоки).  Поэтому  компилятор
после завершения компиляции процедуры P решает вопрос об  ис-
пользовании описанных внутри ее процедур и , при необходимос-
ти, выполняет устранение неиспользуемого кода; далее процеду-
ра P вместе со всеми описанными внутри нее  процедурами  рас-
сматривается как единое целое (и целиком  будет  удалена  или
сохранена). Устранение кода неиспользуемых процедур,  описан-
ных на верхнем уровне, выполняется после завершения  компиля-
ции всей программы. Действия  по  устранению  неиспользуемого
кода выполняются параллельно с действиями по совмещению памя-
ти для локальных переменных независимых  процедур  и  функций
(это описано в следующем разделе).
   Действия по устранению кода неиспользуемых процедур требу-
ют заметного времени - особенно если программа большая и  со-
держит много неиспользуемых процедур. При компиляции програм-
мы, содержащей 150...200 процедур, из  которых  10..20  неис-
пользуемые, это время может составлять 10...15 сек (с  затра-
тами на совмещение памяти для локальных переменных).


   6.3. Совмещение памяти для локальных переменных
           независимых процедур и функций.

   Семантика Pascal'я определяет стековую дисциплину  выделе-
ния памяти для локальных переменных процедур и  функций.  Это
означает следующее. Имеется некоторая область  памяти,  отве-
денная для локальных переменных; в начале выполнения програм-
мы она вся считается свободной. При входе в процедуру в  этой
области выделяется память для локальных переменных процедуры;
после завершения работы процедуры выделенная при входе память
освобождается. При повторном входе в процедуру память выделя-
ется снова - но , возможно, уже в другом месте области.
   Эта стратегия распределения памяти для локальных  перемен-
ных хороша тем, что требуемый для локальных переменных  объем
памяти сведен к минимуму. Второе достоинство этой стратегии -
она соответствует семантике рекурсивных процедур.
   Однако, эта стратегия имеет и крупный  недостаток:  адреса
локальных переменных неизвестны на этапе компиляциии,и должны
вычисляться в процессе выполнения  программы.  Компилятор  EP
выделяет память для локальных переменных на этапе компиляции.
   Для рекурсивных процедур и функций при этом приходится вы-
полнять дополнительные действия: при входе в  них  содержимое
их поля локальных переменных запоминается в аппаратном стеке,
а при выходе восстанавливается оттуда. Такой подход к  реади-
зации рекурсивных процедур и функций вызывает одно  ограниче-
ние: рекурсивные процедуры и функции не могут иметь  парамет-
ров, передаваемых по ссылке.
   При выделении памяти для локальных  переменных  компилятор
пытается, по возможности, уменьшить обший размер поля локаль-
ных переменных за счет совмещения памяти для локальных  пере-
менных различных процедур и функций. Это выполняется на осно-
ве следующих соображений.
   Мы будем говорить, что процедура (функция) А ссылается  на
процедуру (функцию) B, если либо в процедуре  А  используется
идентификатор из B, либо процедура А ссылается  на  процедуру
C, которая ссылается на процедуру B. Две процедуры называются
независимыми, если ни одна из них не ссылается на другую. Ес-
ли две процедуры являются независимыми, то память для их  ло-
кальных переменных может быть совмещена.
   Совмещение памяти для локальных переменных имеет одним  из
следствий то, что при повторном входе в процедуру  содержимое
локальных переменных может не совпадать с тем, что  было  там
при предыдущем обращении. Это полностью соответствует  семан-
тике Pascal'я; мы обращаем на это специальное внимание  пото-
му,что в системе Turbo Pascal v.2.0 локальные переменные име-
ют тип own. В системе EP для создания own переменных вы може-
те  использовать  типизированные  константы   (типизированные
константы - это переменные с начальными значениями, и их зна-
чения не изменяются от одного вызова процедуры к другому).


   6.4. Вычисление константных подвыражений.

   Если арифметическое выражение содержит константное  подвы-
ражение (т.е. подвыражение, все  операнды  которого  являются
константами), то такое подвыражение вычисляется на этапе ком-
пиляции. Например, оператор:

   x:=1+2+3;

будет скомпилирован так же, как оператор:

   x:=6;

   Более актуальным является  упрощение  программы  в  случае
вроде:

const dim=5;
var xxx: array [0..dim-1] of real;
....
for i:=0 to dim-1 do xxx[i]:=0;
....

   Здесь значение dim-1 будет вычислено на этапе компиляции.
   Но наибольший эффект вычисление  константных  подвыражений
дает в адресной арифметике. Процесс вычисления адреса,  соот-
ветствующего ссылке на переменную, рассматривается компилято-
ром так же, как и процесс вычисления арифметического  выраже-
ния с операндами типа word. Поэтому, если у вас  в  программе
используются статические ссылки на переменную, то  они  будут
вычислены на этапе компиляции, и в  результирующей  программе
будут присутствовать только готовые адреса. Например, в  слу-
чае:

var yyy ; record
a : array [1..7] of word;
b : array [1..7] of word;
end;
...
yyy.a[5] :=yyy.b[3];
...

результат компиляции оператора  присваивания  будет  состоять
только из двух команд.
   Если вы расчитываете на то, что в вашей программе какие-то
константные подвыражения будут вычислены при компиляции, пом-
ните, что компилятор не использует ни коммутативности ни  ас-
социативности арифметических операций (поскольку компьютерная
арифметика не обладает этими свойствами !).  Поэтому  выраже-
ние: 

1+x+2

не будет упрощено. обратите внимание на то, что и выражение:

x+1+2

упрощено не будет: в случае отсутствия скобок подразумевается
порядок выполнения операций слева направо; поэтому  приведен-
ное выражение есть то же самое, что и:

(x+1)+2

- а здесь, как легко видеть,  константных  подвыражений  нет.
Чтобы такое выражение упростилось, нужно записать его с явной
расстановкой скобок:

x+(1+2)

или изменить порядок операндов:

1+2+x

т.к. последнее соответствует расстановке скобок:

(1+2)+x


   6.5. Локальная оптимизация кода

   Последний элемент  оптимизации,  выполняемый  компилятором
EP, есть локальная оптимизация кода.
   Генератор кода всегда порождает код, исходя из общих прин-
ципов. Этот код поступает на  вход  локального  оптимизатора.
который выделяет некоторые последовательности команд и  упро-
щает их.
   Например, код для операции сложения значений типа  integer
или word строится так: сначала вычисляется  значение  правого
операнда (результат получается на  регистре  HL);  затем  его
значение отправляется в стек (чтобы  регистры  были  свободны
для вычисления левого операнда); затем  вычисляется  значение
левого операнда (результат получается на регистре HL);  после
этого значение правого операнда извлекается из  стека  в  ре-
гистр DE и выполняется операция сложения. В случае, когда вы-
числения левого операнда не требуется (он есть значение пере-
менной с константным  адресом)  сохранение  значения  правого
операнда в стеке является излишним; упрощение  кода  в  таком
случае и будет выполнено локальным  оптимизатором.  Например,
для выражения:

x+y

первоначально будет сгенерирована последовательность команд:

LHLD x
PUSH H
LHLD y
POP D
DAD D

   Локальный оптимизатор заменит эту  последовательность  ко-
манд на:

LHLD x
XCHG
LHLD y
DAD D

   Локальный оптимизатор упрощает около 20  последовательнос-
тей команд.
   Применение локального оптимизатора дает заметный  вклад  в
сокращение кода и повышение скорости выполнения программы.






















































                   Ч А С Т Ь  2

           О П И С А Н И Е   Я З Ы К А



   ГЛАВА 1
   ЛЕКСЕМЫ И КОНСТАНТЫ


   Лексемы являются наименьшими осмысленными единицами текста
программы на языке паскаль. Они подразделяются на 5  классов:
специальные символы, идентификаторы, метки, числовые  и  сим-
вольные константы.
   Программа на языке паскаль состоит из лексем и  разделите-
лей. Разделителями считаются: пробел, конец строки и  коммен-
тарий. Если каждая из двух подряд идущих лексем является  за-
резервированным словом, идентификатором, меткой или  числовой
константой, то они должны быть разделены по краеней мере  од-
ним разделителем.
   Разделители не могут быть частью  лексем  (за  исключением
случая, когда они входят в символьные константы).

   Для того, чтобы прочитать синтаксическую  диаграмму,  дви-
гайтесь вдоль стрелок. Часто имеется  несколько  возможностей
для продолжения пути. Любой путь, ведущий из левого  верхнего
угла диаграммы в правый нижний, соответствует правильной син-
таксической конструкции. На путях встречаются слова и  знаки,
заключенные в прямоугольники и  овалы.  Заключенные  в  овалы
(зарезервированные слова, операторы и знаки пунктуации)  есть
элементы языка: ровно в том виде, каком они приведены в диаг-
рамме, они должны использоваться в программе.  Заключенное  в
прямоугольники есть названия синтаксических конструкций;  они
определены в других диаграммах. Перед входом в диаграмму рас-
положено название  синтаксической  конструкции,  определяемой
данной диаграммой (оно не заключено в рамку).

   1.1. Специальные символы и зарезервированные слова.

   EP использует следующее множество символов:

- Буквы - буквы латинского алфавита A...Z и a...z
- Цифры - цифры 0...9
- 16-ричные цифры - цифры 0...9 и  латинские  буквы  A...F  и
  a...f
- Пробел - символ пробела (ASCII=32).

   Специальные символы и зарезервированные слова - это симво-
лы или  последовательности  символов,  имеющие  фиксированный
смысл.
   Следующие пары символов также являются спецсимволами:

+ - * / = < > [ ] . , ( ) : ; /\ @ { } $ #

<> <= >=  := .. (* *) (. .)

   Часть спецсимволов является знаками операций.
[ эквивалентна (. , а ] эквивалентна .)  .

   В EP зарезервированными словами являются следующие:

absolute   end                  interface  program  unit
and        file                 label      record   until
array      for                  mod        repeat   uses
begin      forward              nil        set      var
case       function             not        shi      while
const      goto                 of         shr      with
div        if                   or         string   xor
do         implementation       packed     then
downto     in                   private    to
else       inline               procedure  type

   В языке EP в ключевых словах и идентификаторах прописные и
строчные буквы отождествляются.


   1.2. Идентификаторы.

   Идентификаторы  обозначают  константы,  типы,  переменные,
процедуры, функции, программы, модули и поля записей. Иденти-
фикатор может быть любой длины, но не длиннее строки.

Идентификатор константы
Идентификатор типа           Идентификатор
Идентификатор переменной
Идентификатор процедуры      уточненный Идентификатор
Идентификатор функции


Идентификатор программы
Идентификатор модуля         Идентификатор
Идентификатор метки
Идентификатор поля


Идентификатор               буква

                                           буква

                                           цифра

                                             _


   Идентификатор должен начинаться с буквы, за которой  могут
идти буквы, цифры и символ подчеркивания _ (ASCII=95).
ВНИМАНИЕ!!! - русские буквы в Идентификаторах не допускаются!
Пробелы внутри идентификатора не допускаются!  Идентификаторы
можно записывать как большими,так и маленькими буквами.  Мак-
симальная длина идентификатора, как и строки - 127  символов.
Все литеры в идентификаторе являются значимыми.
   Что такое уточненный идентификатор, описано в разделе 2.3.

   1.3. Метки.

   Метка есть целое число от 0  до  9999  или  идентификатор.
Метки используются в предложении goto. Возможность  использо-
вать идентификаторы в качестве меток является расширением  по
сравнению со стандартом языка Pascal.


   1.4. Числовые константы.

   Для записи целых и вещественных констант используется  об-
щеупотребительная десятичная нотация. В  вещественных  числах
дробная часть отделяется от целой точкой (.) . Перед  16-рич-
ными целыми константами ставится символ $. Для записи  вещес-
твенных констант может быть использована экспоненциальная но-
тация, при которой за числом пишется латинская буква Е или е,
а за ней показатель степени. Например, 7Е-2; 1.2е+6; 3.2е4  .
   Числовые константы с  десятичной  точкой  или  показателем
считаются вещественными. Остальные десятичные  числовые  кон-
станты   считаются   целыми;   диапазон   представления    от
-2147483648 до 2147483648.
   16-ричные константы считаются целыми; диапазон представле-
ния от $00000000 до $FFFFFFFF. Знак 16-ричной константы зада-
ется значением старшего бита.


   1.5. Строки символов.

   Строка символов - это последовательность из нуля или более
символов, записанная в одной строке программы и заключенная в
апострофы (' '). Строка символов,  не  содержащая  ни  одного
символа между апострофами, является пустой строкой. Два  под-
ряд идущих в символьной строке апострофа  означают  одиночный
апостроф. Длина строки символов - количество  символов  между
апострофами; длина пустой строки равна нулю.
   В качестве расширения стандартного  Паскаля  EP  позволяет
включать в символьную строку управляющие символы.  Знак  #  и
следующее за ним целое число без знака в диапазоне  от  0  до
255 означает символ с кодом, равным этому числу.  Разделители
между # и числом не допускаются. Если  несколько  управляющих
символов являются частью символьной  строки,  то  разделители
между ними также недопустимы.
   Символьная строка нулевой длины (пустая строка) совместима
только со строковыми типами. Строка символов единичной  длины
совместима с любым символьным или строковым типом. Символьная
строка длины n, при n>=2, совместима с любым строковым типом,
а также с упакованным массивом из n символов.


   1.6. Описание константы.

   Описание константы определяет идентификатор, который обоз-
начает константу внутри  блока,  в  который  входит  описание
константы. Идентификатор константы не может  входить  в  свое
собственное определение.
   Важным расширением языка EP  по  сравнению  со  стандартом
Паскаля является возможность использовать в описании констан-
ты константное выражение. Константное выражение есть  выраже-
ние, все операнды которого  являются  константами.  Структура
выражения описана в главе 6.
   Кроме описания константы, константное выражение может быть
использовано везде, где по  синтаксису  стандартного  Паскаля
требуется константа.  Это  позволяет,  например,  включать  в
программу такой фрагмент:

const nr-of-elem=10;
type arr-of-elem=array [0...nr-of-elem-1] of real;


   1.7. Комментарии

   Следующие последовательности символов являются комментари-
ями и игнорируются компилятором:

   {любой текст, не содержащий правой фигурной скобки }
   (*любой текст , не содержщий пары: звездочка, правая круг-
     лая скобка *)

Это примеры комментариев. Обратите внимание на то,  что  ком-
ментарий, открытый фигурной  скобкой  {,  должен  завершиться
также фигурной скобкой } ; встречающиеся в таком  комментарии
последовательности *) будут рассматриваться как часть коммен-
тария. И наоборот.
   Комментарий может продолжаться на  несколько  строк.  Если
программа состоит из нескольких файлов, то ни один из коммен-
тариев не может выходить за пределы одного  файла  (коммента-
рий, начавшийся в некотором файле, должен в нем же  и  закон-
читься).
   Комментарий, в котором сразу после открывающейся скобки  {
или (* идет знак $, является директивой компилятора. Директи-
вы компилятора описаны в главе 12.


   1.8. Строки программы

   Строки программы на языке EP имеют максимальную длину  127
литер.




   ГЛАВА 2

   БЛОКИ И ОБЛАСТИ ВИДИМОСТИ


   Блоки строятся из описаний, которые могут следовать в  лю-
бом порядке и предложений. Всякий блок является частью проце-
дуры, функции или модуля. Все идентификаторы и метки, описан-
ные в блоке, являются для него локальными.


   2.1. Синтаксис

   Всякий блок имеет следующую структуру:


блок       раздел описаний      раздел операторов


раздел
описаний           раздел описания меток
                   раздел описания констант
                   раздел описания типов
                   раздел описания переменных
                   раздел описания
                   процедур и функций


   Раздел описаний меток есть место, в  котором  определяются
метки, помечающие операторы из соответствующего раздела  опе-
раторов.


раздел описания    label        метка      ;
меток


   Раздел описания констант состоит из описания констант, ло-
кальных в данном блоке.


раздел               const      описание
описаний                        константы
констант   private
                                описание
                                типизированной
                                константы


   Раздел описания типов включает описание всех типов из дан-
ного блока.


раздел                type      описание типа
описаний
типов
           private


   Раздел описания переменных состоит из описания переменных,
локальных для данного блока.


раздел                var       описание
описаний                        переменных
переменных
            private


   Раздел описания процедур и  функций  состоит  из  описания
процедур и функций, локальных для данного блока.


раздел описания                 описание процедуры
процедур и функций              описание функции



   Раздел операторов определяет операторы, или  алгоритмичес-
кие действия, выполняемые в данном блоке.


раздел
операторов         составной оператор


   В языке EP не  требуется  определенного  порядка  разделов
описаний в блоке (в отличие от стандартного  Паскаля).  Более
того, один и тот же раздел описаний может несколько раз появ-
ляться в блоке. Например, вы можете определить несколько  ти-
пов, потом переменные этих типов, потом новые типы и т.д.
   Зарезервированное слово private может появиться перед  лю-
бым описанием, однако эффект оно оказывает только для  описа-
ний в interface-части модуля. Идентификаторы, вводимые описа-
ниеми, начинающиеся словом private , невидимы из других моду-
лей и программ. Подробнее эффект применения и возможности ис-
пользования private описаны в разделе 2.4. настоящей главы.


   2.2. Блоки и правила видимости.

   Вхождение идентификатора или метки в раздел описания опре-
деляет идентификатор или метку. Всякий раз, когда идентифика-
тор или метка встречаются снова, они должны находиться в  об-
ласти видимости. Область видимости идентификатора  или  метки
начинается с его описания  и  заканчивается  концом  текущего
блока (включая внутренние блоки текущего блока), за  исключе-
нием следующих случаев:

** Переопределение во внутреннем блоке. Предположим, что  Ex-
terior есть блок, содержащий другой блок - Interior.  Если  в
этих блоках описан один и тот же идентификатор (J), то внутри
Interior до появления описания J будет  доступен  идентифика-
тор, который описан в Exterior; после  появления  описания  J
будет доступен заданный этим описанием идентификатор (а иден-
тификатор, описанный в Exterior, будет недоступен).

** Позиция описания внутри блока. Идентификаторы и  метки  не
могут быть использованы до того места,  где  они  определены.
Описание идентификатора или метки должно предшествовать любо-
му другому вхождению этого идентификатора или метки в текст -
за одним исключением: базовый тип указателя может быть  иден-
тификатором, который еще не определен. Однако, этот идентифи-
катор должен быть определен в том же разделе описания  типов,
что и указатель.
   Например:

type t1=/\t2;                   {идентификатор t2 здесь еще}
                                {не определен}
t2=record cont:real;            next:t1end;


** Переопределение внутри блока. Идентификатор или метка  мо-
жет быть определен в данном блоке только один раз. Единствен-
ноеисключение - когда идентификатор является  идентификатором
поля записи. Идентификатор поля  записи  определяется  внутри
описания типа записи, и далее имеет  смысл  только  вместе  с
ссылкой на переменную  этого  типа.  Вы  можете  использовать
идентификатор поля в том  же  блоке  для  обозначения  других
объектов - но не для обозначения полей на том же уровне внут-
ри описания того же типа записи. Например:

type t=record
a:integer;
b:record a, b:real end;
end;
var a:string;


** Идентификатор модуля не может быть  предопределен  никаким
способом.


   2.3. Видимость идентификаторов, описанных в модулях.

   Если ваша программа (модуль) содержит предложение:

uses Unit1, Unit2,...,UnitN;

то в ней доступны идентификаторы, описанные в  interface-час-
тях модулей Unit1, Unit2,...,UnitN.
   Видимость идентификаторов из этих модулей определяется  по
следующим принципам. Считается , что имеется блок, в  котором
описаны идентификаторы модуля Unit1; в него  вложен  блок,  в
котором описаны идентификаторы  модуля  Unit2;  и  т.д.  Ваша
программа (модуль) рассматривается как блок, вложенный в блок
модуля UnitN.
   Кроме того, все стандартные идентификаторы считаются опре-
деленными в модуле System,  образующем  самый  внешний  блок;
этот модуль считается используемым в любой программе.
   Поскольку все стандартные и используемые в модулях иденти-
фикаторы считаются определенными во внешних блоках, вы можете
в своей программе переопределить любой из них. Но и после пе-
реопределения вы можете сослаться на стандартный  идентифика-
тор или на идентификатор, определенный в  модуле,  с  помощью
уточненного идентификатора.


уточненный         идентификатор           идентификатор
идентификатор      модуля


   Например, в вашей программе может появиться:

var str=string [80];

и далее:

System.Str (123:5, str);

Это - вызов стандартной процедуры Str; вторым параметром  бу-
дет описанная вами переменная str.
   ВНИМАНИЕ!!! Не путайте стандартные идентификаторы с  заре-
зервированными словами! Зарезервированные слова хотя и похожи
внешне на идентификаторы, таковыми не являются, и поэтому  не
могут быть переопределены.


   2.4. Описатель private.

   Зарезервированное слово private, поставленное перед описа-
нием в interface-части модуля (о структуре модуля  см.  главу
9) делает идентификаторы, вводимые данным описанием,  невиди-
мыми из использующих данный модуль программ и модулей.
   Мы будем ссылаться на приводимый ниже пример при  описании
возможностей использования описателя private.

init xxx;
interface
   private const a=1;
                 b=2;
   private type    tab=a..b;
                   tx=array [a..b] of real;
                   ty=record;
                                f1:integer;
                                f2:tx;
                                end;
   type    tab1=tab;
           tx1=tx;
           tx2=array [0..b] of integer;
           tx3=array [tab] of shar;
           ts1=set of tab1;

   var     x1:tx;
           x2:tx1;
           ab1:tab;

   private var     x3:tx;
                   y2:ty;
                   x4:tx1;

   const   cx1:tx=(1.1. 1.2);
           cy1:ty=(f1:1; f2:(1.3, 1.4));

   private const   cx2:tx1=(1.0, 2.0);
                   c1:integer=2;

   procedure       p1(m1:integer; m2:tx1);
   procedure       p2(m1:tx; m2:ty);
   function        f1(m1:tx1);tab;

   Privite procedure            p3;
   privite function             f2:byte;


   В примере идентификаторы констант а и b, типов tab,  tx  и
ty, полей записи f1 и f2, переменных x3, y2 и  x4,  типизиро-
ванных констант cx2 и c1, процедуры p3, функции f2 невидимы в
программах и модулях, использующих модуль xxx. В пределах мо-
дуля xxx они подчиняются обычным правилам видимости (как  без
описателя private).
   Применение private уместно только для идентификаторов  ти-
пов и нетипизированных констант.  Использование  private  для
переменных (в примере x3,y2,x4) и для типизированных констант
(cx2,c1) эквивалентно перенесению этих описаний в implementa-
tion-часть модуля; использование private для процедур и  фун-
кций (p3,f2) эквивалентно удалению этих описаний из  interfa-
ce-части модуля. Допустимость таких конструкций  введена  для
единообразия.
   Если в модуле есть переменная, тип которой является priva-
te-типом (в примере-tx1), то все, что может с ним делать дру-
гой модуль (или программа) - это присваивать переменной иден-
тичного типа (в примере-x2) или передавать в  качестве  пара-
метра (в примере -вторым параметром p1, первым параметром  p2
и f1).
   Если в модуле есть видимый тип, объвленный идентичным pri-
vate-типу (в примере-tx1), то во внешнем модуле можно  созда-
вать переменные этого типа, но единственное, что  можно  сним
делать, - это присваивать переменным идентичных типов и пере-
давать в качестве параметров.
   Если в модуле имеется видимый тип, отдельные части которо-
го описаны с помощью private-типов, то  для  внешнего  модуля
соответствующим образом ограничиваются возможности  работы  с
переменными этого типа. В примере: вы можете завести перемен-
ную в своей программе типа tx3; про нее будет  известно,  что
она является массивом с элементами типа integer - но для  ин-
дексирования может быть использована  только  переменная  ab1
или результат функции f1, т.к. только они  имеют  нужный  тип
(tab), а внешний модуль не может завести переменную или  кон-
станту типа tab. При этом система обеспечивает правильное ин-
дексирование и проверку выхода за границы  массива.  Подобно,
но не аналогично: можно завести переменные типа ts1; про  них
будет  известно,  что  они  являются  множествами,  и,  соот-
ветственно, к ним могут применяться все допустимые  для  мно-
жества операции; базовый тип их - tab1;  вы  можете  заводить
переменные типа tab1, но не можете задать ни одной  константы
такого типа ( и поэтому не можете построить непустую констан-
ту-множество типа ts1).
   Видимый тип Т, объявленный идентичным private-типу,  может
быть использован во внешнем модуле для конструирования  новых
типов. Но - как бы ни был описан private-тип - во внешнем мо-
дуле тип Т не является упорядоченным, и поэтому не может быть
использован в качестве типа индексов массива или  в  качестве
базового типа множества. В примере: во внешнем модуле  нельзя
написать "set of tab1" - но внутри модуля xxx  это  возможно,
так определен тип ts1. Несколько  неожиданный  эффект,  но  в
этом состоит одна из целей введения private-типов.



   ГЛАВА 3

   ТИПЫ


   Когда вы описываете переменные,вы должны указать их  типы.
Тип переменной определяет множество значений, которые она мо-
жет принимать, и набор операций, которые над ней можно выпол-
нять. Описание типа определяет идентификатор, который обозна-
чает тип.


описание   идентификатор   =       тип   ;
типа


тип        простой тип
           составной тип
           указательный тип
           строковый тип
           идентификатор типа


   Идентификатор, находящийся в левой  части  описания  типа,
определяется как идентификатор типа для блока, в который вхо-
дит данное описание типа. Область видимости такого  идентифи-
катора не включает его описания, за исключением типа указате-
ля.
   Мы будем различать следующие 4 вида типов:

- простые типы
- структурные типы
- типы указателей
- строковые типы

   Среди простых типов будем различать упорядоченные  типы  и
веществееный тип; среди упорядоченных  типов  будем  выделять
целочисленные типы.


   3.1. Простые типы.

   Простые типы делятся на упорядоченные типы и  вещественный
тип.


простой            упорядоченный тип
тип                вещественный тип


   В разделах "Числа" и "Строковые константы" главы 1 описано
как задавать константы простых типов.


   3.1.1. Упорядоченные типы.

   Упорядоченные типы являются частным случаем простых типов.
Все простые типы , отличные от вещественного, являются упоря-
доченными. Упорядоченные типы имеют 4 основные  характеристи-
ки:

** Все возможные значения упорядоченного типа образуют упоря-
доченное множество. С каждым возможным значением  связан  по-
рядковый номер, который является целым числом. За исключением
целочисленных типов, первое значение имеет  порядковый  номер
0, следующее за ним - 1, и т.д. Порядковый номер значения це-
лочисленного типа есть оно само. Во всех упорядоченных  типах
каждое значение, за исключением первого, имеет предшественни-
ка, и каждое значение, за исключением последнего, имеет  пос-
ледователя.

** Стандартная функция Ord может быть  применена  к  значению
любого упорядоченного типа; она возвращает  порядковый  номер
значения.

** Стандартная функция Pred может быть применена  к  значению
любого упорядоченного  типа;  она  возвращает  предшествующее
значение. Если функция применяется  к  первому  значению,  то
возникает ошибка.

** Стандартная функция Succ может быть применена  к  значению
любого упорядоченного типа; она возвращает  следующее  значе-
ние. Если функия применяется к последнему значению, то возни-
кает ошибка.
   В EP имеется 7 предопределенных  упорядоченных  типов:  их
идентификаторы: byte, shortint, word, integer,  longint,  bo-
olean, char.
   Имеются еще 2  класса  упорядоченных  типов,  определяемых
пользователем: перечислимые типы и отрезки.

                   отрезок
                   перечислимый тип
                   идентификатор
                   упорядоченного типа


   3.1.1.1. Целые типы.

   Имеется пять предопределенных целых типов; их  идентифика-
торы: byte, shortint, word, integer, longint.
   Множество значений каждого из этих типов есть подмножества
множества целых чисел.
   Арифметические операции над операндами целых типов  выпол-
няются с 8-, 16- или 32-битовым представлением в  зависимости
от контекста, в котором они появляются.  Правила  определения
типа, с которым производится вычисление значения арифметичес-
кого выражения, описаны в главе 6.
   Все константные подвыражения всегда вычисляются  на  этапе
компиляции. Вычисление константных подвыражений выполняется с
32-битовым представлением. Тип значения константного подвыпа-
жения есть предопределенный целый тип с минимальными граница-
ми, содержащий значение константного подвыражения.
   Любое значение целого типа может  быть  явно  приведено  к
другому целому типу с помощью преобразователя типа значения.


   3.1.1.2. Тип Boolean.

   Тип boolean имеет 2 значения: они обозначаются  с  помощью
предопределенных констант true и false.Тип boolean есть пери-
числимый тип. Для значений типа boolean выполняются следующие
соотношения:

false<true
ord(false)=0
ord(true)=1
succ(false)=true
pred(true)=false


   3.1.1.3. Тип char

   Множество значений этого типа есть множество литер, упоря-
доченное в соответствии с их ASCII-кодами. Функция ord,  при-
мененная к значению типа char, возвращает ASCII-код литеры.
   Строковая константа длины 1 может обозначать константу ти-
па char. Все значения типа char могут быть получены с помощью
стандартной функции Chr.


   3.1.1.4. Перечислимые типы.

   Перечислимые типы определяют упорядоченные множества  зна-
чений с помощью перечисления идентификатора,которые обознача-
ют эти значения.  Порядок  значений  задается  последователь-
ностью, в которой порядок значений идентификаторов перечисля-
ется.

перечислимый       (       список идентификаторов       )
тип


список
идентификаторов            идентификатор


   Вхождение идентификатора в список идентификаторов перечис-
лимого типа есть описание этого идентификатора как  константы
данного типа.
   Порядковый номер константы упорядоченного типа определяет-
ся ее позицией в списке идентификатора.  Первая  константа  в
списке имеет порядковый номер 0.
   Например:

suit=(c,d,h,s)

   В соответствии с описанием  c,d,h,s  являются  константами
типа suit; ord(c)=0, ord(d)=1, Ord(s)=3.


   3.1.1.5. Отрезки типов

   Множество значений отрезка типа есть подмножество значений
некоторого упорядоченного типа,  называемого  базовым  типом.
Определение отрезка типа задает верхнюю и нижнюю границы  от-
резка.


отрезок    константное                   константное
           выражение                     выражение


Оба константных выражения должны иметь значения одного и того
же упорядоченного типа. При описании отрезка типа  вида  a..b
требуется, чтобы a <= b. Возможность использовать для  указа-
ния границ отрезков константные выражения является расширени-
ем стандарта языка Паскаль.
   Примеры отрезков типа:

0...16*32-1
-128..127
succ(c)...h

   Переменная отрезка типа имеет все свойства переменной  ба-
зового типа, но ее значения  в  период  исполнения  программы
должны лежать в указанном диапазоне. 


   3.1.2. Вещественный тип (Real).

   Имеется один предопределенный вещественный тип; его  иден-
тификатор real.
   Множество значений типа real есть  подмножество  множества
вещественных чисел. Значения типа real представляются в  фор-
мате с плавающей точкой; они занимают 6 байт. Диапазон значе-
ний от 2*10 39 до 2*10  38;  количество  истинных  десятичных
цифр - 11 или 12 (в зависимости от значения). Подробно способ
представления вещественных чисел описан в главе 13.


   3.2. Строковые типы.

   Значения строкового типа - это последовательность литер.
   С каждым строковым типом связан атрибут длины - максималь-
но возможное число  литер  в  последовательности,  являющейся
значением этого типа. Атрибут длины должен лежать в диапазоне
от 1 до 255.
   Значение строкового типа с атрибутом длины n может  содер-
жать от 0 до n литер. Текущая длина значения строкового  типа
является составной частью значения.

строковый          string
тип                        [       константное      ]
                                   выражение


   Константное выражение, если оно задано, должно иметь целое
значение в интервале от 1 до 255. Если константное  выражение
(вместе с обрамляющими его квадратными скобками) опущено,  то
оно считается равным 255.
   Порядок на множестве строк - лексикографмческий. Это озна-
чает следующее: если первые символы строк s1 и s2  различные,
то больше та строка, у которой первый  символ  больше;  иначе
нужно сравнить вторые символы: и  т.д.  Если  более  короткая
строка совпадает с началом более длинной, то  более  короткая
строка меньше. Например:

'abc'<'xyz'
'xyz<'xyz '

   Тип string[n] во многом похож на тип array[0...n] of char.
Если в вашей программе описана переменнная s типа  string[n],
то вы можете, например, обратиться к второму символу  строки,
написав s[2]. Значение s[0] есть литера с кодом, равным теку-
щему количеству литер в строке.
   ЗАМЕЧАНИЕ. Обратите внимание на то,  что  string  является
зарезервированным словом, а не идентификатором. В  частности,
оно не может быть переопределено; конструкция наподобие:

var string:array[1...22] of byte;

недопустима.


   3.3. Составные типы.

   Основным признаком составных типов является  то,  что  его
значения состоят из нескольких  элементов.  В  свою  очередь,
элементы составного типа сами могут быть составными.  Глубина
вложенности составных типов не ограничена.


составной                          тип массива
тип                                тип записи
                   packed          тип множества
                                   тип файла


   Зарезервированное слово packed должно говорить компилятору
о том, что данные следует размещать в памяти как  можно  ком-
пактнее - возвожно,  за  счет  снижения  скорости  выполнения
программы. В языке EP, однако, оно не оказывает никакого дей-
ствия, т.к. во всех случаях  данные  размещаются  максимально
компактно.


   3.3.1. Тип массива.

   Массив имеет фиксированное число компонент; все они  имеют
один и тот же тип - тип компоненты.


тип        array   [       тип        ]  of     тип
массива                    индекса
                           ,


тип                упорядоченный тип
индекса


   Типы индексов, задаваемые для каждого  измерения  массива,
определяют количество элементов в массиве. Для  типа  индекса
допустимыми являются все упорядоченные типы (в частности, от-
резки) - за исключением типа longint и  его  отрезков.  Коли-
чество элементов массива по каждому измерению равно  количес-
тву значений соответствующего индексного типа. Количество из-
мерений массива не ограничено.

   Примеры:
   array[1...23] of real;
   array[boolean] of array[1...3,-5...3*4] of char;

   Если компоненты массива сами являются массивами, вы можете
трактовать это и как массив массивов, и как многомерный  мас-
сив. Например, конструкция:

array[boolean] of array[1..10] of array[size] of real;

полностью эквивалентна конструкции:

array[boolean, 1...10, size] of real;


   Тип массива вида:

packed array[m...n] of char

называется упакованныммассивом литер (здесь m<=n; слово  pac-
ked может быть опущено, т.к. оно в EP  игнорируется).  Упако-
ванный массив литер обладает рядом свойств, которые не прицу-
щи другим типам массивов (см. раздел "Идентичные и  совмести-
мые типы" далее в настоящей главе).



































































































































































   3.3.2. Тип записи

   Значение типа записи состоит из нескольких  компонент  иле
полей , которые могут иметь различные типы. Описание типа за-
писи определяет типы полей и их идентификаторы. Синтаксис ти-
па записи:

тип                record                       end
записи                      список полей


список             постоянная часть
полей                    ;                      ;
                   переменная часть


постоянная         список                :      тип
часть              идентификаторов
                            ,


переменная    case                     тип       or  вариант
часть              идентификатор   :   признака        :



тип                идентификатор упорядоченного
признака           типа


вариант    константное      .   .                   ;
           выражение                 список полей


   В постоянной части записи задается список  постоянных  по-
лей; для каждого поля указывается его  идентификатор  и  тип.
Поля, находящиеся в постоянной части, не перекрываются с дру-
гими; к информации, находящейся в них, можно получить  доступ
только сославшись на такое поле.
   Пример записи, содержащей только постоянную часть:

record
nr1, nr2:integer;
data:array[0...21,-1...1] of real;
date:record;
year:word;
month:1...12;
day:1...31;
end
end

   В переменной части записи задается список вариантов.  Каж-
дый вапиант содержит список полей,  устроенный  синтаксически
точно так же, как и список полей записи в целом (в частности,
в конце списка полей варианта может снова появиться  перемен-
ная часть). Для всех вариантов переменной части записи  выде-
ляется одна и та же память; память для  записи  с  переменной
частью выделяется такого размера, чтобы в ней мог поместиться
цамый длинный вариант. Константные  выражения,  задаваемые  в
начале каждого варианта, никак не используются  компилятором;
они носят комментирующий характер (однако компилятор требует,
чтобы перед каждым вариантом находилось  хотя  бы  одно  кон-
стантное выражение, и чтобы типы таких константных  выражений
были совместимы с типом признака).  Возможное  поле  признака
имеет тип "тип признака"; оно обладает всеми свойствами полей
постоянной части.
   Содержательное использование переменной части  предполага-
ет, что в каждый момент времени активным является только один
из вариантов, т.е. обращения к полям  переменной  части  осу-
ществляются с помощью идентификаторов , описанных в этом  ва-
рианте. Вопрос о том, какой из вариантов является активным  в
настоящий момент, должен решаться программой  самостоятельно.
Поле признака может быть использовано программой для хранения
информации о том, какой из вариантов является активным.
   С точки зрения компилятора вполне допустимым является  за-
пись информации в поле одного варианта и  последующее  чтение
ее из поля другого варианта. Этим вы  можете  пользоваться  в
своей программе - но будьте внимательны; во всяком случае хо-
рошо разберитесь с форматами представления данных (см.  главу
13). Например , вы можете описать тип:

record
case boolean of
true:(w:word);
false:(1,h:byte);
end

Теперь, обращаясь к полю w, вы получите доступ к целому  сло-
ву; обращаясь к полю 1 - к младшему байту этого слова;  обра-
щаясь к полю h - к его старшему байту. Заметим, что аналогич-
ный результат вы можете получить еще двумя способами:  с  по-
мощью преобразователя типа переменной (см. главу 4) и  с  по-
мощью конструкции absolute при описании переменной.
   Пример записи с переменной частью:

record
x,y,:real;
case kind:figure of
rectangle:(height,width :real);
triangle:(side1,side2,angle :real);
circle:(radius :read);
end

   Все идентификаторы  поле  записи  должны  быть  различными
(включая идентификаторы полей переменной части). Однако иден-
тификаторы полей записи могут совпадать с другими идентифика-
торами, описанными в текущем блоке, с идентификаторами  полей
в других записях и идентификаторами полей в подзаписях.
   Например, можно:

record
a:byte;
b:record a,b:word end
end

но нельзя :

record
a:byte;

case char of
'x':(a,b,c:shortint);
'z':(b,c:word);
end

   Использование для полей записи  идентификаторов,  совпада-
ющих с другими идентификаторами, может быть вполне  осмыслен-
ным; но помните, что это может создать определенные трудности
при использовании оператора with.


   3.3.3. Тип множества.

   Значения типа множества суть подмножества множества значе-
ний некоторого упорядоченного типа - базового типа множества.


тип                  set      of       упорядоченный
множества                              тип


   Базовый тип множества должен содержать не более 256 значе-
ний; порядковые номера верхнего и нижнего его пределов должны
лежать в интервале от 0 до 255. Поэтому, в частности, базовым
типом не может быть shortint, integer, word, longint.
   Всякий тип множества содержит значение [], называемое пус-
тым множеством.


   3.3.4. Тип файла.

   Значение файлового типа есть  линейная  последовательность
компонент, каждая из которых имеет тип компоненты. Тип компо-
ненты может быть любым - за исключением  файлового  типа  или
составного типа, содержащего файловую компоненту. Число  ком-
понент в файловом типе при описании не указывается.


тип файла   file     of       тип


   Если слово of и тип компоненты опущены, то это есть  нети-
пизированный файл. Нетипизированные файлы  суть  каналы  вво-
да/вывода нижнего уровня; они используются для прямого досту-
па к дисковым файлам, и не используют  внутреннюю  логическую
структуру файла.
   Предопределенный файловый тип Text обозначает файл, состо-
ящий из организованных в строки литер. Для работы с текстовы-
ми файлами используются специальные процедуры.
   Подробно возможности работы с файлами описаны в главе 10.


   3.4. Типы указателей.

   значения указанного типа указывают на  динамические  пере-
менные. Тип этих динамических переменных  называется  базовым
типом данного указанного типа.


указательный       /\      базовый тип
тип


базовый тип        идентификатор типа


   Базовый тип может быть не определен к моменту  определения
указанного типа; в таком случае он должен быть определен  да-
лее в том же разделе описания типов. Это позволяет  использо-
вать определения типов наподобие:

type x1: recrd a: real; b:/\x2 end;
x2: record a: longint; b: /\x1 end;

   Вы можете присвоить значение переменной- указателю  с  по-
мощью процедуры New, оператора @ или функции  Ptr.  Процедура
New выделяет область памяти в куче и заносит адрес выделенной
области в переменную-указатель. @-оператор  вырабатываетадрес
переменной,к которой он применен.  Функция  Ptr  вырабатывает
адрец, соответствующий числу, указанному в качестве ее  аргу-
мента.
   Доступ к переменной, на которую указывает  переменная-ука-
затель, можно получить при помощи  операции  разименования  -
записав после имени переменной -указателя знак /\.
   Зарезервированное слово nil обозначает константу -  никуда
не указывающий адрес. Значение nil принадлежит лубому  указа-
тельному типу.
   Предопределенный указательный тип Pointer обозначает нети-
пизированный указатель, т.е. указатель, который не может быть
разыменован: здесь /\ после имени переменной типа Pointer яв-
ляется ошибкой. Тип Pointer совместим с любым  другим  указа-
тельным типом.
   Подробнее возможности работы с указательными типами описа-
ны в главах 4 и 6.


   3.5. Идентичные и совместимые типы.

   Для характеристики возможностей совместного  использования
объектов различных типов важными понятиями являются  идентич-
ность типов, совместимость типов и совместимость типов  отно-
сительно присваивания.


   3.5.1. Идентичность типов.

   Идентичность типов требуется только для фактических и фор-
мальных параметров поцедур и функций, передаваемых по ссылке.
Кроме того, понятие идентичности используется при определении
понятий совместимости и совместимости относительно присваива-
ния.
   Ввиду наличия private -типов типы, идентичные в одном  мо-
дуле, могут оказаться не идентичными в другом модуле.
   Начнем с нескольких вспомогательных определений.
   Тип Т1 называется эквивалентным типу Т2, если он определен
с помощью конструкции вида:

type T1=T2;

   Для каждого типа определим его конечный тип в модуле U:

** если Т1 есть видимый в модуле U идентификатор типа и  если
Т1 объявлен эквивалентным идентификатору типа Т2, то конечным
типом для Т1 в модуле U является конечный тип для Т2 в модуле
U
** во всех остальных случаях кончным типом для типа Т1  явля-
ется он сам.

   Теперь два типа называются идентичными, если  их  конечные
типы совпадают.
   Например, при следующем описании типов:

type t1=integer;
t2=t1;
t3=t2;
t4=t1;
t5=integer;

типы t1, t2, t3, t4, t5 и integer будут идентичными.
   Обратите внимание, что при описании:

type t6=set of char;
     t7=set of char;

типы t6 и t7 не являются идентичными, т.к.  set  of  char  не
есть идентификатор типа.
   Две переменные, объявленные в одном и том же описании, по-
лучают идентичные типы, например:

var v1,v2:set of char;

- здесь v1 и v2 имеют идентичные типы.
   Однако, если переменные объявлены в  различных  описаниях,
они получат идентичные типы лишь в том случае, когда  указан-
ные при них типы являются идентичными. Например, при описании

var v3:set of char;
v4:set of char;
v5:integer;
v6:integer;

переменные v5,v6 будут иметь идентичные типы, а v3 и v4- нет.
   Рассмотрим пример, в котором используются private-типы

{================модуль Unit1====================}

unit Unit1; interface
type t1=integer;
private type t2=t1;
   t3=integer;
type t4=integer;
t5=t1;
t6=t2;
t7=t3;
t8=t3;
.....
unit Unit1;interface
uses Unit1;
....

   В модуле Unit1 типы t1,...,t8 и integer идентичны  -  пос-
кольку конечным типом для всех них является integer.
   В модуле Unit2 типы t1,t4,t5 и integer идентичны (конечным
типом для них является integer), тип t6 не идентичен им  (ко-
нечным типом для него является невидимый в модуле  Unit2  тип
t2), а типы t7, t8 идентичны между собой (конечным типом  для
них является невидимый в модуле Unit2 тип t3) , но  не  иден-
тичны никаким другим типам.


   3.5.2. Совместимость типов.

   Понятие совместимости типов используется для описания  ло-
пустимух соотношений между операндами в выражениях. Кроме то-
го, понятие совместимости необходимо для определения  совмес-
тимости относительно присваивания.
   Два типа являются совместимыми, если выполняется по  край-
ней мере одно из следующих условий:

-  оба типа являются идентичными
-  оба типа идентичны целым типам или их отрезкам
-  один из типов идентичен отрезку другого
-  оба типа идентичны отрезкам одного и того же базового типа
-  оба типа идентичны типам множества с совместимыми базовыми
   типами
-  один из типов идентичен Pointer, а второй идентичен любому
   указательному типу
-  оба типа идентичны указательным типам с совместимыми
   базовыми типами
-  оба типа идентичны либо типу CHar, либо отрезку типа char,
   либо упакованному массиву литер, либо строковому типу.


   3.5.3. Совместимость относительно присваивания.

   Понятие совместимости типов относительно присваивания  не-
обходима для определения  возможности  присваивания  значения
переменной в операторе присваивания, или при  передаче  пара-
метров процедуры или функции по значению.
   Тип Т2 называется совместимым относительно присваивания  с
типом Т2 (т.е. допустимо присваивание Т1:=Т2), если выполнено
хотя бы одно из следующих условий:

-  Т1 и Т2 являются идентиэными типами , и никакой из них не
   идентичен файловому типу и не идентичен составному типу
   содержащему компоненту файлового типа
-  Т1 и Т2 - совместимые упорядоченые типы
-  Т1 идентичен вещественному типу, а Т2 - целому типу
-  Т1 и Т2 идентичны строковому типу
-  Т1 идентичен строковому типу, а Т2 - литерному типу
-  Т1 идентичен строковому типу, а Т2 - упакованному массиву
   литер
-  Т1 и Т2 идентичны упакованным массивам литер с одинаковым
   числом компонент
-  Т1 и Т2 идентичны совместимым типам множеств
-  один из типов Т1 и Т2 идентичен Pointer , а второй иденти
   чен любому указательному типу.

   Когда требуется совместимость относительно присваивания, а
ее нет, возникает либо ошибка периода исполнения, либо ошибка
компиляции.


   3.5.4. Раздел описания типов.

   Программы, процедуры и функции, в которых определяются но-
вые типы, содержат раздел  описания  типов.  Ниже  приводится
пример раздела описания типов.

type
range           =integer;
number          =integer
color           =(red, green, blue);
testindex       =1...100;
testvalue       =-99..99;
testlist        =array [testindex] of testvalue;
testlistPtr     =^ testlist;
date            =record
                year:integer;
                month:1..12;
                day:1..31;
   end;
measure         =record
                when:date;
                count:testindex;
                data:testlistPtr;
   end;
measurelist     =array [1..50] of measuredata;
name            =string [80];
sex             =(male, female);
person          =^persondata;

persondata      =record
                name, first_name:name;
                age:integer;
                married:boolean;
                father:person;
                case s:sex of
                        male:(bearded:boolean);
                        female:(pregnant:boolean);
   end;

people=file of persondata;
intfile=file of integer;


   В приведенном примере типы range, number и integer являют-
ся идентичными. Тип testindex совместим и  совместим  относи-
тельно присваивания с этими типами, но не идентичен им.  Типы
testlistPtr, person несовместимы, но каждый из них  совместим
с типом Pointer.
   Типы определенные в этом примере, будут использоваться да-
лее в тексте.



   ГЛАВА 4

   ПЕРЕМЕННЫЕ

   4.1. Описание переменных.

   Описание переменных имеет следующий синтаксис:


описание        список              :   тип
переменных      идентификаторов                absolute
                                               конструкция


   Тип, приписываемый переменным, может быть либо идентифика-
тором типа, определенным ранее, либо это может быть новое оп-
ределение типа.
   Вхождение идентификатора в список идентификаторов является
объявлением его как идентификатора переменной. Этот идентифи-
катор может далее до конца блока использоваться для ссылок на
переменную. Этот идентификатор может быть переопределен в ка-
ком-либо внутреннем блоке. Переопределение переменной  делает
ее недоступной в том блоке, в коиором она переопределена,- но
никак не влияет на значение переменной:
   Примеры:
var x,y,z:integer;
error    :boolean;
matrix   :array[1..10, 1..10] of real;

   Переменная, описанная на верхнем уровне блочной  структуры
(вне процедур и  функций),  называется  глобальной;  перемен-
ная,описанная внутри какого-нибудь блока , называется локаль-
ной (по отношению к этому блоку).
   При обработке описания  переменной,  компилятор  выполняет
выделение памяти для этой переменной - если описание перемен-
ной не содержало absolute-конструкции (см. следующий раздел).
Память для переменных  выделяется  в  области  переменных  (о
распределении памяти подробнее см. главу 13).
   При выделении памяти для локальных  переменных  компилятор
при возможности выполняет совмещение памяти (совмещение памя-
ти локальных переменных процедур p1 и p2  возможно,  если  ни
одна из них не вызывает другую). Подробно механизм  выделения
и совмещения памяти описан в главе 7 ч.1 и в главе 13  насто-
ящей части.


   4.1.1. Absolute-конструкция.

   При определении переменной можно дать указание компилятору
разместить ее в определенном , задаваемом программистом, мес-
те памяти. Такое указание дается с помощью absolute-конструк-
ции. Переменные,  в  описании  которых  использована  absolu-
te-конструкция, называются абсолютными переменными.

absolute-       absolute        константное выражение
конструкция                     целого типа
                                константное выражение
                                указательного типа
                                статитическая ссылка
                                на переменную

константное выражение           константное выражение
целого типа


константное выражение           константное выражение
указательного типа


статическая ссылка              ссылка на переменную
на переменную


   Если задано константное выражение целого типа, то компиля-
тор считает переменную размещенной по адресу, численно равно-
му значению этого выражения.  Диапазон  возможных  адресов  в
ПЭВМ Корвет - от 0 до FFFF-1. Для получения  числа  из  этого
диапазона значение константного выражения берется  по  модулю
2*16 (к отрицательным значениям прибавляется кратное 2*16).
   Если задано константное выражение указательного  типа,  то
компилятор считает переменную размещенной по адресу,  равному
значению этого выражения.
   Если задана статическая ссылка на переменную, то  компиля-
тор считает новую переменную размещенной по тому  же  адресу,
что и переменная, указанная в ссылке. "Статическая" означает,
что ссылка на переменную может быть вычислена на этапе компи-
ляции (т.е. для ее вычисления  не  требуется  знания  текущих
значений каких-либо переменных).
   Понятие "ссылка на переменную" описано в следующем  разде-
ле.
   В качестве ссылки на переменную может быть указан формаль-
ный параметр процедуры или функции. На этом случае остановим-
ся подробнее.
   Формальный параметр, передаваемый по значению, по сути яв-
ляется обычной локальной переменной,  которой  перед  вызовом
процедуры (функции) присваивается значение фактического пара-
метра. Absolute-конструкция, содержащая ссылку на  формальный
параметр, передаваемый по значению, создаст переменную,  раз-
мещенную в том же месте, что и переменная для формального па-
раметра.
   Иначе будет обстоять дело, если  указан  формальный  пара-
метр, передаваемый по ссылке. В этом случае переменная, опре-
деляемая с помощью absolute-конструкции, будет считаться раз-
мещенной в том же месте, что и фактический параметр - и, зна-
чит, при различных вызовах процедуры в различных местах памя-
ти! Это - один из инструментов для  ретипирования  формальных
параметров, передаваемых по ссылке. Заметим, что доступ к та-
кой переменной будет требовать  несколько  большего  времени,
чем к обычной.
   Absolute-конструкция является расширением по сравнению  со
стандартом  Паскаля.  Возможность  использования  в   absolu-
te-конструкции константных выражений (вместо констант) и про-
извольных статических ссылок на переменную (вместо  идентифи-
каторов переменных) является расширением по сравнению с  язы-
ком Turbo Pascal v.4.0.
   В Описании переменных, использующем  absolute-конструкцию,
может быть описана только одна переменная (список идентифика-
торов должен состоять только из одного идентификатора).
Примеры:

const     IOreg_base * $FE00;
var      comand_str     :string [127] absolute $80;
         cs_length      :byte absolute @ command_str;
         first_cschar   :char absolute addr(command_str)+1;
         timer_reg      :byte absolute IOreg_base+$03;
         w              :word;
         l              :byte absolute w;
         h              :byte absolute succ (addr(w));
         vect           :array [1..10] of real;
         fourth_comp    :real absolute vect[4];

   Использование absolute-конструкции позволяет:

-  получить доступ к переменным ОС (переменная command_str)
   или к портам ввода/вывода (переменная timer_reg).
-  обеспечить прямой доступ к полям переменных составных
   типов (переменные first_cschar, fourth_comp).
-  выполнить ретипирование переменных (т.е. обращаться к
   существующим переменным как к переменным других типов).
   Например, первый байт строковой переменной содержит ее
   текущую длину. Использование переменной cs_length позво-
   ляет непосредственно читать и менять текущую длину
   переменной command_str. Аналогично, использование пере-
   менных l и h позволяет непосредственно обращаться к
   мл. и ст. байтам переменной w.

   Заметим, что ретипирование может быть выполнено  и  другим
способом - с помощью  преобразователя  типа  переменной  (это
описано далее). Однако, при частом применении ретипирования ,
использование absolute-конструкции  окажется  более  удобным,
Кроме того, подобный результат может быть получен  путем  ис-
пользования записей с переменной частью.


   4.2. Ссылка на переменную.

   Ссылка на переменную означает одно из следующих:

-  переменную
-  компоненту переменной составного или строкового типа
-  динамическую переменную, на которую указывает перемен-
   ная указательного типа

   Ссылка на переменную имеет следующий синтаксис:


ссылка на       идентификатор
переменную      переменной              квалификатор
                преобразователь
                типа переменной
                вызов           /\
                функции


   Обратите внимание на то, что в ссылку на переменную  может
входить вызов функции (тип результата которой является указа-
тельным типом). После него обязательно должен идти  разымено-
ватель - чтобы получить доступ к  переменной,  адрес  которой
возвращен функцией.
   Квалификаторы указывают компоненту  переменной  составного
типа, к которой вы желаете получить доступ.


   4.3. Квалификаторы.

   Как правило, ссылка на переменную есть идентификатор пере-
менной, за которым идет несколько квалификаторов (возможно ни
одного).

квалификатор            индекс
                        селектор поля
                        /\

   Рассмотрим пример. Пусть переменная Result описана как

var Result: measurelist;

(тип measurelist описан  в  конце  предыдущей  главы).  Тогда
ссылка на переменную :

Result

обозначает весь массив целиком. Добавив индекс,  мы  получаем
ссылку на элемент массива:

Result[current+1]

-в нашем случае это переменная типа measuredata, которая  яв-
ляется типом записи. Добавив к этому селектор поля, мы  полу-
чим ссылку на поле записи:

Result[current+1].data

Это переменная указательного типа, testlistPtr. К  ней  можно
применить разыменователь, т.е. приписать /\:

Result[current+1].data/\

Полученное есть ссылка на переменную, адрес которой находился
в поле Result[current+1].data . Эта переменная имеет тип мас-
сива, и потому к ней может быть добавлен индекс:

Result[current+1].data/\[j]

Мы получили ссылку на переменную типа testvalue, который  яв-
ляется простым типом. Далее ни  один  квалификатор  не  может
быть добавлен.
   Количество возможных квалификаторов и их виды определяются
типом переменной.


   4.3.1. Массивы, строки и индексы.

   Ссылка на компоненту переменной -массива состоит из ссылки
на массив, за которой следует индекс, определяющий  необходи-
мую компоненту массива.
   Аналогично, ссылка на литеру из строки состоит  из  ссылки
на строку, за которой следует индекс, определяющий номер  не-
обходимой литеры.

индекс   [      выражение       ]
                   ,

   Каждое индексное выражение выбирает компоненту  массива  в
соответствующем измерении. Количество индексных выражений  не
может превосходить числа  индексов,  указанных  при  описании
типа массива. Тип каждого индексного  выражения  должен  быть
совместимым относительно присваивания с соответствующим типом
индекса, указаннум в описании типа массива.
   В Паскале многомерные массивы суть то же самое, что и мас-
сивы массивов. Например, вы можете описать переменные:

var matr1:array [1..10,1..10] of real;
    matr2:array [1..10] of array [1..10] of real;

и потом к каждой из них обращаться и как к 2-мерному  массиву
вещественных чисел,и как к массиву массивов вещественных  чи-
сел; иными словами, любая из следующих ссылок  на  переменную
допустима:

matr1 [3,7]             matr2 [3,7]
matr1 [3] [7]           matr2 [3] [7]

   Kak уже упоминалось, тип string[n] во многом похож на  тип
array[0..n] оf char. В  частности,  вы  можете  индексировать
строковую переменную одним индексным выражением целого  типа;
его значение должно лежать в интервале от 0 до n.  Компонента
строковой переменной с инд. 1 есть первая  литера  строки;  с
индексом 2 - 2-я и т.д.
   Компонента с индексом 0  есть  литера,  ASCII-код  которой
совпадает  с  текущим  количеством  литер  в   строке.   Т.о.
ord(s[0]) дает то же самое значение, что и length(s). Присва-
ивание компанента с индексом 0 меняет текущую  длину  строки.
При таком присваивании компилятор  не  проверяет,  что  новое
значение длины строки не превосходит объявленной  в  описании
максимальной длины; контроль за этим на совести программы.
   Вы можете обращаться к литерам строки, лежащим за предела-
ми текущей длины (но в пределах максимальной длины).  Резуль-
тат чтения таких литер не определен: присваивание им не меня-
ет текущего значения строковой переменной.
   Обращение к элементам массива с индексами, значения  кото-
рых выходят за пределы допустимого типом индекса диапазона (в
частности, обращение к литерам строки за пределами максималь-
ной длины) приведет к возникновению ошибки  времени  исполне-
ния, если программа  содержит  директиву  компилятора  {$R+},
или, если такой директивы нет, к непредсказуемым  результатам
работы программы.


   4.3.2. Записи и селекторы полей.

   Ссылка на поле записи состоит из ссылки  на  переменную  -
запись, за которой следует селектор требуемого  поля  (состо-
ящий из точки и следующего за ней идентификатора поля).


селектор поля           .       идентификатор поля


Примеры:

var today:date; result:measuredata;
.........
...      today.year...
..       result.count...
         result.when.day ...
   ...

   Внутри оператора with для ссылки на поле записи (указанной
в операторе with) можно  указать  только  идентификатор  поля
(без предшествующих ссылки  на  переменную-запись  и  точки).
Подробнее об этом см. описание оператора with в главе 7.


   4.3.3. Указатели и динамические переменные.

   Значение переменной указательного типа есть либо nil, либо
адрес динамической переменной.
   Ссылка на динамическую переменную, адрес которой находится
в некоторой указательной переменной, получается приписыванием
справа к ссылке на эту указательную переменную  символа-разы-
менователя /\.
   Вы можете создавать динамические переменные  и  прсваивать
их адреса указательным переменным с помощью стандартных  про-
цедур New и GetMem. Вы можете использовать оператор @ и стан-
дартную функцию Ptr для создания значений указательного типа,
которые будут трактоваться как адреса  динамических  перемен-
ных.
   Nil не является адресом никакой переменной. Если вы  попы-
таетсь обратиться к динамической переменной с помощью  указа-
тельной переменной, значение которой есть nil или не  опреде-
лено, то результат будет непредсказуемым.
   Примеры:

var      f:text;
         s:string;

begin
assign (f,paramstr(1)); reset(f);
whil not eof(f)
do begin readln (f,s);  writeln (s); end;
end


   4.4. Преобразователь типа переменной

   Ссылка на переменную одного типа может быть  преобразована
в ссылку на переменную другого типа с помощью преобразователя
типа переменной.


преобразователь         идентификатор   (   ссылка на     )
типа переменной         типа                переменную


   Ссылка на переменную используется компилятором для опреде-
ления адреса памяти, по которому расположена переменая.  Пре-
образователь типа переменной заставляет  компилятор  считать,
что по адресу, определяемому ссылкой на переменную, находится
переменная типа "идентификатор типа".
   При использовании преобразователя типа переменной никакого
преобразования значения переменной не выполняется;  также  не
требуется никакого соответствия между новым и старым типами.
   За преобразователем типа переменной могут следовать квали-
фикаторы - в соответствии с типом "идентификатор типа".
   Преобразователь типа переменной следует отличать от преоб-
разователя типа выражения (см. главу 6), при применении кото-
рого выполняется преобразование значений и требуется  совмес-
тимость типов.
    Примеры:

type     point=record x,y:word end;
         list=array [1..2] of word;

var      p:point;
         l:longint;
         n:word;
         s:string[22];

begin
p:=point(l);
n:=point(l).x;
longint(p):=longint(p)+$12345678;
list(p)[n]:=32;
point(n).x:=byte(s);

end.

   Языки с жестким контролем за типами (к  каковым  относится
Паскаль) обеспечивают высокую надежность программирования, но
взамен сильно ограничивают возможности программиста - особен-
но при написании программ системного  характера.  Возможность
явного изменения типа переменной придает языку  EP  гибкость,
необходимую для системных приложений.

   ГЛАВА 5
   ТИПИЗИРОВАННЫЕ КОНСТАНТЫ


   Типизированные константы по сути являются переменными сна-
чальными значениями. В описании типизированной константы  за-
даются ее тип и начальное значение.
   Описание типизированной константы:


   идентификатор    :   тип    =    типизированная     :
                                    константа


типизированная          константное выражение
константа               константа-массив
                        константа-запись
                        константа-множество
                        nil

   Типизированная константа может  использоваться  точно  так
же, как и переменная; в частности, она может появляться в ле-
вой части оператора  присваивания.  Типизированные  константы
инициализируются только один раз - в начале исполнения  прог-
раммы; при повторном входе в процедуру или функцию  локальные
типизированные константы не переинициализируются.  Однако,  в
отличие от других локальных переменных значения локальных ти-
пизированных констант не изменяются от одного входа в  проце-
дуру (функцию) до другого. Поэтому, если  значения  типизиро-
ванных констант не изменяются явно  программой,  их  значения
сохраняются в течении всего периода работы.


   5.1. Типизированные константы простых типов.

   Описание типизированной  константы  простого  типа  задает
значение значение константы:

const    maxnr:integer=1000-1;
         factor:real=-0.1;
         str_Z:char=#$1A;

   Т.к. типизированная константа на самом деле есть  перемен-
ная с начальным значением, она не может быть  использована  в
константном выражении. Например, следующий фрагмент  недопус-
тим:

const min:word=1;
      max:word=87;
type vect=array [min...max] of real;


   5.2. Типизированные константы строкового типа.

   Описание типизированной константы строкового  типа  задает
ее максимальную длину и начальное значение:

const head      :string [20]='заголовок';
   crlf         :string[2]=#13 #10;
   trueans      :string[5]= 'YES';
   faleans      :string[5]= 'NO';


   5.3. Типизированные константы составных типов

   Описание типизированной константы составного  типа  задает
значение каждой компоненты. В EP поддерживаются  типизирован-
ные константы типов массива, записи и множества; кроме  того,
поддерживаются константы указательных типов.  Не  допускаются
типизированные константы файловых типов  и  составных  типов,
содержащих файловые компоненты.


   5.3.1. Типизированные константы типа массива

   Описание типизированной константы типа массива задает зна-
чение всех его компонент. Эти  значения  отделяются  друг  от
друга запятой и заключаются в скобки.


константа-      (   типизированная      )
массив              константа
                        ,


   Пример:

type     status=(active,passive,waiting);

const    statstr:array [status] of string [7]
                =('ACTIVE','PASSIVE','WAITING');

В этом примере определяется типизированная константа statstr,
которая может быть использована для  преобразования  значений
типа status в соответствующие строковые представления. Значе-
ния компонент statstr:

statstr [active]='ACTIVE'
statstr[passive]='PASSIVE'
statstr[waiting]='WAITING'

   Константа типа "упакованный массив литер" может быть зада-
на и как последовательность литер, и как строка. Описание:

const digits:array  [0..9]  of  char  =  ('0','1','2','3',  и
т.д.);

полностью эквивалентно описанию:

const digits:array  [0..9]  of  char  ='0123456789';

   Многомерные массивы  задаются  вложенными  типизированными
константами. Самые внутренние константы соответствуют  самому
правому измерению. Например.описание:

type cube=array [0..1, 0..1, 0..1] of integer;
const maze : cube=(((0,1),(2,3)),((4,5),(6,7)));

задает значения компонент массива maze следующим образом:

maze [0,0,0]=0    maze [1,0,0]=4
maze [0,0,1]=1    maze [1,0,1]=5
maze [0,1,0]=2    maze [1,1,0]=6
maze [0,1,1]=3    maze [1,1,1]=7


   5.3.2. Типизированные константы типа записи.

   Описание типизированной константы типа записи задает  зна-
чения некоторых ее полей (не обязательно всех!). Для  каждого
задаваемого поля указывается его идентификатор и  через  дво-
еточие - значение; эти элементы отделяются друг от друга точ-
ками с запятой и заключаются в скобки.


константа-      (   идентификатор    :   типизированная   )
запись                  поля               константа
                                     ;


   Задаваемые в типизированной константе поля должны  идти  в
том же порядке, что и в описании типа записи. Поля  файлового
типа не могут быть заданы. Если  запись  содержит  переменную
часть, в ней могут быть заданы поля только одного варианта.
   Примеры :

type point  =record x,y,:real end;
     vector =array [0..1] of point;
     fcb    =record
                open:boolean;
                size:longint;
                f   :file;
                name:string [16];
         end;

const    origin:point   =(x:0.0; y:0.0);
         line  :vector  =((x:-1.2; y:2.1), (x:4.0; y:2.9));
         inp_f :fcb     =(open:false; name:'name.ext');


   5.3.3. Типизированные константы типа множества.

   Описание типизированной константы типа множества представ-
ляет собой последовательность из нуля или  более  константных
групп элементов; они отделяются друг от друга запятыми и зак-
лючаются в квадратные скобки. Каждая константная группа  эле-
ментов есть либо константное выражение  -  оно  задает  соот-
ветствующий элемент множества, - либо два константных выраже-
ния, разделенных двумя точками  -  такая  конструкция  задает
несколько элементов, составляющих заданный интервал.  Если  в
последнем случае правое константное выражение меньше  левого,
то такая константная группа элементов  не  задает  ни  одного
элемента множества. Если не задано ни одной константной груп-
пы элементов, то такая типизированная константа задает пустое
множество.


константа-      [                          ]
множество            константная
                     группа элементов
                              ,


константная             константное
группа элементов        выражение
                                        ..     константное
                                               выражение


Примеры:

type     numbers  =set of 1..20;
const    prime  : numbers=[2,3,5,7,11,13,17,19];
         non_prime: numbers= [1,4,6,8,10,12,14,16,18,20];
         first=5; size=3;
         mask   :numbers=[first..first+size-1];
         emty_set:numbers [];
         hex_digits: set of 'o'..'z' =['0'..'9','a'..'f'];


   5.4. Типизированные константы указательного типа

   Типизированная константа указательного  типа  может  иметь
единственное значение - nil.




   ГЛАВА 6
   ВЫРАЖЕНИЯ


   Выражения строятся из операндов с помощью знаков операций.
Операции бывают унарные (имеющие  один  операнд)  и  бинарные
(два операнда). Знак  унарной  операции  располагается  перед
операндом; бинарной - между операндами.
   Порядок выполнения операций определяется их  приоритетами.
Операции и их приоритеты приведены в таблице:

.............................................................
знак операции           приоритет       категория
.............................................................
@,not                   1 (высший)      унарные операции-1
*,/,div,mod,and,shr,shl 2               операции типа умнож-я
+,- (унарные)           3               унарные операции-2
+,- (бинарные),or,xor   4               операции типа слож-я
=,<>,<,>,<=,>=,ln       5 (низший)      операции сравнения
.............................................................

   Вычисление выражения выполняется  на  оснавании  следующих
трех правил:

** операнд между двумя знаками операций различного приоритета
связывается знаком операции более высокого приоритета
** операнд между двумя  знаками  операций  одного  приоритета
связывается левым знаком операции
** выражения в  скобках  вычисляются  первоначально  и  далее
рассматриваются как операнды
   Обратите внимание на необычное деление унарных операций на
две категории с различными приоритетами. Это следствие специ-
фического способа определения синтаксиса выражения.
   Компилятор EP организует вычисление выражений справа нале-
во, т.е. для всякой  бинарной  операции  сначала  вычисляется
правый операнд, а потом левый. Это позволяет генерировать бо-
лее компактный код. Как правило, на  это  можно  не  обращать
внимания: однако , по крайней мере в  одном  случае,  порядок
выполнения  операций  является  существенным:   использование
функций с побочным эффектом. Пусть, например, функция f ,  не
имеющая параметров, при последовательных вызовах выдает  пос-
дедовательность натуральных чисел: 1,2,3, и т.  д.  ,  и  при
последнем вызове она выдала 5. Тогда, если выражения вычисля-
ются слева напрво, в результате выполнения оператора:

y:=f+f*f

переменная y получит значение 62 (=6+7*8), а  если  выражения
вычисляются справа налево - то значение 50 (=8+7*6). Компиля-
тор EP изготовит вам программу, которая вычислит значение  50
- однако другой компилятор может поступить по другому.  Чтобы
ваша программа не зависела от компилятора, поступите  в  рас-
сматриваемом случае следующим образом.  Замените  приведенный
оператор на последовательность:

x1:=f;
x2:=f;
x3:=f;
y:=x1+x2*x3;

результат выполнения такой последовательности  операторов  не
зависит от порядка вычисления выражения; в  нашем  примере  y
получит значение 62.
   Рекомендуем вам, по возможности, избегать в ваших програм-
мах использования функций с побочным эффектом; они затрудняют
понимание программы и  ,  следовательно,  снижают  надежность
программирования.
   То, что выражения вычисляются справа налево, не  означает,
что компилятор может изменить определенный синтаксисом  поря-
док выполнения операций. Так, по синтаксису Паскаля в выраже-
нии:

x*y*z

скобки считаются расставленными в порядке:

(x*y)*z

- и в вашей программе именно так и будет вычислено такое  вы-
ражение. Заметим, что это существенн, т.к. операции над  чис-
лами с плавающей точкой в компьютере не являются  ассоциатив-
ными - в отличие от математических операций над вещественными
числами. Например, если значения переменных x,y,z (типа real)
равны соответственно 10*30, 10*30 и 10*-30, то  результат вы-
числения выражения:

x*(y*z)

будет равен 10*30, а при вычислении выражения:

(x*y)*z

возникнет ошибка переполнения, т.к. формат представления  чи-
сел с плавающей точкой в EP не  позволяет  представить  число
10*60.


   6.1. Синтаксис выражений.

   Выражения строятся в соответствии с приводимым  ниже  син-
таксисом. Для определения понятия выражения вводятся  вспомо-
гательные понятия множителя , терма и прстого выражения.
   Множители являются простейшими составляющими выражения.

множитель           ссылка на переменную
               @    ссылка на переменную
                    идентификатор процедуры
                    идентификатор функции
                    беззнаковая константа
               (    выражение                  )
             not    множитель
                    вызов функции
                    конструктор множества
                    преобпазователь типа выражения

   Обратите внимание на то, что множителем может быть  только
беззнаковая константа - а не произвольная константа. Это одно
из средств борьбы с выражениями вроде 2*-3 .

беззнаковая         число без знака
константа           строка символов
                    идентификатор константы
                    nil

Примеры множителей:

matrix [2,3]                 ссылка на переменную
@ matrix                     указатель на переменную
15                           беззнаковая константа
(x+y+z)                      подвыражение
not Error                    отрицание
sin (x/2)                    вызов функции
['0'..'9', 'a'..'z']         конструктор множества
longint (l)                  преобразователь типа переменной

   Термы представляют  собой  последовательность  множителей,
связанных операциями типа умножения.


терм                множитель
                    *
                    /
                    div
                    mod
                    and
                    shi
                    shr

   Примеры термов:

x*z
z/(1-z)
(x>1) and error

   Простое выражение есть последовательность термов,  связан-
ных знаками операций типа сложения, которой,  возможно  пред-
шествует знак.

простое                      терм
выражение           знак     +
                             -
                             or
                             xor

   Обратите внимание на то, что унарные + и - представлены  в
синтаксисе знаком , который стоит в начале  простого  выраже-
ния. Этим обеспечивается тот факт, что приоритет унарных +  и
- меньше приоритета бинарных операций типа умножения. Послед-
нее имеет, по крайней мере, одно важное следствие:  значением
выражения -$05 and $0F будет $FB - а не $0B, как  было  бы  в
случае, если бы унарный - имел приоритет выше,  чем  бинарная
операция типа умножения and.
   Примеры простых выражений:

x+y
-x
+matrix [1]*5


   Выражение является либо  простым  выражением,  либо  двумя
простыми выражениями, связанными операцией сравнения.

выражение           простое
                    выражение                  простое
                                      <        выражение
                                      <=
                                      >
                                      >=
                                      =
                                      <>
                                      ln

   Примеры выражений:

x=1.5
(i<j)=(j<k)
elem in set-of-elem

   Обратите внимание на то, что по синтаксису Паскаля  опера-
ции сравнения являются обычными операциями, и они имеют  низ-
ший приоритет. Поэтому в выражении:

b1=b2 or b3

цкобки считаются расставленными так:

b1=(b2 or b3)  , а не  (b1=b2) or b3

как моно было бы предпололожить, исходя из обычных  математи-
ческих соглашений. В случае, когда b1,b2,b3 - переменные  це-
лого типа, выражение без скобок, к  вашему  счастью,  вызовет
сообщение об ошибке (т.к. нельзя сравнивать целое значение  с
булевским). Но если все эти переменные имееют тип boolean, то
вы рискуете долго удивляться результатам работы  вашей  прог-
раммы, пока не сообразите в чем дело. Чтобы избежать неприят-
ностей такого рода, рекомендуем всегда в выражениях, содержа-
щих операции сравнения  и  логические  операции,  расставлять
полный комплект скобок.
   То обстоятельство,  что  знак  сравнения  может  связывать
только простые выражения, несколько облегчает вам жизнь,  де-
лая выражение вроде:

b1=b2 or b3=b4

синтаксически недопустимым, независимо от типов операндов.


   6.2. Операции.

   Операции делятся на следующие 6 классов:
- арифметические
- логические
- строковые
- операции над множествами
- операции сравнения
- @-операция


   6.2.1. Арифметические операции.

   К арифметическим операциям относятся: унарные + и  -;  би-
нарные + ,-, *, /, div, mod.
   Операции +, -, *, / применимы к операндам целых  типов  (в
частности, к отрезкам целых типов) и вещественных типов; опе-
рации div и mod применимы только к операндам целых  типов  (в
частности, к отрезкам целых типов).
   Результат операций div и mod всегда имеет целый  тип;  ре-
зультат операции / всегда имеет вещественный  тип;  результат
остальных операций имеет вещественный тип, если хотя бы  один
из операндов имеет вещественный тип, и целый  тип,  если  оба
операнда имеют целый тип.
   Если в результате выполнения  операции,  дающей  результат
вещественного типа, получается значение, превосходящее по аб-
солютной величине максимальное представимое вещественное чис-
ло (около 1.7*10'38), то возникает ошибка времени  исполнения
"арифметическое переполнение". Если же результат по  абсолют-
ной величине меньше  минимального  отличного  от  нуля  числа
(около 2.9*10'-39), то результат считается равным  0;  ошибки
не возникает.
   Если правый операнд опрации / (делитель) равен 0, то  воз-
никает ошибка времени исполнения "деление на 0".
   Результат операции i div j  (целочисленное  деление)  есть
частное от деления i на j, округленное в сторону 0 до ближай-
шего целого числа. Если j равно 0, то возникает ошибка време-
ни исполнения "деление на 0".
   Результат операции i mod j (остаток от деления) есть оста-
ток при целочисленном делении i на j; он удовлетворяет  соот-
ношению :

i mod j = i -(i div j)*j

Знак результата операции mod всегда совпадает  со  знаком  i.
Если j равно 0, то возникает ошибка времени исполнения "деле-
ние на 0".
   Представление (1-, 2-, 4-байтовое), с которым  выполняются
целочисленные операции, определяются по приводимым ниже  (до-
вольно сложным) правилам. Эти правила выбраны так,  чтобы,  с
одной стороны, не получить искажения результата,а, с  другой,
не выполнять без необходимости вычисления  с  длинными  пред-
ставлениями. За редким исключениям эти правила приводят к же-
лаемому результату; во всяком случае, если значения всех про-
межуточных результатов при вычислении вашего выражения  укла-
дываются во множество допустимых значений типа операндов,  то
вы можете быть уверены, что результат получится верным, и  не
тратить времени на изучение правил. В тех случаях, когда  вы-
бор представления по приведенным правилам является неудовлет-
ворительным, вы можете явно изменить его , использовав преоб-
разователь типа выражения (описан далее).
   Приводимые здесь правила относятся также к  выражениям,  в
состав которых входят рассматриваемые в следующем разделе ло-
гические операции с целочисленными операндами.
   Для описания правил определения представления для выполне-
ния арифметических действий нам потребуется несколько вспомо-
гательных определений.
   Напомним, что в EP имеется 5 целых типов, для которых  ис-
пользуются следующие представления (отрезки целых  типов  при
вычислении выражений трактуются как базовые типы):

- shortint - 1-байтовое знаковое
- byte     - 1-байтовое беззнаковое
- integer  - 2-байтовое знаковое
- word     - 2-байтовое беззнаковое
- longint  - 4-байтовое знаковое

   Отрицательные числа представляются в  обратном  коде  (это
означает , что операция изменения знака состоит в  инвертиро-
вании всех битов с последующим  прибавлением  1).  При  таком
представлении старший бит является знаковым: он  содержит  0,
если число положительное, и 1, если число отрицательное.
   Сначала определим операцию приведения значения одного типа
к другому. Она имеет 25 вариантов (по числу пар типов):

** приведение типа к нему самому (shortint к shortint, byte к
byte и т. д. ): не выполняется никаких действий.

** приведение типа к типу той же длины (shortint к byte, byte
к shortint, integer к word, word к integer):  не  выполняется
никаких действий

** приведение типа к более короткому типу  (integer  к  shor-
tint, integer k byte, word k shortint, word к byte, longint k
shortint, longint k byte, longint k integer, longint k word):
откидываются старшие байты значения

** приведение беззнакового типа к более длинному (byte k  in-
teger , byte k word, byte k longint, word k longint):  добав-
ляется необходимое количество 0-х старших байтов

** приведение знакового типа к более длинному (shortint k in-
teger, shortint k word, shortint k longint,  integer  k  lon-
gint): добавляется необходимое количество старших  байтов,  в
них распространяется знаковый разряд  (т.е.  добавляются  0-е
байты , если число было положительным, и байты из всех 1, ес-
ли число было отрицательным)

   Заметим, что операция приведения может исказить  значение;
сохранение значения можно гарантировать лишь  при  приведении
типа к нему самому и к более длинному.
   Общим типом двух целых типов Т1 и Т2 называется целый тип,
длина которого есть максимум из длин Т1 и Т2, и который явля-
ется знаковым, если хотя бы один из типов Т1  и  Т2  является
знаковым.
   Естественным типом результата бинарной арифметической опе-
рации называется общий тип естественных типов  ее  операндов,
за исключением: если операция есть *, div или  mod,  а  общий
тип естественных типов операндов есть shortint или  byte,  то
естественным типом результата операции является  integer  или
word соответственно. Естественным типом ссылки на переменную,
константы, преобразователя типа выражения или вызова  функции
является их тип.
   Для всякого целого арифметического выражения, входящего  в
программу (в частности, для подвыражений), определим  внешний
тип.

** если выражение сотавляет правую часть оператора присваива-
ния, то внешний тип есть тип ссылки на  переменную  из  левой
части

** если выражение является индексом, то внешний тип есть word

** если выражение есть элемент (или граница  отрезка  элемен-
тов) конструктора множества, то внешний тип есть byte

** если выражение является левым операндом оператора  in,  то
внешний тип есть byte

** если выражение является правым операгдом оператора shl или
shr, то внешний тип есть byte

** если два выражения являются операндами операции сравнения,
то внешний тип для каждого из них есть общий  тип  их  естес-
твенных типов

** если выражение является фактическим  параметром  процедуры
или функции, то внешний тип есть  тип  соответствующего  фор-
мального параметра

** если выражение является  аргументом  преобразователя  типа
арифметического выражения, то внешний тип есть тип,  указыва-
емый этим преобразователем

** во всех остальных случаях тип не определен

   Обратите внимание на то, что, хотя внешний  тип  арифмети-
ческого выражения определен не всегда, он определен для  всех
тех арифметических выражений, которые не являются  операндами
арифметических операций.
   Представление, с которым будут выполняться  арифметические
операции, планируется снаружи вглубь.
   Пусть имеется выражение вида:

подвыражение1 операция подвыражение2

и пусть Т1 есть его естественный тип  и  Т2  -  внешний  тип.
Обозначим через Т общий тип для типов Т1 и Т2. Тогда  сначала
вычисляются подвыражение2 и подвыражение1 с внешним  типом  Т
(если внешний тип для них не определен; иначе они вычисляются
с внешним типом, определяемым приведенными  выше  правилами).
Далее выполняется операция (над представлениями типа Т) и за-
тем результат ее приводится к типу Т2. Аналогично обрабатыва-
ется случай унарной операции.
   Проверка принадлежности результатов вычисления отрезкам  в
процессе вычисления выражения не производится;  она  произво-
дится только в момент выполнения  присваивания  при  передаче
параметров процедуре или функции по значению и при индексиро-
вании массивов  -  если  соответствующий  фрагмент  программы
скомпилирован в режиме "включена проверка принадлежности  от-
резку" (включается директивой {$R+}). Проверка искажения  ре-
зультата при выполнении приведений никогда не производится.


   6.2.2. Логические операции.

   К логическим операциям (над операндами целых типов)  отно-
сятся: унарная операция not и бинарные операции and, or, xor,
shl, shr.
   Операция not состоит в инвертировании всех битов операнда;
тип ее результата совпадает с типом операнда.
   Операции and, or и xor состоят в побитовом выполнении опе-
раций И, ИЛИ и ИСКЛЮЧАЮЩЕЕ ИЛИ соответственно; перед  их  вы-
полнением операнды приводятся к общему типу;  тип  результата
операции есть общий тип операндов.
   Операции shl и shr выполняют сдвиг левого  операнда  соот-
ветственно влево или вправо на число битов, задаваемое правым
операндом. Тип результата совпадает с типом левого  операнда.
Правый операнд всегда приводится к типу byte; это  ,  в  час-
тности, означает, что сдвиг на 1024 не  изменит  числа  (т.к.
мл. байт числа 1024 есть 0), а сдвиг на -1 есть сдвиг на  255
битов (что в результате всегда даст 0).


   6.2.3. Булевские операции.

   К булевским операциям (над операндами типа boolean)  отно-
сятся унарная операция not и бинарные операции and, or , xor.
   Все эти операции выполняются по обычным  правилам  и  дают
результат типа boolean.


   6.2.4. Операции над строками .

   Имеется всего одна операция над строками  -  конкатенация;
она обозначается знаком + .
   Операнды операции конкатенации могут иметь тип string [n],
char или упакованный массив литер. Результат операции совмес-
тим с любым строковым типом (но не с типом char и не с упако-
ванным массивом литер).
   Операция конкатенации состоит в приписывании  к  строке  -
левому операнду справа строки- правого операнда. Если резуль-
тирующая строка имеет длину более 255 литер, то она обрезает-
ся до 255 литер.


   6.2.5. Операции над множествами.

   Имеется три операции над множествами:  +  (объединение,  -
(разность), * (пересечение).
   Операнды каждой из этих операций должны быть  совместимыми
типами множеств. Результат этих операций  совместим  с  любым
типом множества, с которым совместимы операнды.
   Эти операции являются обычными математическими  операциями
над множествами, подчиняющимися следующим определениям:

** x принадлежит a+b тогда и только тогда, когда x  принадле-
жит a или x принадлежит b 

** x принадлежит a-b тогда и только тогда, когда x  принадле-
жит a и не x принадлежит b

** x принадлежит a*b тогда и только тогда, когда x  принадле-
жит a и x принадлежит b


   6.2.6. Операции сравнения.

   Имеется семь операций сравнения:

=   равно
<>  не равно
>   больше
<   меньше
>=  больше или равно
<=  меньше или равно
in  является элементом множества

   Операции сравнения применимы к  выражениям  многих  типов;
далее мы опишем их действие для каждого типа  в  отдельности.
Во всех случаях требуется, чтобы типы операндов были  совмес-
тимыми. Результат операции сравнения всегда имеет тип  boole-
an.


   6.2.6.1. Сравнение простых типов.

   Для сравнения значений простых типов применимы операции:
=, <>, >, <, >=, <=.
   Если сравниваются значения упорядоченных типов, то сравни-
ваются их порядковые номера. Сравнения чисел  выполняются  по
обычным правилам.
   Имеется одно исключение из  общего  правила  совместимости
типов операндов операции сравнения: если тип одного  из  опе-
рандов есть real , то второй операнд может быть целого  типа;
в этом случае операнд целого типа предварительно преобразует-
ся в вещественное число, и затем  выполняется  сравнение  ве-
щественных чисел.


   6.2.6.2. Сравнение строк.

   Для сравнения строк применимы операции =, <>, >, <, >=, <=
   Сравниваться могут строки, упакованные массивы литер и ли-
теры в произвольных сочетаниях (с тем лишь замечанием  ,  что
сравнение двух литер производится по правилам сравнения прос-
тых типов, а не по правилам настоящего раздела). Во всех слу-
чаях сначала выполняется преобразование значения в  строковый
тип, а затем выполняется сравнение строк. Порядок между стро-
ками - лексикографический (см. главу 3).


   6.2.6.3. Сравнение указателей.

   Для сравнения указателей применимы только операции = и <>.
Указатели считаются равными, если они указывают на одно и  то
же место памяти.


   6.2.6.4. Сравнение множеств.

   Для сравнения множеств применимы операции =, <>, >=, <= .
   Если a и b есть множества, то их сравнение дает следующий-
результат:

** a=b есть True, если x принадлежит a тогда  и  только  тог-
да,когда x принадлежит b; иначе a<>b есть True

** a <= b есть True , если всякий элемент a является  элемен-
том b 

** a >= b есть True, если всякий элемент b является элементом
a


   6.2.6.5. Проверка принадлежности элемента множеству.

   Проверка принадлежности элемента множеству  выполняется  с
помощью операции in.
   Левый операнд операции in должен быть упорядоченного типа,
а правый операнд должен быть типа множества, базовый тип  ко-
торого совместим с типом левого операнда.
   Операция in дает True, если левый операнд является элемен-
том множества правого операнда, и False в противном случае.


   6.2.7. Операция @.

   Унарная операция @ применима к ссылке на  переменную  и  к
идентификатору процедуры или функции.  Результат  операции  @
имеет тип Pointer (который совместим с  любым  другим  указа-
тельным типом).
   Применение операции @ к ссылке на  переменную  дает  адрес
этой переменной.
   Применение операции к идентификатору  процедуры  (функции)
дает адрес точки входа в эту процедуру (функцию). EP не имеет
механизмов работы с такими указателями; единственное, где  вы
можете их использовать - это в inline-предложениях.
   Особое внимание следует обратить на применение операции  @
к формальным параметрам процедур и функций.
   Формальный параметр, передаваемый  по  значению,  по  сути
есть обычная локальная переменная, которой перед началом  вы-
полнения процедуры (функции) присваивается значение фактичес-
кого параметра. Применение операции @ к формальному  парамет-
ру, передаваемому по значению, даст адрес этой переменной.
   Применение операции @ к формальному  параметру,  передава-
емому по ссылке, даст адрес переменной -  фактического  пара-
метра.


   6.3. Вызов функции.

   Вызов функции приводит к вычислению значения функции,  ко-
торое далее используется для вычисления значегия выражения.
   Вызов функции состоит из идентификатора функции, за  кото-
рым, возможно, следует список фактических параметров (если  в
описании функции указан список формальных параметров). Каждый
фактический параметр из списка  должен  соответствовать  фор-
мальному параметру - по правилам  соответствия,  приведеннымв
главе 8.


вызов           идентификатор
функции         функции         список фактических
                                параметров


список фактических      (    фактический параметр       )
параметров                      ,


фактический             выражение
параметр                ссылка на переменную


   cos (x)
copy (s,5,succ(i))



   6.4. Конструктор множества.

   Конструктор множества служит для формирования значений ти-
па множества. Он состоит из заключенной в  квадратные  скобки
последовательности групп элементов. Каждая  группа  элементов
задает либо один элемент множества, либо несколько  элементов
множества с последовательными порядковыми номерами.


конструктор     [                               ]
множества               группа элементов
                                ,

группа          выражение
элементов                       ..      выражение


   [] обозначает пустое множество; такое выражение совместимо
с любым типом множества. Группа элементов вида x...y  обозна-
чает множество элементов из диапазона от x до y включительно.
Если x>y , то эта группа не  задает  ни  одного  элемента,  и
[x..y] обозначает пустое множество.
   Значения всех выражений, вхдящих во все  группы  элементов
одного конструктора множества, должны быть одного и  того  же
упорядоченного типа.
Примеры:

[1,5,10..k mod 12, 7..8]
[chr (first-in)...pred(chr(first-out)),'0'..'9']


   6.5. Преобразователь типа выражения.

   Тип выражения может быть явно преобразован в другой с  по-
мощью преобразователя типа выражения.


преобразователь         идентификатор   (   выражение   )
типа выражения          типа

   Идентификатор типа и тип выражения должны  быть  либо  оба
указательными типами, либо оба упорядоченными типами.
   Если оба есть указательные типы, то никаких преобразований
не выполняется, но значение выражения  рассматривается  далее
как имеющее тип "идентификатор типа".
   Если же оба есть упорядоченные типы, то выражение вычисля-
ется с внешним типом "идентификатор типа" и  затем  результат
приводится к типу "идентификатор типа" (см. раздел 6.2.1.)
   Синтаксически преобразователь типа выражения  очень  похож
на преобразователь типа переменной (см. главу 4). Распознают-
ся они по следующему признаку. Если то, что  идет  в  скобках
после идентификатора типа , есть  ссылка  на  переменную,  то
конструкция является преобразователем типа переменной;  иначе
конструкция является преобразователем типа выражения.
   Примеры:

integer ('А')           преобразователь выражения
real (n)                преобразователь переменной

   ГЛАВА 7

   ОПЕРАТОРЫ


   Операторы описывают  алгоротмические  действия  ,  которые
должны быть выполнены программой. Перед любым оператором  мо-
гут находиться метки; метки могут быть использованы в  опера-
торе перехода 


оператор
                метки   :       простой оператор
                                структурный оператор


   Метка может быть целым без  знака  и  идентификатора  (см.
главу 1). Любая метка,  используемая  в  разделе  операторов,
должна быть предварительно описана в разделе описаний  меток,
и любая метка, описанная в разделе описаний меток, должна по-
явиться ровно перед одним оператором в разделе операторов.
   Вхождение метки в префикс оператора  называется  определя-
ющим; вхождение метки в описание меток - описывающим; все ос-
тальные вхождения меток (в качестве аргумента оператора goto)
называются использующими. Впределах одного блока каждая метка
должна иметь ровно одно описывающее и ровно одно определяющее
вхождение. Количество использующих вхождений может быть  про-
извольным (даже ни одного).


   7.1. Простые операторы.

   Простой оператор есть оператор, который не содержит внутри
себя никакого другого оператора.

простой                 оператор присваивания
оператор                вызов процедуры
                        оператор перехода
                        оператор inline


   7.1.1. Оператор присваивания.

   Оператор присваивания применяется для формирования  нового
значения переменной или для формирования результата функции.


оператор                ссылка на       :=      выражение
присваивания            переменную
                        идентификатор
                        функции


   Выражение должно  иметь  тип  ,  совместимый  относительно
присваивания с типом переменной или с типом  результата  фун-
кции (см. главу 3).
   Идентификатор функции может быть  использован  в  качестве
левой части оператора  присваивания  только  внутри  описания
этой функции.


   7.1.2. Вызов процедуры.

   Оператор вызова процедуры состоит из идентификатора проце-
дуры, за которым, возможно, следует список фактических  пара-
метров (если в описании процедуры  указан  список  формальных
параметров). Каждый фактический параметр из списка должен со-
ответствовать  формальному  параметру  -  по  правилам  соот-
ветствия, которые прведены в главе 8.


вызов           идентификатор
процедуры       процедуры               список фактических
                                        параметров


   Выполнение оператора вызова процедуры состоит в выполнении
тела процедуры при значениях формальных параметров  ,  равных
значениям фактических. 


   7.1.3. Оператор перехода.

   Оператор перехода имеет следующий синтаксис:


оператор        goto    метка
перехода


   Выполнение оператора goto состоит в передаче управления на
оператор , помеченный меткой, указанной в операторе goto.
   Определяющее вхождение метки, указанной в операторе  goto,
должно находиться в том же блоке, что и оператор goto. Нельзя
передавать управление снаружи внутрь и изнутри наружу  проце-
дуры или функции.
   Нельзя также передавать управление снаружи внутрь операто-
ров for i with (но можно передавать управление изнутри их на-
ружу).
   Компилятор позволяет передавать управление снаружи  внутрь
других структурных операторов; но перед тем,  как  воспользо-
ваться этим, хоршо подумайте чего вы хотите.
   Вообще, мы рекомендуем избегать  использования  операторов
goto без необходимости - они затрудняют понимание программы и
снижают надежность программирования. Оправданным является ис-
пользование goto для перехода изнутри структурного  оператора
на его конец или для выхода из процедуры или функции (в  пос-
леднем случае следует передавать управление на метку, стоящую
непосредственно перед завершающим составной оператор процеду-
ры (функции) end); однако для таких целей мы рекомендуем  ис-
пользовать стандартные процедуры Break и Exit.  Во  всех  ос-
тальных случаях попытайтесь найти конструкцию, заменяющую go-
to.


   7.1.4. Оператор inline.

   Оператор inline позволяет вставлять в программу фрагменты,
написанные непосредственно в машинных кодах. Для того,  чтобы
правильно использовать оператор inline, вам  необходимо  вла-
деть языком ассемблера и внимательно изучить главу 13.


оператор        inline   (      inline-элемент     )
inline                                  /


   Каждый inline элемент задает байт или слово и имеет следу-
ющий синтаксис:


inline                  константное выражение
элемент         >       целого типа
                <
                        константное выражение
                        указательного типа
                        статическая ссылка
                        на переменную
                *   +       константное выражение
                            целого типа


   Первый вариант (константное выражение целого типа ,  кото-
рому, возможно, предшествует знак > или < ) позволяет  задать
байт или слово. Константное выражение целого типа всегда  вы-
числяется как longint. Если присутствует знак <, то значением
inline-элемента будет младший байт значения константного  вы-
ражения; если присутствует знак > - младшее слово.  Если  нет
ни < ни > , то будет взят младший байт,  если  значение  кон-
стантного выражения укладывается в байт (т.е. имеет тип  byte
или shortint), и будет взято младшее слово в  противном  слу-
чае.
   Во всех остальных случаях inline-элемент задает слово.
   Если указано константное выражение указательного  типа  то
значение inline-элемента есть определяемый указателем адрес.
   Если указана статическая ссылка на переменную, то значени-
ем inline-элемента будет адрес этой переменной.  Если  ссылка
на переменную есть формальный параметр, передаваемый по ссыл-
ке, то значением inline-элемента будет адрес слова,  содержа-
щего адрес переменной - фактического параметра (подробнее см.
главу 13). Если задана конструкция вида * + константное выра-
жение, то значением inline-элемента будет текущий адрес  (ад-
рес пораждаемогоinline-элементом слова), к которому прибавле-
но значение константного выражения. Если необходимо  получить
адрес меньше текущего, то следует взять константное выражение
с отрицательным выражением.
   Компилятор не позволяет задавать машинные  команды  с  по-
мощью мнемокодов. Однако, вы легко можете достичь необходимо-
го эффекта; достаточно описать набор констант вроде:

const    iNOP   =$00;
         iJMP   =$C3;
         iPUSH_H=#E5;
....

и затем использовать эти константы в операторе  inline.  Если
вам часто приходиться пользоваться оператором  inline,  реко-
мендуем вам создать отдельный файл, содержащий описания  кон-
стант-мнемокодов, и затем включать его в ваши программы с по-
мощью директивы компилятора {$1 имя файла}.
   Примеры:

{Эта процедура транспонирует байт, т.е. меняет  местами биты}
{2'0 и 2'7, 2'1 и 2'6 и т.д.                                }

prosedure TranspByte (b:byte; var r: byte);
   begin
   inline (iLHLD /addr(b)-1 {H-РЕГ.:=b}
         / iMV1_C  /8
         / iDAD_H
         / iRAR
         / iDCR_C
         / iJNZ   / *+-3
         / iLHLD   / r
         / iMOV_M_A       );
end;


   7.2. Структурные операторы.

   Структурные операторы включают в  себя  другие  операторы,
которые исполняются последовательно, в зависимости от условия
или циклически. Операторы, входящие в состав структурных опе-
раторов, сами могут быть структурными.

структурный             составной оператор
оператор                условный оператор
                        оператор цикла
                        оператор with


   7.2.1. Составной оператор.

   Составной оператор имеет следующий синтаксис:


составной       begin           оператор        end
оператор                            ;


   Выполнение составного оператора состоит в последовательном
выполнении входящих в его состав операторов.
   Т.к. пустой оператор является одним из возможных вариантов
оператора, вы с равным успехом можете писать как:

begin x:=0; y:=0; end

так и:

begin x:=0;; y:=0;;;end


   7.2.2. Условный оператор.

   Условный оператор позволяет выбрать для  выполненния  один
(или ни одного) из входящих в его состав  операторов.  Имеет-
ся два условных оператора: оператор if и оператор case.


условный        оператор if
оператор        оператор case



   7.2.2.1. Оператор if.

   Оператор if имеет следующий синтаксис:


оператор if     if      выражение       then    оператор
                                        else    оператор


   Выражение,  стоящее  после  зарезервированного  слова  if,
должно иметь тип boolean. При выполнении оператора if сначала
вычисляется выражение. Если его значение есть True, то выпол-
няется оператор, стоящий после then. Если же значение выраже-
ния есть False, то выполняется оператор, стоящий после else -
или вообще никаких действий не выполняется, если альтернатива
else отсутствует.
   Во вложенных операторах if очередное слово else  считается
связанным с ближайшим слева словом if, с которым еще не  свя-
зано слово else. Т.е. конструкция:

if el then if e2 then s1 else s2

трактуется как:

if e1
then begin
   if e2
   then s1
   else s2
end

   Если вам в подобном случае необходимо, чтобы else  относи-
лось к внешнему if, вы должны включить внутренний оператор if
внутрь составного оператора:

if e1
then begin
   if e2
   then s1
end
else 2

   Составной оператор придется употребить также во  всех  тех
случаях, когда альтернативой должен быть не отдельный  опера-
тор, а последовательность операторов.
   Если выражение, стоящее после if, является константным, то
оно вычисляется на этапе компиляции и компилятор не генериру-
ет код проверки условия и генерирует только код одной альтер-
нативы - той, которая должна выполняться (если значение выра-
жения есть False, а else отсутствует, то вообще кода не гене-
рируется). Этим можно воспользоваться для  условной  компиля-
ции.
   Примеры:

if x< 1.5
then z:=x
else z:=1.5;
if p1<> nil
then begin write (p1/\.name); p1:=p1/\.father end;

   Обратите внимание : если присутствует  альтернатива  else,
то после оператора из альтернативы then ";" быть не должно!


   7.2.2.2. Оператор case.

   Оператор case имеет синтаксис:

оператор   case     выражение   of    случай
case                                    ;

                else-часть      .       end


случай     константное     ..   константное    :   оператор
           выражение            выражение



else-часть      else    оператор


   Выражение, стоящее после слова case,может быть любого упо-
рядоченного типа, кроме longint. Типы  константных  выражений
должны быть совместимыми с типом выражения.
   Выполнение оператора case происходит  следующим  способом.
Вначале вычисляется выражение. Затем его значение сравнивает-
ся с значениями константных выражений. Если значение  выраже-
ния совпадает с одним из константных выражений или попадет  в
интервал, задаваемый парой константных выражений, то выполня-
ется соответствующий оператор и на этом выполнение  оператора
case заканчивается. Если же такого не произошло,  выполняется
оператор, указанный после else - или не  выполняется  никаких
действий, если else отсутствует.
   Примеры:

case     operator       of
   plus: z:=x+y;
   minus:z:=x-y;
   times:z:=x*y;
end;

case i of
0,2,4,6,8 :writeln ('even digit');
1,3,5,7,9 :writeln ('odd digit' );
10..100   :writeln ('between 10 and 100');
   else    writeln ('negativ or >100');
end;

   В отличие от оператора if случай,  когда  выражение  после
слова case является константным, не обрабатывается компилято-
ром EP; полный код выполнения оператора генерируется во  всех
случаях.


   7.2.3. Операторы цикла.

   Оператор цикла содержит один или несколько операторов, ко-
торые должны выполняться циклически.


оператор        оператор repeat
цикла           оператор while
                оператор for


   Оператор for используется, если необходимое число повторе-
ний цикла известно до начала его выполнения. В остальных слу-
чаях используются операторы repeat и while.


   7.2.3.1. Оператор repeat.

   Синтаксис:

оператор       repeat   оператор      until     выражение
repeat                     ;


   Выражение, стоящее после слова until, должно быть типа bo-
olean.
   Выполнение оператора repeat происходит следующим способом.
Выполняется последовательность операторов, стоящих между  re-
peat и until, и затем вычисляется  выражение.  Если  значение
выражения есть True, то выполнение оператора repeat  на  этом
заканчивается. В противном случае последовательность операто-
ров выполняется снова и т.д.,  пока  значением  выражения  не
станет True.
   Выражение, стоящее после слова until, может быть  констан-
тным. В этом случае компилятор не генерирует кода  вычисления
и проверки значения выражения, а поступает следующим образом:
если значение выражения есть True, то генерируется код однок-
ратно выполняемой последовательности операторов; если  значе-
ние выражения есть False, то генерируется бесконечный цикл. В
последнем случае внутри последовательности  операторов  между
repeat и until должен быть предусмотрен выход из цикла с  по-
мощью оператора goto или процедуры Exit.
   Примеры:
                                        {Алгоритм Eвклида}
repeat
k:=i mod j; i:=j; j:=k;
until j=0;
   repeat
   write ('Введите число от 0 до 9:'); readln (i);
   until (i>=0) and (i<=9);


   7.2.3.2. Оператор while.

   Синтаксис:

оператор        while   выражение     do     оператор
while


   Выражение, стоящее между словами while и do, должно  иметь
тип boolean.
   Выполнение оператора while происходит следующим  способом.
Сначала вычисляется выражение. Если его значение  есть  True,
то выполняется оператор, затем снова вычисляется выражение  и
т.д., пока значение выражения не станет равным False -  после
чего выполнение while завершается. Обратите внимание, что ес-
ли при первом вычислении выражения  будет  получено  значение
False, то оператор не будет выполнен ни разу - в  отличие  от
оператора repeat, где последовательность операторов  выполня-
ется по крайней мере один раз.
   Если требуется, чтобы в цикле выполнялось несколько опера-
торов, то следует воспользоваться составным оператором.
   Выражение, стоящее между словами while и do ,  может  быть
константным. В этом случае компилятор не генерирует кода  вы-
числения и проверки значения выражения, а поступает следующим
образом: если значение выражения есть False, то никакого кода
не генерируется; если же значение выражения есть True, то ге-
нерируется бесконечный цикл. В последнем случае внутри после-
довательности операторов между repeat  и  until  должен  быть
предусмотрен выход из цикла с помощью оператора goto или про-
цедуры Exit.
   Примеры:

while not Eof (lnfile)          {вывод текстового файла}
do begin                        {на экран}
   readln (lnfile, line);
   writeln (line);
end;


   7.2.3.3. Оператор for.

   Синтаксис:

оператор       for     управляющая     :=       начальное
for                    переменная               значение

   to           конечное        do      оператор
   downto       значение


управляющая             статическая ссылка
переменная              на переменную


начальное               выражение
значение


конечное                выражение
значение


   Управляющая переменная может быть  компонентой  какой-либо
структурной переменной, но адрес  ее  должен  вычисляться  на
этапе компиляции.
   Управляющая переменная должна иметь упорядоченный тип. На-
чальное и конечное значения должны  иметь  типы,  совместимые
относительно присваивания с типом управляющей переменной.
   Выполнение оператора  for  происходит  следующим  образом.
Вначале вычисляются начальное и конечное значения,  пусть  их
порядковые номера есть a и b. Далее вычисляется число  повто-
рений цикла: оно есть b-a+1, если использовано  слово  to,  и
есть a-b+1, если использовано слово downto.  Если  это  число
оказалось отрицательным или равным 0, то выполнение оператора
for на этом заканчивается. Иначе оператор, расположенный пос-
ле слова do, выполняется вычисленное число раз. Перед  первым
его выполнением управляющей переменной присваивается  началь-
ное значение; после каждого выполнения оператора значение уп-
равляющей переменной увеличивается (если  использовано  слово
to) или уменьшается (если использовано слово downto) на 1.
   Обратите внимание на то, что перед началом выполнения цик-
ла вычисляется именно число повторений цикла - поэтому  ника-
кие изменения переменных , входящих в состав начального и ко-
нечного значений, или управляющей переменной в теле цикла  не
смогут изменить числа  повторений  цикла.  Обратите  внимание
также на то, что в Паскале тело цикла for может  ни  разу  не
выполниться - в отличие, например, от языков FORTRAN и BASIC,
где в аналогичном случае тело цикла  выполняется  по  крайней
мере один раз.
   В языке Паскаль запрещается  менять  значение  управляющей
переменной в теле цикла; к чему это приведет в языке  EP  см.
выше.
   После нормального заверщения цикла for  значение  управля-
ющей переменной не определено; однако, если  выход  из  цикла
произошел с помощью оператора goto, значение управляющей  пе-
ременной, при котором произошел выход, сохраняется.
   Если требуется, чтобы в цикле выполнялось несколько опера-
торов, то следует воспользоваться составным оператором.
   Компилятр EP оптимизирует  организацию  цикла  в  случаях,
когда начальное и конечное значения (одно из них или оба) яв-
ляются константными.
   Возможность помещать на месте управляющей переменной  про-
извольную статическую ссылку на переменную является  расшире-
нием как по сравнению со стандартом Паскаля, так и по сравне-
нию с TURBO PASCAL v.4.0.
   Примеры:

max:=data [i];    {поиск макс. элемента в массиве data}
for i:=2 to 99
do if data [i] > max then max:=data [i];


   7.2.4. Оператор with.

   Оператор with позволяет в случаях, когда приходится  много
работать с полями одной переменной-записи , избавиться от не-
обходимости каждый раз в ссылке на поле записи указывать  имя
переменной и точку. Оператор with имеет синтаксис:


оператор        with    ссылка на              do   оператор
with                    переменную-запись


ссылка                          ссылка на переменную
на переменную-запись


   Примеры:

with date                       {переход к следующему месяцу}
do if month=12
then begin month:=1; year:=succ(year); end
else month:=succ(month);

   Эта последовательность операторов  полностью  эквивалентна
последовательности:

if date.month 12
then begin
   date.month:=1;
   date.year:=succ(date.uear);
end
else date.month:=succ(date.month);

   Внутри оператора with компилятор всегда ,  начиная  анализ
ссылки на переменную, проверяет, не является ли идентификатор
, с которого начинается ссылка на переменную, идентификатором
поля записи, объявленной в операторе with. Если это  так,  то
идентификатор считается ссылкой на это поле записи - даже ес-
ли в текущий момент доступна другая переменная с таким  иден-
тификатором. Например, если описаны переменные:

type point = record x,y:integer end;
var x:point;
y:integer;

то в следующей последовательности операторов:

with x
do begin x:=1; y:=2; end;

первое вхождение есть ссылка на переменную x, а второе  вхож-
дение x и единственное вхождение у суть ссылки на поля  пере-
менной x (x.x и x.y) - а не ссылки на переменные x и y!
   Оператор with со списком переменных:

with rec1, rec2,...,recN do S;

эквивалентен последовательности вложенных операторов with:

with rec1
do with rec2
   do ...
         with recN
   do S;

   Если две записи, указанные во вложенных  операторах  with,
имеют поле с одним и тем же идентификатором, то указание это-
го идентификатора будет означать ссылку  на  поле  записи  из
внутреннего оператора with.
   Если во внутреннем  операторе  with  вы  укажете  перемен-
ную-запись того же типа, что и во внешнем, то к полям внешней
записи уже нельзя будет получить доступ, указав только  иден-
тификатор поля: это будет ссылка на поле  внутренней  записи.
Однако, вы по-прежнему можете ссылаться на поля внешней запи-
си, указывая их полные имена.
   Ссылка на переменную, задаваемая в операторе  with,  может
быть вычисляемой (содержать индексы, разыменователи и  т.п.).
В этом случае она вычисляется один раз  в  начале  выполнения
оператора with.

   ГЛАВА 8

   ПРОЦЕДУРЫ И ФУНКЦИИ


   Процедуры и функции  позволяют  вкладывать  дополнительные
блоки в блок главной программы. Описание каждой  процедуры  и
функции имеет заголовок , за которым следует блок.  Процедура
активизируется с помощью оператора вызова процедуры;  функция
активизируется в процессе вычисления выражения,  которое  со-
держит вызов функции; в результате ее  выполнения  получается
значение функции, которое используется далее  для  вычисления
выражения.
   В этой главе обсуждаются различные формы описания процедур
и функций и описание и способ передачи им параметров.


   8.1. Описание процедуры.

   Синтаксис:

описание        заголовок               тело
процедуры       процедуры       :       процедуры       ;


заголовок                    procedure       идентификатор
процедуры       private
                                список формальных параметров

   Заголовок процедуры определяет идентификатор  процедуры  и
список ее формальных параметров (если  процедура  их  имеет).
Структура списка формальных параметров описана далее .
   Зарезервированное слово private может быть  указано  перед
любым заголовком процедуры, но оказывает  действие  только  в
interface-части модуля.


тело                    блок
процедуры               forward


   Тело процедуры является либо блоком, либо состоит из слова
forward. В последнем случае далее в тексте  программы  должно
появиться второе описание этой же процедуры , в котором  тело
является блоком. Подробнее forward-описания процедур  и  фун-
кций описаны далее в настоящей главе.
   Как уже упоминалось, процедура  активизируется  с  помощью
оператора вызова процедуры, который состоит  из иден-
тификатора процедуры и (возможно) списка фактических парамет-
ров. Оператор вызова процедуры может встретиться и в теле са-
мой процедуры; это означает рекурсивный  вызов  процедуры.  В
языке EP работа с рекурсивными процедурами и функциями  имеет
некоторые особенности; они описаны далее.
   Пример описания процедуры:

{преобразовать число в строку - десятичное представление}

procedure NumToStr (N:integer; var S:string);
   var v:integer;
   begin
   v:=abs(N); S:='';
   repeat
     S:=chr (v mod 10 + ord('0')) + S;
     v:=v div 10;
     catil v=0;
     if N < 0 then S:='-' + S;
end;


   8.2. Описание функции.

   Синтаксис:

описание       заголовок      ;    тело         ;
функции        функции             функции



заголовок                 function      идентификатор
функции         private


         список формальных      :       тип
         параметров                     результата


тип                     идентификатор типа
результата                      string



   Заголовок функции опеределяет идентификатор функции и спи-
сок ее формальных  параметров  (если  она  имеет  параметры).
Структура списка формальных параметров описана далее.
   Зарезервированное слово private может быть  указано  перед
любым заголовком функции, но оказывает действие только в  in-
terface-части модуля.


тело            блок
функции         forward


   Тело функции является либо блоком, либо состоит  из  слова
forward. В последнем случае далее в тексте  программы  должно
появиться второе описание этой же функции, в котором тело яв-
ляется блоком. Подробнее forward-описания процедур и  функций
описаны далее в настоящей главе.
   В разделе операторов блока,  составляющего  тело  функции,
должен по крайней мере один раз встретиться оператор  присва-
ивания, левая часть которого есть  идентификатор  описываемой
функции (и функция должна быть запрограммирована  так,  чтобы
этот оператор обязательно выполнялся при каждом  вызове  фун-
кции). Значение, присваиваемое этим оператором,  и  есть  ре-
зультат функции. Если функция содержит несколько таких опера-
торов (или оператор в процессе одного вызова выполняется нес-
колько раз), то результатом функции будет значение ,  присво-
енное последним по времени выполнения оператором.
   Как уже упоминалось, функция активизируется при вычислении
выражения, содержащего вызов  функции.  Вызов  функции  может
встретиться и в теле самой функции; это означает  рекурсивный
вызов функции. (Если  идентификатор  функции  является  левой
частью оператора присваивания, то это не вызов  функции!).  В
EP работа с рекурсивными процедурами и функциями имеет  неко-
торые особенности; они описаны далее.



   8.3. Параметры.

   Описание процедуры или функции включает список  формальных
параметров. Каждый параметр, описанный  в  списке  формальных
параметров, является локальным для данной процедуры (функции)
и доступен лишь в пределах ее блока.


список формальных       (    описание параметров    )
параметров                              ;



описание                список
параметров      var     идентификаторов         тип
                                           :    параметров



тип                     идентификатор типа
параметров                      string



   Каждый из параметров является либо  параметром,  передава-
емым по значению, либо параметром,  передаваемым  по  ссылке,
либо нетипизированным параметром.  Признаком  этого  является
следующее:

** описание параметров, которое не содержит слова var,  явля-
ется описанием параметров, передаваемых  по  значению.  Такое
описание параметров обязательно должно содержать тип парамет-
ров.

** описание параметров, начинающееся со слов var и содержащее
тип параметров, является описанием  параметров,  передаваемых
по ссылке.

** описание параметров, начинающееся со слова var и не содер-
жащее типа параметров,  является  описанием  нетипизированных
параметров.

   Описание параметров, не содержащее ни слова var,  ни  типа
параметров, является недопустимым.
   Нетипизированные параметры являются расширением по сравне-
нию со стандартом Паскаля.
   Обратите внимание на то, что в  качестве  типа  параметров
можно указывть только идентификатор типа  или  слово  string.
Это объясняется одним из принципиальных моментов  языка  Пас-
каль. Дело в том, что при проверке соответствия формальных  и
фактических параметров требуется либо совместимость типов от-
носительно присваивания (для параметров, передаваемых по зна-
чению), либо идентичность типов (для параметров, передаваемых
по ссылке). Если бы вы смогли в заголовке процедуры  записать
какой-либо составной тип, то  (в  соответствии  с  правилами,
приведенными в главе 3) он не был бы ни идентичным,  ни  сов-
местимым ни скаким другим типом - вы не смогли бы вызвать эту
процедуру, т.к. не смогли бы передать ей параметр. Чтобы убе-
речь вас от этой ошибки, в Паскале тип параметра  может  быть
указан только идентификатором.
   При вызове процедуры или функции после  ее  идентификатора
должен быть помещен список фактических параметров. Количество
фактических параметров в списке должно совпадать  с  количес-
твом формальных параметров, указанных в  описании  процедуры.
При выполнении вызова процедуры или  функции  устанавливается
соответствие между фактическими  и  формальными  параметрами.
Способ установления соответствия зависит  от  вида  параметра
(передаваемый по значению, передаваемый по ссылке или нетипи-
зированный); он описан в следующих разделах.


   8.3.1. Параметры, передаваемые по значению.

   Формальный параметр, передаваемый по значению,  фактически
есть локальная переменная процедуры. Единственное отличие  от
других локальных переменных состоит в том, что в момент вызо-
ва процедуры переменной - формальному параметру присваивается
начальное значение, равное значению  фактического  параметра.
Изменения формального параметра  ,  выполняемые  в  процедуре
(функции) никак не затрагивают формальный параметр.
   Фактический параметр, соответствующий формальному парамет-
ру, передаваемому по значению, должен  быть  выражением;  его
тип должен быть совместимым относительно присваивания с типом
формального параметра. (Из этого ,в частности,  следует,  что
файловые параметры не могут передаваться  по  значению,  т.к.
файловые типы и составные типы, содержащие фаловые  компонен-
ты, не совместимы относительно присваивания ни с каким  типом
- даже с самим собой).
   Указание  в  качестве  типа  формального  параметра  слова
string эквивалентно указанию идентификатора типа, идентичного
string [255].
   Обратите внимание на то, что значение  фактического  пара-
метра (при передаче по значению) всегда копируется в перемен-
ную-формальный параметр - независимо от того, какого  размера
это значение. Это, разумеется, требует и  памяти  и  времени.
Поэтому часто бывает уместно вместо параметра , передаваемого
по значению, использовать параметр,  передаваемый  по  ссылке
- возможно, в ущерб логике программы.


   8.3.2. Параметры, передаваемые по ссылке.

   Фактический параметр, соответствующий формальному парамет-
ру, передаваемому по ссылке, должен быть ссылкой на  перемен-
ную типа, идентичного типу формального параметра.
   Все обращения к формальному  параметру  в  теле  процедуры
(функции) вызывают обращения к переменной - фактическому  па-
раметру; изменение формального параметра  означает  изменение
этой переменной.
   Ссылка на переменную - фактический параметр может  быть  и
вычисляемой (содержать индексы или  разыменователи).  В  этом
случае она  вычисляется  один  раз  перед  вызовом  процедуры
(функции); все дальнейшие изменения  переменных,  от  которых
зависела ссылка, не меняют связанной с формальным  параметром
переменной.
   Указание  в  качестве  типа  формального  параметра  слова
string эквивалентно указанию идентификатора типа, идентичного
string [255].
   Единственным исключением из правила,  требующего  идентич-
ности типов формального и фактического  параметров,  является
случай передачи параметров строковых типов.  Если  компиляция
выполняется с директивой {$V-} (или вообще без этой  директи-
вы, т.к. такой режим установлен по умолчанию),  то  для  фор-
мального параметра строкового типа достаточно,  чтобы  факти-
ческий параметр был тоже строкового типа - неважно,  с  каким
атрибутом длины. Если же компиляция выполняется с  директивой
{$V+}, то необходимо, чтобы длины строк совпадали.  В  случае
компиляции с директивой {$V-} компилятор считает, что строко-
вая переменная, переданная по  ссылке,  имеет  атрибут  длины
формального параметра - и ответственность за возможный  выход
за пределы длины фактического параметра  лежит  на  программе
пользователя.
   Файловые параметры могут быть переданы только по ссылке.


   8.3.3. Нетипизированные параметры.

   Когда формальный параметр является нетипизированным,  фак-
тическим параметром может быть любая ссылка на  переменную  -
независимо от ее типа.
   Внутри процедуры (функции)  нетипизированный  параметр  не
имеет типа - и, следовательно, несовместим ни с каккой другой
переменной. Единственный способ использовать нетипизированный
параметр - это ретипировать его  (с  помощью  преобразователя
типа переменной или с помощью absolute-переменной).
   Использование нетипизированных  параметров  удобно  в  тех
случаях, когда необходимо создать процедуру или функцию, спо-
собную работать с параметрами различных типов. Эта  процедура
(функция) может быть устроена так, что для ее выполнения  во-
обще не важен тип параметра, либо она может работать с  пара-
метрами типов из определенного набора - а то, какой  параметр
ей передан, она узнает из других  параметров  или  глобальных
переменных.



   8.4. Frorward-описание.

   Описание процедуры или функции, содержащее после заголовка
слово forward, называется forward-описанием; описание, содер-
жащее после заголовка блок - определяющим описанием.
   Если  в  каком-либо  разделе  описаний  встретилось   for-
ward-описание, то далее в этом же разделе описаний должно по-
явиться определяющее описание этой же процедуры (функции).
   Заголовок определяющего  описания  должен  либо  полностью
совпадать с заголовком forward-описания, либо содержать толь-
ко слово procedure (function) и идентификатор -  т.е.  список
формальных параметров и тип результата для функции могут быть
опущены в повторном описании.
   Между первым forward-описанием некоторой  процедуры  и  ее
определяющим описанием могут находиться другие forward-описа-
ния этой же процедуры. В этом случае их заголовки должны либо
полностью совпадать с  заголовком  первого  forward-описания,
либо содержать только слово procedure (function) и  идентифи-
катор. Повторные forward-описания уместны в тех случаях, ког-
да вы имеете несколько include-файлов и включаете их в разные
программы в разных сочетаниях.
   Forward-описания необходимы в тех случаях, когда вы имеете
две или более процедуры, каждая из которых  вызывает  другую.
Без forward-описаний сделать это невозможно; перед  тем,  как
вызвать процедуру, вы должны ее описать, а ни одно из опреде-
ляющих описаний вы не можете поместить первым:  в  нем  нужно
сослаться на вторую процедуру, а она еще не описана.
   Пример:

procedure p1(x:real); forward;
procedure p2 (n:integer);
   begin ... p1(0.5); ... end;

procedure p1;
   begin ... p2(2); ... end;



   8.5. Рекурсивные процедуры и функции.

   Рекурсивные процедуры и функции - это  такие  процедуры  и
функции, которые вызывают сами себя непосредственно или через
цепочку других процедур и функций.
   Пример рекурсивной функции:

function fact (n:byte) :longint;  {факториал числа n}
   begin
         if n>0
         then fact:=n*fact (n-1)
         else fact:=1;
   end;

   Классический метод реализации рекурсивных процедур  требу-
ет, помимо всего прочего, активного  использования  косвенной
адресации. В EP применен  специальный  метод.  Ограничения  и
требования к оформлению программы этого метода реализации ре-
курсивных процедур описаны в главе 13.
   Ограничение состоит в том,  что  рекурсивные  процедуры  и
функции не могут иметь параметров, передаваемых по ссылке  (в
частности, нетипизированных параметров).
   Дополнительное требование к программе  состоит  в  том,что
рекурсивные процедуры и функции  должны  компилироваться  при
директиве компилятора {$A-} (по умолчанию установлен противо-
положный режим). В частности, перед фрагментами, приведенными
в примерах в конце предыдущего  раздела  и  в  начале  этого,
должна находиться директива {$A-}.
   Можно поставить директиву {$A-} в начале программы - тогда
вы можете не задумываться о том, какую процедуру -  рекурсив-
ную или нет - вы в данный момент создаете. Но это приведет  к
тому, что нерекурсивные процедуры будут скомпилированы  менее
эффективно. Поэтому, если для вас важно получить наиболее ка-
чественный код, мы рекомендуем ставить директиву {$A-}  перед
началом каждой рекурсивной процедуры (функции),  а  после  ее
окончания  - директиву {$A+}.
   Процедуры, имеющие forward-описание будут  компилироваться
как рекурсивные, если первое  forward-описание  находилось  в
области действия директивы {$A-1}.
   Компилятор обнаруживает рекурсивные процедуры и функции, и
если они были скомпилированы без директивы {$A-}, выдает  со-
общение об ошибке.





   ГЛАВА 9

   ПРОГРАММЫ И МОДУЛИ


   9.1. Программы.

   Синтаксис программы на языке паскаль очень похож  на  син-
таксис процедуры. Отличаются они лишь  заголовком,  возможным
наличием предложения uses и тем, что после завершающего прог-
рамму end ставится не точка с запятой, а точка.


программа                                       блок    .
                заголовок       предложение
                программы       uses


заголовок       program         идентификатор
программы
                (   параметры программы    )     ;


параметры               список идентификаторов
программы


   Заголовок программы задает имя программы и список ее пара-
метров. В EP он играет чисто декоративную роль и  может  быть
опущен.


   9.1.1. Предложение uses.

   Предложение uses задает модули, используемые в программе.


предложение       uses      идентификатор       ;
uses                            ,



   Если выша программа использует модули Unit1, Unit2,  и мо-
дуль Unit1 использует модуль Unit2, то в предложении uses имя
Unit2 должно предшествовать имени Unit1.
   Если ваша программа использует модуль Unit1, модуль  Unit1
использует модуль Unit2, но в программе модуль  Unit2  непос-
редственно не используется, то в предложении uses  достаточно
указать только имя Unit1.
   В процессе компиляции предложения uses компилятор считыва-
ет с диска файлы, содержащие перечисленные в предложении uses
модули. Если в предложении uses указан идентификатор  UnitNa-
me, то соответствующий модуль должен  находиться  в  файле  с
именем UNITNAME.EPU; этот файл должен находиться  на  текущем
диске. Если идентификатор модуля содержит более 8-и литер, то
имя файла образуется из первых 8-ми. Рекомендуем использовать
в качестве имен модулей идентификаторы, содержащие  не  более
8-и литер.
   Все стандартные идентификаторы считаются  определенными  в
модуле System, который считается используемым первым в  любой
программе.


   9.2. Модули.

   Модули - это основа модульного  программирования  в  языке
EP. Они позволяют создать библиотеки  процедур,  и  позволяют
разбить большую программу  на части.
   Модуль имеет следующую структуру:


модуль          заголовок       interface-часть
                модуля          implementation-часть
                                initialization-часть    .



   9.2.1. Заголовок модуля.

   Заголовок модуля имеет следующую структуру:


заголовок       unit    идентификатор    .
модуля


   Идентификатор, задаваемый в заголовке, является именем мо-
дуля, под которым он далее будет известен. Этот идентификатор
используется для формирования имени файла,  в  котором  будет
храниться скомпилированный модуль, и должен быть употреблен в
предложениях uses в программах и модулях, использующих данный
модуль. Имя файла, в котором хранится скомпилировнный модуль,
образуется  из  идентификатора  путем  добавления  расширения
".EPU"; если идентификатор содержит более 8-и литер,  то  ис-
пользуется только первые 8.
   Если в программе используется несколько модулей ,  то  все
они должны иметь различные имена. Идентификатор модуля  обла-
дает одним свойством, отличающим его от других  идентификато-
ров: он не может быть переопределен. В частности, в программе
или модуле не может быть переопределен идентификатор  System,
поскольку считается, что такой модуль  используется  в  любой
программе.


   9.2.2. Interface-часть.

   В interface-части описываются константы, типы, переменные,
процедуры и функции, которые должны быть доступными из других
модулей.
   Interface-часть имеет следующую структуру:


Interface-      Interface
часть                         предложение       раздел
                                 uses           описаний
                                                констант
                                                разд.о-ий
                                                типов
                                                разд.о-ий
                                                переменных
                                                раздел
                                                заголовков
                                                проц. и ф-ий


раздел заголовков               заголовок процедуры     ;
процедур и функций              заголовок функции


   Раздел заголовков процедур и функций по сути дела  состоит
из forward-описаний; отличие состоит лишь в том, что в inter-
face-части слово forward после заголовка процедуры  или  фун-
кции не ставится. Для всякого заголовка процедуры или функции
в implementation-части должно находиться определяющее  описа-
ние этой процедуры (функции). Как и в  случае  forward-описа-
ний, заголовок  процедуры  (функции)  в  implementation-части
должен либо совпадать с заголовком  в  interface-части,  либо
содержать только идентификатор процедуры (функции).


   9.2.3. Implementation-часть.

   В implementation-части располагаются определяющие описания
процедур и функций, заголовки которых присутствовали в inter-
face-части. Кроме того, здесь содержатся описания  внутренних
констант, типов, переменных, процедур и функций модуля.


implementation-     implementation
часть                                   раздел описания
                                        меток
                                        раздел описаний
                                        констант
                                        раздел описаний
                                        типов
                                        раздел описаний
                                        переменных
                                        раздел описаний
                                        процедур и
                                        функций



   9.2.4. Initialization-часть.

   Initialization-часть завершает  модуль.  Она  представляет
собой либо составной оператор, либо единственное слово end.


initialization-         составной оператор
часть                   end


   Если initialization-часть является  составным  оператором,
то он исполняется всякий раз в начале работы программы, кото-
рая использует данный модуль. Если в  программе  используется
несколько модулей, то их инициализирующие  части  исполняются
перед началом работы программы в том порядке, в котором моду-
ли перечислены в предложении uses.























































































































































   ГЛАВА 10

   ВВОД И ВЫВОД


   В этой главе описываются механизмы ввода-вывода в языке EP
 и дается краткая характеристика  стандартных  процедур  вво-
да-вывода. Более подробное описание см. в главе 14.


   10.1. Общие замечания.

   Файловая переменная есть переменная файлового типа.  В  EP
имеется три класса файловых типов: типизированные, текстовые,
и нетипизированные. Синтаксические  правила  записи  файловых
типов приведены в главе 3.
   Перед тем, как использовать файловую переменную, ее  нужно
связать с внешним файлом, с помошью процедуры Assign. Внешний
файл обычно является дисковым файлом, однако он может быть  и
устройством - например, клавиатурой или принтером. Во внешнем
файле сохраняется информация , записываемая в файл, и он  яв-
ляется источником читаемой из файла информации.
   После того, как файловая переменная связана с внешним фай-
лом, она должна быть "открыта", т.е. подготовлена для  выпол-
нения операций чтения или  записи.  Существующий  файл  может
быть открыт с помошью процедуры Reset; новый файл может  быть
создан  и  открыт  с  помощью  процедуры  Rewrite.  Текстовый
файл,открытый с помощью процедуры Reset, доступен только  для
чтения; текстовый файл, открытый процедурой Rewrite  или  Ap-
pend, доступен только для записи. Типизированные и  нетипизи-
рованные файлы всегда доступны и для чтения и  для  записи  -
независимо от того , были они  ткрыты  процедурой  Reset  или
Rewrite (за исключением файлов  на  устройствах,  допускающих
только чтение или только запись).
   Есть 4 стандартные текстовые файловые  переменные:  Input,
Output, Kbd, Lst. Все они автоматически открываются в  момент
начала выполнения программы.

   I n p u t есть доступный только для чтения файл, связанный
с клавиатурой. При вводе из него  каждая  нажимаемая  клавиша
отображается на экране ("эхо"-ввод)  и  возможно  исправление
вводимой информации до нажатия клавиши Cr. Содержимое  строки
становится доступным программе только после  нажатия  клавиши
Cr. Подробнее возможности ввода  информации  из  файла  Input
описаны далее.

   O u t p u t есть доступный только для записи файл, связан-
ный с экраном.

   K b d есть доступный только для чтения файл,  связанный  с
клавиатурой. При вводе из него вводимая информация не отобра-
жается на экране (ввод без "эха"). Вводимая из файла Kbd  ин-
формация становится доступной программе сразу же после  нажа-
тия клавиши; исправление невозможно.

   L s t есть доступный только  для  записи  файл,  связанный
с принтером.

   Каждый файл  есть  линейная  последовательность  компонент
(записей), каждая из которых имеет тип компоненты файла. Каж-
дая компонента имеет свой номер. Номер первой компоненты фай-
ла есть 0.
   Доступ к файлам обычно осуществляется последовательно. Это
означает, что после того, как очередная компонента  прочитана
с помощью стандртной процедуры Read или  записана  с  помощью
стандартной процедуры Write, текущая позиция в файле  переме-
щается к следующей по порядку компоненте. Возможен  и  произ-
вольный доступ. Стандартная процедура Seek перемещает текущую
позицию в файле к компоненте с указанным  номером.  Формально
процедура Seek может быть применена к  любому  файлу,  однако
только для типизированных и нетипизированных файлов в резуль-
тате ее выполнения текущая позиция устанавливается перед ком-
понентой с номером, указанным в качестве аргумента Seek.
При применении процедуры Seek к текстовому файлу текущая  по-
зиция устанавливается перед байтом с указанным номером - а не
перед строкой с указанным номером, как можно было бы ожидать.
Поэтому применение процедуры Seek к текстовым файлам  разумно
лишь с указанием позиции , полученной ранее с  помощью  стан-
дартной функции FilePos (или к текстовым файлам, имеющим спе-
циальную структуру, известную программе). С помощью  стандар-
тных процедур FilePos и FileSize можно узнать текущую позицию
в файле и текущую длину файла.
   После того, как обработка файла завершена, он должен  быть
закрыт с помощью стандартной процедуры Close. Только при  вы-
полнении процедуры Close происходит окончательное  оформление
изменений во внешнем файле; если  программа  завершается  без
выполнения процедуры close, то есть риск,  что  внешний  файл
останентся недооформленным, и записанная  в  него  информация
будет потеряна. При выполнении процедуры  Close  связь  между
файловой переменной и внешним файлом не разрушается; этот  же
файл может быть снова открыт без предварительного  выполнения
процедуры Assign. С другой стороны, после выполнения процеду-
ры Close файловая переменная может быть связана с новым внеш-
ним файлом путем выполнения процедуры Assign.
   По умолчанию, при обращении ко всем стандартным процедурам
ввода-вывода автоматически выполняется  проверка  на  предмет
возникновения ошибки. Если  возникла  ошибка,  то  выполнение
программы прекращается, и  на  экран  выдается  сообщение  об
ошибке времени исполнения. Эта  автоматическая  проверка  ре-
зультата может быть включена или выключена с помощью директив
компилятора {$I+} и {$I-}. Если автоматическая проверка  вык-
лючена, т.е. если вызов процедуры или функции был скомпилиро-
ван в режиме {$I-}, то при  возникновении  ошибки  выполнение
программы не прекращается; код возникщей  ошибки  может  быть
получен вызывающей программой с помощью  стандартной  функции
IOResult. Значения, возвращаемые функцией IOResult, - это но-
мера ошибок периода исполнения, перечисленные в приложении Б.
Даже в режиме {$I-} ошибки, связанные с неправильным  обраще-
нием к процедурам ввода-вывода (применение процедуры Reset  к
файловой переменной, которая не  была  обработана  процедурой
Assign, применение процедуры  Read  к  неоткрытому  файлу;  и
т.д.) вызывают немедленное прекращение работы программы с вы-
дачей сообщения об ошибке времени исполнения. В режиме  {$I-}
необходимо после каждого  выполнения  процедуры  ввода-вывода
проверять ее результат с помощью вызова функции IOResult. Ес-
ли возникла ошибка, а функция IOResult не вызывалась, то  при
очередном обращении к процедуре ввода-вывода будет диагности-
рована (возникшая при предыдущем обращении) ошибка и выполне-
ние программы будет прекращено.
   На протяжении своей программы вы можете  неоднократно  ме-
нять режим проверки ошибок.
   Пример:

procedure GetFile (var f:text);
   var fn:string[16];
   label l;
   begin
         write ('Введите имя файла:'); readln (fn);
         Assign (f.filename);
   {$I-}
         Reset (f);
         if IOResult <>0
         then begin
                writeln ('??? Такого файла нет');
                goto l;
                end;
end.



   10.2. Виды файлов.

   Как уже упоминалось, имеется три вида файлов:
типизированные файлы,
нетипизированные файлы,
текстовые файлы.


   10.2.1. Типизированные файлы.

   Типизированные файлы - это файлы, тип которых  задается  с
помощью конструкции вида:

file of тип компоненты

   Типизированные файлы на диске начинаются с 6-ти  байтового
префикса, состоящего из двух полей:

байты    тип             содержимое

0-1      word       длина записи (компоненты) файла в байтах
2-5      longint    количество записей (компонент) в файле


   Значения типов word и longint записаны  в  соответствии  с
общими правилами (см. главу 13): первый  байт  поля  содержит
младший байт значения,..., последний байт поля содержит стар-
ший байт значения.
   Файлы на устройствах такого префикса не содержат.
   Далее идет  последовательность  компонента  файла.  Каждая
компонента имеет тип, указанный в  описании  файлового  типа;
формат представления компоненты во внешнем файле (и на диске,
и на устройстве) полностью совпадает с форматом представления
значений этого типа в памяти (о том, как представляются  зна-
чения различных типов в памяти, см. главу 13).


   10.2.2. Нетипизированные файлы.

   Нетипизированные файлы - это файлы, тип которых есть  file
(без последующего of тип компоненты). Нетипизированные  файлы
по сути дела являются каналами ввода-вывода  нижнего  уровня;
они позволяют работать с файлами независимо от их  логической
структуры.
   Нетипизированные файлы представляют  собой  последователь-
ности байтов, сгруппированных в блоки (деление на блоки явля-
ется логическим понятием, и никак не отражено в в  физическом
представлении внешнего файла). Размер блока может быть  задан
при выполнении процедуры Reset или Rewrite (только для  нети-
пизированных файлов в них допускается второй параметр - длина
блока).
   Для чтения из нетипизированных файлов и для записи  в  них
могут использоваться только процедуры BlockRead и  BlockWrite
(которые неприменимы для работы с файлами других видов).  Эти
процедуры обеспечивают только пересылку  байтов  из  внешнего
файла в память или обратно - без выполнения каких-либо прове-
рок и преобразований. Как вы будете трактовать эти последова-
тельности и что вы будете с ними делать - ваша личная забота.


   10.2.3. Текстовые файлы.

   Текстовые файлы - это файлы, тип которых задан  с  помощью
стандартного идентификатора Text.  Никакого  другого  способа
создать тип текстового файла нет.
   Внешний файл, связанный с текстовым  файлом  ,  трактуется
как последовательность литер,  организованных  в  строки  (но
будьте внимательны: это то же самое ,  что  file  of  char!).
Признаком конца каждой строки является специальный маркер ли-
тера  Cr,  или  последовательность  литер  Cr,Lf   (ASCII-код
Cr=$0D, Lf=$0A). Признаком конца  текстового  файла  является
литера /\Z (ASCII=$1A) или физический конец файла  (последнее
возможно только для дисковых файлов).
   Для работы с текстовыми файлами  используются  специальные
формы процедур Read и Write, позволяющие читать и  писать  не
только данные типа char, но и данные строковых и числовых ти-
пов (писать еще можно данные типа boolean). При вводе и выво-
де данных таких типов выполняются  форматные  преобразования;
они рассмотрены подробнее далее.


   10.3. Стандартные процедуры и функции ввода-вывода.

   В настоящем разделе кратко описываются стандартные  проце-
дуры и функции ввода-вывода. Подробное их описание приводится
в главе 14.
   Процедуры и функции ввода-вывода  делятся  на  5  основных
классов:

** процедуры и функции работы с диском, не затрагивающие фай-
ловой структуры;

** процедуры и функции, применимые для всех видов файлов;

** процедуры и функции, применимые только для  типизированных
файлов;

** процедуры и функции, применимые только для не типизирован-
ных файлов; 

** процедуры и функции, применимые только для текстовых  фай-
лов


   10.3.1. Процедуры и функции для работы с диском.

   В эту группу входят 2 процедуры и 2 функции:

процедура ChDir - изменяет текущие дицковод и номер пользова-
                  теля
функция DiskFree - сообщает размер свободного пространства на
                   текущем диске
функция DiskSize - сообщает общий размер диска
процедура GetDir - сообщает текущий дисковод и номер  пользо-
                   вателя

   Напомним, что при работе на Корвете с CP/M вы можете рабо-
тать с 5-ю дисками, которые обозначаются от A до E.
   Каждый файл на диске может быть снабжен номером  пользова-
теля от 0 до 15 (по умолчанию - 0). Ввиду того,  что  в  CP/M
v.2.0. затруднена работа с номерами пользователя ,  отличными
от 0, не рекомендуем вам ими пользоваться - хотя процедуры EP
и представляют такую возможность.


   10.3.2. Процедуры и функции,  применимые  для  всех  видов
           файлов

   Ниже приводится список процедур и функций, применимых  для
всех видов файлов:

п. Assign - связывает с файловой переменной имя внешнего фай-
            ла или устройства
п. Close - закрывает открытый файл
ф. Eof - сообщает значение флага "конец файла"
п. Erase - уничтожает дисковый файл
ф. FilePos - сообщает положение текущей позиции в файле
ф. FileSize - сообщает размер файла
ф. IOResult - сообщает результат выполнения предудущей опера-
              ции ввода-вывода
п. Rename - переименовывает дисковый файл
п. Reset - открывает существующий файл
п. Rewrite - создает и открывает новый файл
п. Seek - перемещает текущую позицию в файле в заданное место
п. Truncate - обрезает файл (удаляет из файла часть от  теку-
              щей позиции до конца)

   Функции FilePos, FileSize и  процедура  Seek  выполняют  в
точности предписанные действия только для типизированных фай-
лов на диске (поскольку только в них EP поддерживает структу-
ру, достаточную для выполнения этих операций). Для  остальных
видов файлов имеются некоторые ограничения. Для файлов на ус-
тройствах ни одна из этих процедур и функций неприменима (вы-
зов их не приводит к возникновению ошибки, но они не выполня-
ют никаких действий).
   Во-первых, напомним, что в CP/M дисковый файл  состоит  из
блоков длиною 128 байт каждый, и ОС позволяет создавать  фай-
лы, состоящие только из целого числа блоков. Т.о. , последний
блок файла может содержать неиспользованный  хвост.  Как  уз-
нать, где точно заканчивается файл, ОС оставляет на  усмотре-
ние программ, создающих и обрабатывающих файлы.  Единственное
соглашение имеется для  текстовых  файлов:  после  последнего
байта, принадлежащего текстовому файлу, ставится байт, содер-
жащий /\Z (ASCII=$1A); байт  с  таким  содержимым  появляться
внутри текстового файла не может.
   Поэтому для нетипизированных файлов функция FileSize выда-
ет размер, соответствующий целому числу 128-байтовых блоков. 
Кроме того, размер нетипизированного файла выдается в блоках,
размер которых был задан при открытии  файла;  для  получения
числа блоков физический размер файла (сообщаемый ОС и  всегда
кратный 128) делится на размер блока, указанный при  открытии
файла; если при этом получается дробная часть, то она откиды-
вается. В остальном функции FileSize и  FilePos  и  процедура
Seek для нетипизированных файлов выполняются корректно. Реко-
мендуем при работе с нетипизированными  файлами  пользоваться
размером блока 1; в некоторых случаях  оправдан  размер  128,
соответствующий физическому размеру блока на диске.
   Функции FileSize, FilePos  и  процедура  Seek  работают  с
текстовым файлом точно так же, как с нетипизированным  файлом
с размером блока 1; то, что реальный конец файла помечен бай-
том /\Z, ими никак не используется.
   Ввиду ограничений, накладываемых CP/M, процедура  Truncate
реализована только для типизированных файлов;  вызов  ее  для
других видов файлов, хотя и  допустим,  не  вызывает  никаких
действий. Но даже для типизированных файлов применение проце-
дуры Truncate только  делает  недоступными  хвостовые  записи
файла, не уменьшая физического размера файла.


   10.3.3. Процедуры и функции, применимые только для типизи-
           рованных файлов.

   К таковым относятся процедуры:

п. Read - читает одну или несколько записей из типизированно-
          го файла
п. Write - записывает одну или несколько записей в  типизиро-
           ванный файл


   10.3.4. Процедуры и функции, применимые только для не  ти-
           пизированных файлов.

   К таковым относятся процедуры:

п. BlockRead - читает один или несколько блоков из  нетипизи-
               рованного файла
п. BlockWrite - записывает один или несколько блоков в  нети-
                пизированный файл


   10.3.5. Процедуры и функции , применимые только для
           текстовых файлов.

   К таковым относятся:

п. Append - открывает существующий текстовый файл для дозапи-
            си
ф. Eoln - сообщает текущее значение флага "конец строки"
п. Read - читает один или несколько элементов  из  текстового
          файла
п. Readln - выполняет те же действия, что и п. Read, и допол-
            нительно перемещает текущую позицию в начало сле-
            дующей строки
ф. SeekEof - пропускает расположенные после  текущей  позиции
             пробелы, знаки табуляции и маркеры конца строки
             и сообщает возникшее после этого значение флага
             "конец файла"
ф. SeekEoln -пропускает расположенные после текущей позиции
             пробелы, знаки табуляции и сообщает
             возникшее после этого значение флага"конец
             строки"
п. Write - записывает один или несколько элкментов в  тексто-
           вый файл
п. Writeln - выполняет те же действия, что и п. Write, и  до-
             полнительно записывает во внешний файл маркер
             конца строки (Cr, Lf).

   Как уже упоминалось, имеется 4 предопределенных  текстовых
фала: два из них - Input и Output играют особую роль. В  про-
цедурах и функциях ввода-вывода, работающих с текстовыми фай-
лами, можно опустить имя файловой переменной. В  этом  случае
подразумевается переменная Input - при вводе,  или  -  Output
при выводе.
   В отличие от файловых типов других видов, текстовые файлы,
открытые процедурой Reset, доступны только для ввода, а  фай-
лы, открытые процедурами Rewrite и  Append,  доступны  только
для вывода.



   10.4. Форматные преобразования при работе
         с текстовыми файлами.

   При чтении или записи информации в текстовый файл,  выпол-
няются форматные преобразования. Целью их является преобразо-
вание данных из текстового формата с которым  работает  чело-
век, во внутренние форматы, с которыми работает  компьютер  -
при вводе , и в обратную сторону - при выводе.


   10.4.1. Форматные преобразования при вводе.

   Ввод из текстовых файлов выполняется с помощью п.  Read  и
Readln. При их вызове задается  список  вводимых  переменных.
Форматные преобразования выполняются отдельно для каждой  пе-
ременной и зависят от типа переменной.
   Процедура Readln отличается от процедуры Read тем, что при
чтении всех переменных из списка процедура Readln  пропускает
все литеры до начала следующей строки,  т.е.  все  литеры  до
ближайшего маркера конца строки , включая маркер конца строки
(если читалась последняя строка файла, то пропускаются литеры
до конца файла).
   Вводиться могут переменные типов char, строковых  типов  и
всех числовых типов.
   При вводе переменной типа char читается одна литера, кото-
рая присваивается переменной, и текущая позиция  продвигается
на одну литеру вперед. Если текущая позиция находилась в кон-
це строки, то прочитанная литера будет Cr, и следующей прочи-
танной литерой будет Lf. Если текущая  позиция  находилась  в
конце файла (значение ф. Eof перед выполнением процедуры Read
есть True), то значение прочитанной литеры будет  /\Z  ($1A);
текущая позиция при этом не продвигается.
   При вводе переменной строкового типа  читаются  литеры  от
текущей позиции до ближайшего маркера  конца  строки  или  до
конца файла; эти литеры составляют строковое значение,  кото-
рое присваивается переменной. Если текущая позиция  находится
непосредственно перед маркером конца строки или в конце файла
(значение ф. Eof перед выполнением п.  Read  есть  True),  то
прочитанное значение есть  пустая  строка.  Если  прочитанное
строковое значение превосходит по длине  максимальный  размер
строковой переменной, то оно обрезается (в строковую перемен-
ную попадает начало прочитанного значения).  Текущая  позиция
устанавливается перед маркером конца строки (или перед концом
файла) - независимо от того, поместилась ли прочитанная стро-
ка в переменную или нет; т.о если вы задали слишком  короткую
строковую переменную, хвост строки будет потерян  безвозврат-
но.
   Если строка была прочитана в строковую переменную процеду-
рой Read, то следующая попытка прочитать строку  в  строковую
переменную приведет к чтению пустой строки - т.к. текущая по-
зиция осталась перед маркером конца строки. Перейти к  началу
следующей строки можно только процедурой  Readln  (можно  еще
пропустить маркер конца строки, читая его в  переменные  типа
char, но этот метод не кажется естественным).  Поэтому,  если
вам нужно читать текстовый файл по строкам,  следует  пользо-
ваться процедурой Readln со списком из одной переменной стро-
кового типа.
   При чтении переменных числовых типов  сначала  выполняется
пропуск пробелов, знаков табуляции и маркеров  конца  строки.
То, что стоит после этого, должно быть числом (целым или  ве-
щественным, в зависимости от типа переменной),  записанным  в
формате для записи числовых констант язака Паскаль  (см.главу
1). Концом числа является пробел, знак табуляции, маркер кон-
ца строки или конец файла. Если внутри  числа  обнаруживаются
недопустимые литеры, возникает ошибка времени исполнения. Ес-
ли число имеет значение, которое не может  быть  размещено  в
переменной указанного типа (например, вы пытаетесь  прочитать
1000 в переменную типа byte), то возникает ошибка времени ис-
полнения. Если в период пропуска пробелов, знаков табуляции и
маркеров конца строки достигнут конец файла, то читается зна-
чение 0. После чтения эту ситуацию нельзя отличить  от  ситу-
ации, когда перед концом  файла  действительно  располагалось
число 0. Поэтому, в тех случаях,когда это для вас существенно
перед чтением числа выполняйте процедуру SeekEof.


   10.4.2. Форматные преобразования при выводе.

   Вывод в текстовые файлы осуществляется с помощью  процедур
Write и Writeln. При обращении к ним задается список  выводи-
мых выражений; вместе с каждым выражением может  быть  указан
спецификатор длины и количества десятичных знаков после точки
(последнее - только для выражений вещественного  типа).  Фор-
матные преобразования выполняются для значения каждого  выра-
жения в отдельности и зависят от его типа.
   В общем случае параметр п. Write или Writeln, задающий вы-
водимое выражение, имеет следующий вид:


параметр проц.                  выражение
Write или Writeln       .       минимальная ширина
                        :    число десятичных знаков


минимальная ширина      выражение целого типа

число десятичных знаков         выражение целого типа


   Процедура Writeln отличается от п. Write  тем,  что  после
завершения вывода значений выражений из  списка  она  выводит
маркер конца строки - последовательность Cr, Lf.
   Выводиться могут выражения всех числовых типов,  строковых
типов, типов char, boolean и упакованные массивы литер.
   Минимальная ширина задает минимальное число позиций, кото-
рое должно занять преобразованное выражение. Если  для  пред-
ставления значения достаточно меньшего числа позиций, то  оно
дополняется  слева  необходимым  числом  пробелов.  Если  для
представления значения требуется больше позиций, то выводимое
значение будет занимать столько позиций,  сколько  требуется.
Если минимальная ширина опущена, то значение выражения  также
займет столько позиций, сколько требуется для его представле-
ния. Минимальная ширина, если она задана, должна быть положи-
тельным числом.
   Число десятичных знаков задает число десятичных десятичных
знаков после точки в представлении вещественного числа в виде
с фиксированной точкой; оно может быть задано только для зна-
чений типа реал, и только если задана минимальная  ширина.  В
отличие от минимальной ширины, число десятичных знаков  может
быть 0 или отрицательным числом.
   При выводе значения типа char выводится задаваемая выраже-
нием литера.
   При выводе значения строкового типа или упакованного  мас-
сива литер выводится последовательность  литер,  составляющих
значение.
   При выводе значения типа boolean выводится  строка  'True'
или 'False' - в зависимости от значения выражения.
   При  выводе  значений  целых  типов  выводится  десятичное
представление целого числа без ведущих нулей.  Перед  отрица-
тельными числами ставится знак "-". Никаких пробелов в начале
или конце числа не помещается  (за  исключением,  разумеется,
того случая, когда перед числом ставятся пробелы для дополне-
ния его до минимальной ширины).
   Формат вывода вещественных чисел  зависит  от  того,  при-
сутствует или нет число десятичных знаков и каково его значе-
ние.
   Если число десятичных знаков отсутствует или его  значение
отрицательное, вещественное число выводится в формате с  пла-
вающей точкой. Если при этом отсутствует мимнимальная ширина,
то она считается равной  17;  если  минимальная  ширина  при-
сутствует и меньше 8, то она считается равной 8.
   Формат вывода числа с плавающей точкой следующий:
<знак> <цифра> <мантисса>е <знак порядка> <порядок>
где:
знак - ничего для положительного числа, "-" для отрицательно-
       го числа
цифра - старшая цифра мантиссы; она равна 0 только в том слу-
        чае, когда число равно 0
мантисса - остальные цифры мантиссы; количество их есть мини-
           мальная ширина - 7. Представление вещественных чи-
           сел, используемое в EP, обеспечивает  11  истинных
           десятичных цифр; поэтому, если в мантиссе требует-
           ся вывести более 10-и цифр, все цифры,  начиная  с
           11-й, будут 0
знак порядка - + или - в соответствии со знаком порядка
порядок - состоит всегда из двух десятичных цифр.

   Если число десятичных знаков присутствует и если 0, то вы-
вод производится в формате целого числа;  выводимое  значение
получается из вещественного числа путем округления (по  обыч-
ным правилам). Представление вещественных чисел, используемое
в EP , обеспечивает 11 истинных десятичных цифр; поютому, ес-
ли количество десятичных цифр в целой части  превосходит  11,
последние цифры будут 0-ми.
   Если число десятичных знаков присутствует и  положительно,
то вывод производится в формате числа с фиксированной точкой:
<знак> <целая часть> . <дробная часть>
где:
знак - "-" для отрицательного числа
целая часть -  последовательность  цифр,  составляющая  целую
               часть числа , без ведущих 0; если целая  часть
               числа равна 0, то эта последовательность
               состоит из одного 0
дробная часть - последовательность цифр, составляющих дробную
                часть в количестве число десятичных знаков.
                Если общее число десятичных цифр  в  целой  и
                дробной части превосходит 11, последние цифры
                будут 0

   Перед выводом числа в формате с фиксированной точкой,  оно
предварительно округляется до определяемого количеством число
десятичных знаков (по обычным правилам).
   Никаких пробелов к выводимому числу  не  прибавляется  (за
исключением дополнения до минимальной ширины).



   10.5. Имена дисковых файлов.

   При вызове процедуры Assign ей должен быть  передан  пара-
метр, определяющий внешний файл, с которым будет  происходить
дальнейшая работа. Этот параметр есть либо имя дискового фай-
ла, либо имя устройства (работу с устройствами см. далее).
   Имя дискового файла имеет следующую структуру:

   duu:nnnnnnnn.eee

d- обозначение дисковода (A,B,...,P).  Строчные  и  прописные
   буквы отождествляются.
uu- номер пользователя (0...15)
nnnnnnnn- имя файла, последовательность не более 8  латинских
          букв, цифр и спецзнаков кроме *, ., :, ;, <, =,  >,
          ?. (русские буквы не допускаются). Строчные и  про-
          писные буквы отождествляются
eee - расширение, последовательность  не  более  3  латинских
          букв, цифр и спецзнаков кроме *, ., :, ;, <, =,  >,
          ?. (русские буквы не допускаются). Строчные и  про-
          писные буквы отождествляются

   Обозначение дисковода и  (или)  номер  пользователя  могут
быть опущены; в этом случае будет выполняться работа с  теку-
щим дисководом и (или ) номером пользователя.  Если  одновре-
менно опускаются обозначение дисковода и номер  пользователя,
то следует также опустить двоеточие.
   Если расширение состоит из одних пробелов, то  предшеству-
ющая ему точка может быть опущена.
   Процедура Assign обрабатывает имя дискового  файла  следу-
ющим образом. Сначала пропускаются ведущие  пробелы  и  знаки
табуляции. Затем производится  разбор  имени  файла  в  соот-
ветствии с описанным синтаксисом до тех пор, пока не появится
литера, которая не может входить в имя файла или пока  строка
не закончится (пробел также не может входить в имя  файла,  и
при его появлении разбор  имени  файла  также  прекращается).
Возможно оставшийся хвост строки никак  не  обрабатывается  и
его наличие ошибкой не считается.


   10.6. Устройства в языке EP.

   Кроме работы с дисковыми файлами, в EP допускается  работа
с файлами на устройствах. Набор устройств, с которыми возмож-
на работа, определяется возможностями CP/M.
   Для того, чтобы файловая переменная оказалась связанной  с
устройством, необходимо при выполнении процедуры Assign вмес-
то имени файла указать имя устройства. Имя устройства  всегда
состоит из 4-х литер, первые три из которых являются буквами,
а четвертая есть двоеточие. В программе имя устройства  может
задаваться как строчными, так и прописными буквами.
   Доступ к устройствам всегда осуществляется с помощью вызо-
ва соответствующих процедур BDOS.
   Допустимыми являются следующие имена устройств:

   "CON:" устройство вывода на экран- реализуется через вызов
BDOS-процедуры ConOut (#2)
    или устройство ввода с клавиатуры с эхом- реализуется че-
рез вызов BDOS-процедуры ConBuf (#10)

   "KBD:" устройство ввода с клавиатуры без эха - реализуется
через вызов Паскаль-процедуры ReadKey (см. главу 14)

   "LST:" устройство вывода на печать - реализуется через вы-
зов BDOS-процедуры LStOut (#5)

   "AUX:" дополнительное устройство вывода - реализуется  че-
рез вызов BDOS-процедуры AuxOut (#4)
   или дополнительное устройство ввода  -  реализуется  через
вызов BDOS-процедуры AuxIn (#3)

   "NUL:" пустое устройство ввода-вывода

   Для некторых имен устройств допустимы синонимы:

"CON:" - ("CRT:" , "TTY:" , " ")
"LST:" - ("LPT:" , "PRN:")

   Операции ввода -вывода для устройств имеют некоторые отли-
чия по сравнению с соответствующими операциями  для  дисковых
файлов.
   Файлы на устройстве KBD: могут  быть  открыты  только  для
ввода. Файлы на устройстве LST: могут буть открыты только для
вывода. На всех остальных устройствах файлы могут быть откры-
ты как для ввода, так и для вывода; однако , файлы,  открытые
п.Reset доступны только для чтения, а файлы, открытые  п.Rew-
rite и Append, доступны только для записи.
   Операции открытия и закрытия для файлов на устройствах  не
выполняют никаких действий (кроме подготовки некоторых  полей
в файловых переменных).
   Функции FileSize и FilePos для файлов на устройствах всег-
да возвращают 0. Процедура Seek для них не выполняет  никаких
действий.
   Функция Eof для файлов на устройствах, открытых для ввода,
всегда возвращает False - за исключением файлов на устройстве
NUL:, для которых всегда возвращается True. Для  файлов,  от-
крытых для вывода, ф.Eof всегда возвращает True.
   Для типизированных файлов на устройствах при  открытии  не
считывается, а при закрытии не записывается  6-байтовый  пре-
фикс.
   Устройство NUL: - пустое устройство - не связано с  реаль-
ным физическим устройством. Файлы, открытые на нем для ввода,
всегда пустые; информация, записываемая  в  открытые  на  нем
входные файлы, просто исчезает.
   Использование файлов на устройстве NUL: уместно, например,
в следующем случае. Пусть ваша программа должна, в зависимос-
ти от условий запуска, либо создавать протокол своей  работы,
либо не создавать. Тогда вместо того, чтобы перед каждой опе-
рацией записи в протокол проверять флаг  создания  протокола,
вы можете просто в случае, когда протокол создавать не нужно,
назначить соответствующий файл на устройство NUL:.


   10.7. Ввод и вывод информации при работе
         с устройством CON:.

   При вводе информации из  дисковых  файлов  очередной  байт
(или последовательность байтов)  считываются  из  файла,  как
только в программе выполняется процедура ввода. При вводе ин-
формации с устройств KBD: или AUX: очередной байт попадает  в
программу, как только он  появляется  на  устройстве  (нажата
клавиша на клавиатуре или появился сигнал на линии связи).
   Иначе обстоит дело при вводе информации с устройства CON:.
Информация попадает в программу только при  завершении  ввода
строки. Поэтому в процессе ввода строки вы можете  исправлять
вводимую информацию (используя  BS).  Завершить  ввод  строки
нужно нажатием клавиши Cr. После этого информация попадает  в
программу и вы теряете возможность ее изменить.
   Несмотря на то, что вы завершаете ввод строки нажатием од-
ной клавиши, при политерном чтении будут прочитаны две  лите-
ры: Cr и Lf.
   Вывод на устройство CON: выполняется через процедуру BDOS.
Эта процедура трактует определенные упр.  символы  (литеры  с
ASCII-кодами меньше $20) и esc-последовательности как команды
для выполнения определенных операций над экраном (сдвиг экра-
на, вставка/удаление строки и  т.п.).  Этим  всем  вы  можете
пользоваться, включая в выводимую вами последовательность ли-
тер упр. символы и Esc-последовательности. О том , какие опе-
рации над экраном допустимы и какие упр.  символы  для  этого
требуются, вы можете узнать из руководства по ОС.
   Предопределенные файлы Input и Output  связаны  с  устрой-
ством CON: - со всеми вытекающими из этого последствиями.
   Заметим также , что на Корвете вы можете  выполнять  вывод
на экран путем непосредственной записи  информации  в  память
экрана (память экрана занимает 1 КБ и при работе в конфигура-
ции CP/M расположена по адресам от $FC00  до  $FFFF).  Непос-
редственная работа с памятью экрана обеспечивает более  высо-
кую скорость, чем вывод на него через устройство  CON:  -  но
требует от вас самостоятельно создавать такие процедуры,  как
сдвиг экрана и т.п.


   10.8. Предопределенные файлы.

   Как уже упоминалось, имеется 4  предопределенные  файловые
переменные:
Input, Output   (на устройстве CON:)
Kbd             (на устройстве KBD:)
Lst             (на устройстве LST:)

   Все эти файловые переменные имееют тип Text. Они отличают-
ся от определенных вами следующим. Во-первых,  вы  не  можете
связать с ними иные внешние файлы: попытка применения  к  ним
п.Assign вызывает ошибку времени  исполнения.  Во-вторых,  их
нельзя открыть или закрыть: попытка применить к ним п. Reset,
Rewrite, Append ,Close вызывает ошибку времени исполнения.
   Во всех остальных отношениях эти файловые переменные ведут
себя как и любые другие.














































































































































































   ГЛАВА 12

   ДИРЕКТИВЫ КОМПИЛЯТОРА


   Компилятор может выполнять генерацию  кода  результирующей
программы в нескольких различных режимах. Выбор этих  режимов
осуществляется с помощью директив компилятора.
   Синтаксически директива компилятора выглядит как коммента-
рий со специальной внутренней структурой. Директива  компиля-
тора может находиться в любом месте программы, в котором  мо-
жет находиться комментарий. Как и комментарий, директива ком-
пилятора может заключаться в скобки { } или (* *). В  отличие
от комментариев, которые могут занимать несколько строк,  ди-
ректива компилятора должна располагаться целиком  в  пределах
одной строки.
   Признаком директивы компилятора является знак $,  располо-
женный непосредственно за открывающей скобкой.  За  знаком  $
располагается буква - имя директивы; здесь строчные и пропис-
ные буквы отождествляются. Все, что расположено далее  -  это
аргументы директивы.
   Имеется два типа директив:
директивы- переключатели;
параметрические директивы.
   Аргумент директивы-переключателя состоит  из  единственной
литеры - знака "+" или "-", записываемого сразу после буквы -
имени директивы (пробел между именем директивы  и  аргументом
для директивы-переключателя является ошибкой).
   Аргументы параметрической директивы имеют структуру, зави-
сящую от директивы. Они должны отделяться от имени  директивы
по крайней мере одним пробелом и не должны содержать внутрен-
них пробелов.
   Примеры:

{$А+}
{$r-}
{$М $3000,$А000}
{$i B07 :incfile.pas}

   Несколько директив-переключателей могут быть сгруппированы
в одну. В этом случае они должны отделяться друг от друга за-
пятой; пробелы между ними в этом случае не допускаются.  Нап-
ример:

{$I+,a-,R-}

   В такую директиву может быть  включена  и  параметрическая
директива, но она может быть только одна  и  должна  распола-
гаться последней. Например:

{$I-, I filename.ext}

   Директива компилятора может содержать и комментарий.  Ком-
ментарием является часть директивы, начинающаяся  с  пробела,
следующего за последним аргументом последней директивы.  Нап-
ример:

{$A-,R+ Генерация рекурсивного кода и проверка границ}
{$S $9000,$C000 Область для аппаратного стека}


   12.1. Директивы-переключатели.

   12.1.1. Управление генерацией рекурсивного кода.

   {$A+} или {$A-}

   В режиме {$A+} генерируется нерекурсивный  код,  в  режиме
{$A-} - рекурсивный.
   Рекурсивная процедура или функция обязательно должна  быть
скомпилирована в режиме {$A-}, в противном случае  компилятор
диагностирует ошибку.
   Нерекурсивная процедура или функция будет правильно  ском-
пилирована в любом из режимов - но при  компиляции  в  режиме
{$A-} она будет занимать больше памяти и будет медленнее  ра-
ботать. Поэтому для получения более эффективной программы ре-
комендуем перед началом каждой  рекурсивной  процедуры  (фун-
кции) ставить директиву {$A-}, а сразу после ее конца  -  ди-
рективу {$A+}.
   Действие директивы  {$A...}  начинается  с  процедуры  или
функции, заголовок которой идет после  директивы.  В  случае,
когда процедура или  функция  имеет  forward-описания,  режим
компиляции определяется тем, в области какой директивы  нахо-
дится первое forward-описание.
   По умолчанию компиляция выполняется в режиме {$A+}.


   12.1.2. Управление автоматическим контролем за
           результатом выполнения ввода-вывода.

   {$I+} или {$I-}

   В режиме {$I+}, если при выполнении  какой-либо  процедуры
ввода-вывода возникает ошибка, то выполнение программы  прек-
ращается и на экран выводится сообщение об ошибке периода ис-
полнения.
   В режиме {$I-} в такой ситуации управление возвращается  в
Паскаль-программу. Как закончилась  операция  ввода-вывода  ,
программа может узнать с помощью ф.IOResult.  Результат  фун-
кции IOResult есть один из номеров сообщений об ошибке  пери-
ода исполнения (см. приложение Б).
   Ошибки, связанные с неправильным обращением  к  процедурам
ввода-вывода всегда  диагностируются  немедленно  и  вызывают
прекращение работы программы.
   Компиляция отдельных вызовов процедур ввода-вывода в режи-
ме {$I-} с последующей обработкой их результата  -  легальный
метод в языке EP для  обнаружения  таких  ситуаций,  как  от-
сутствие требуемого файла на диске, нехватка места для записи
нового файла и т.д. .
   Напомним, что физические ошибки при работе с дисками  сис-
темой EP вообще не обрабатываются - поскольку CP/M  не  пред-
ставляет  такой  возможности.  При  возникновении  физической
ошибки всегда происходит рестарт ОС.
   По умолчанию компиляция выполняется в режиме {$I-}.



   12.1.3. Управление контролем за значениями типа
           "отрезок" и индексами массивов.

   {$R+} или {$R-}

   Если фрагмент программы скомпилирован в режиме {$R+}, то в
нем:

   всякий раз, когда переменной типа "отрезок"  присваивается
значение, выполняется  проверка,  попадает  ли  присваиваемое
значение в требуемый диапазон. Если не попадает, то  выполне-
ние программы прекращается и диагностируется ошибка.

   всякий раз, когда передается  по  значению  параметр  типа
"отрезок", выполняется проверка, попадает ли значение  факти-
ческого параметра в требуемый диапазон. Если не попадает,  то
выполнение программы прекращается и диагностируется ошибка.

   всякий раз, когда производится индексирование массива, вы-
полняется проверка, попадает ли значение индексного выражения
в требуемый диапазон. Если не попадает, то  выполнение  прог-
раммы прекращается и диагностируется ошибка.

   Если фрагмент программы скомпилирован в режиме {$R-}, то в
нем никакая из этих проверок не выполняется. В  случае,  если
какое-либо значение выйдет за пределы допустимого  диапазона,
результаты работы программы могут оказаться  непредсказуемыми
(особенно при индексации массивов).
   Обращаем ваше внимание на то, что проверка  принадлежности
значения отрезку выполняется  только  в  момент  присваивания
(или другого использования) готового значения; в процессе вы-
числения выражения никаких  проверок  не  производится.  Так,
например, при выполнении следующего фрагмента никаких  ошибок
не возникнет:

var a,b,c,d:1...10;
....
a:=9; b:=9; c:=3; d:=(a+b)/c;

   Программа ,скомпилированная в режиме {$R+} , более  надеж-
на, но занимает больше места и медленнее выполняется.
   В тех случаях, когда вы используете  специальные  средства
EP,  компиляция  в  режиме  {$R-}  может  оказаться  для  вас
единственной альтернативой. Например, в следующей  процедуре,
которая заполняет произвольное поле нулями:

procedure FillZero (length:word; var field);
   var i:word;
         f:array [0...0] of byte absolute field;
{Ну, а какой другой тип индекса здесь}
{написать ? 0...10? 1..1000? А чем они лучше}
begin
{$R-} for i:=0 to length-1 do f[i]:=0; {$R+}
end;

   По умолчанию компиляция выполняется в режиме {$R-}.


   12.1.4. Управление контролем за строковыми
           параметрами, передаваемыми по ссылке.

   {$V+} или {$V-}

   В режиме {$V+} выполняется жесткий контроль за  строковыми
параметрами, передаваемыми по ссылке: тип переменной - факти-
ческого параметра должен быть идентичен типу формального  па-
раметра (т.е. их длины должны совпадать).
   В режиме {$V-} , если формальный параметр является строко-
вым, то фактическим параметром может быть любая строковая пе-
ременная. При этом контроль  за  тем,  чтобы  не  происходило
присваиваний за пределами фактического  параметра,  находится
целиком на совести программы.
   Режим компиляции {$V..} не влияет ни на размер, ни на ско-
рость выполнения скомпилированной  программы;  он  определяет
лишь то, будет или нет диагностироваться ошибка в период ком-
пиляции.
   По умолчанию компиляция выполняется  в  режиме  {$V-}.


   12.2. Параметрические директивы.

   12.2.1. Включение файла с исходным текстом.

   {$I имя файла}

   При появлении этой директивы чтение исходного текста прог-
раммы из памяти приостанавливается и начинается чтение исход-
ного текста из указанного в директиве файла. После того,  как
будет достигнут конец файла, возобновляется чтение  исходного
текста из памяти. Мы называем файлы, включаемые по  директиве
{$I имя файла} , include-файлами.
   Include-файл сам может содержать директиву {$I имя файла},
и т.д. Максимальная глубина вложенности include-файлов  огра-
ничивается размером имеющейся в распоряжении компилятора  па-
мяти. Поскольку память используется компилятором и для других
целей, точную цифру назвать невозможно  (свободно  можно  ис-
пользовать глубину до 5).
   Имя файла записывается по общим правилам записи имен  фай-
лов в EP (см. раздел 5 главы 10). В частности, в имени  файла
вы можете указать дисковод и номер  пользователя.  Однако  мы
рекомендуем по возможности не делать этого; если вы  вставите
в директиву {$I b:uncf.pas}, то вы сможете выполнить компиля-
цию только в том случае, когда диск с include-файлом находит-
ся на дисководе B:. Если обозначение  дисковода  опущено,  то
include-файл ищется на текущем  дисководе  (на  том,  который
указан в основном меню).
   Если в имени файла опущено расширение вместе с предшеству-
ющей ему точкой, то подразумевается расширение ".PAS". В  том
случае, если вам нужно указать пустое  расширение  (состоящее
из одних пробелов), следует после имени поставить точку. Нап-
ример: name понимается как name.pas, а name. - как name.


   12.2.2. Описание области памяти, отводимой
           под скомпилированную программу.

   {$M bbbb,eeee}

   Эта директива определяет  область  памяти,  отводимой  для
размещения скомпилированной программы и ее данных. Здесь bbbb
и eeee есть соответственно начальный и конечный адреса  отво-
димой памяти (при этом байт с адресом bbbb  есть  первый  ис-
пользуемый байт, а байт с адресом eeee -  первый  неиспользу-
емый байт). В этой директиве bbbb и eeee могут быть  десятич-
ными или шестнадцатеричными числами - но не могут  быть  кон-
стантными выражениями.
   Если директива {$M..} не задана,  то  программе  отводится
вся свободная память - от конца библиотеки  процедур  времени
исполнения (при компиляции на диск) или  от  конца  исходного
текста программы (при компиляции в  память)  до  начала  CP/M
(подробно распределение памяти при работе EP описано в  главе
13). Начальный и конечный адреса, используемые по  умолчанию,
будем далее обозначать MemStart и MemEnd.
   Заданные в директиве адреса должны удовлетворять соотноше-
нию:

MemStart<= bbbbb < eeee <=  MemEnd

Если какой-либо из адресов, указанных в директиве,  не  удов-
летворяет этому соотношению, то он игнорируеися.
   Один из адресов в директиве может быть опущен. Если опущен
eeee, то может быть опущена и запятая; если опущен  bbbb,  то
запятая должна присутствовать.
   Директива {$M..} может располагаться в любом  месте  прог-
раммы; в программе может  присутствовать  несколько  директив
{$M..}. В этом случае будут использованы значения из  послед-
ней директивы, в которой соответствующий аргумент не опущен.
   Директива {$M..} может быть  использована,  например,  для
резервирования места для размещения фрагмента на ассемблере.
   Примеры:

{$M $5000,$9000}
{$M $3000 задан только начальный адрес}
{$M,$A000 задан только конечный адрес}



   12.2.3. Описание области памяти, отводимой
           под аппаратный стек.

   {$S ssss, eeee}

   Эта директива определяет область памяти, отводимую под ап-
паратный стек. Здесь ssss есть размер, а eeee - верхняя  гра-
ница стека (стек будет занимать байты с адресами от eeee-ssss
до eeee-1). В этой директиве ssss и eeee могут быть  десятич-
ными или шестнадцатеричными числами - но не могут  быть  кон-
стантными выражениями.
   Если директива {$S..} опущена, то стек будет занимать $200
байт - если в программе нет рекурсивных процедур  и  функций,
или $400 байт - если они есть; при этом стек будет расположен
в верхнем конце отводимой  под  размещение  программы  памяти
(верхняя его граница  будет  MemEnd  или  eeee  из  директивы
{$M..}).
   Любой из аргументов директивы может быть опущен; если опу-
щен eeee, то может быть опущена и запятая,; если опущен ssss,
то запятая должна присутствовать.
   В случае, если опущен конечный адрес стека eeee, стек рас-
полагается там же, где и обычно - в конце отведенной под раз-
мещение программы памяти. Если конечный адрес  стека  указан,
то компилятор не резервирует память под стек - вы должны  по-
заботиться об этом сами. Компилятор в этом случае обеспечива-
ет только занесение указанного вами адреса в регистр SP  про-
цессора в начале выполнения программы.
   Аппаратный стек используется Паскаль-программой для следу-
ющих целей (более подробное описание см. в главе 13):

   сохранение адреса возврата при вызове процедуры  или  фун-
кции;
   передача параметров процедуре или функции;
   хранение промежуточных результатов при вычислении  выраже-
ний;
   сохранение локальных  переменных  рекурсивных  процедур  и
функций;
   использование для внутренних нужд процедур библиотеки вре-
мени исполнения.

   Если размер стека, выбираемый компилятором  по  умолчанию,
недостаточен для выполнения вашей программы, вы  должны  сами
установить требуемый размер с помощью директивы {$S..}.
   Директива {$S..} может располагаться в любом  месте  прог-
раммы; в программе может  присутствовать  несколько  директив
{$S..}. В этом случае будут использованы значения из  послед-
ней директивы, в которой соответствующий аргумент не опущен.
   Примеры:

{$S $1000,$C000}
{$S $600 задан только размер стека}
{$S,$A000 задано только положение стека}
{$S 100, $4000} Ошибка: между аргументами не должно быть про-
                белов; второй аргумент  будет  воспринят  как
                комментарий






   ГЛАВА 13

   ВНУТРЕННЕЕ УСТРОЙСТВО


   В этой главе описываются некоторые детали реализации  сис-
темы EP, которые могут  оказаться  полезными  при  разработке
программ  системного  характера,  использующих  специфические
особенности устройства компьютера и требующих  вставки  фраг-
ментов на ассемблере.


   13.1. Распределение памяти.

   Распределение памяти в период работы компилятора:

---------------------- FFFFh
Память экрана,
регистры,
CP/M
---------------------- CC06h
Стек
----------------------
Таблицы компилятора
----------------------
Исходный текст
Паскаль-программы
----------------------
Редактор и компилятор
----------------------
Библиотека процедур
периода исполнения
---------------------  0100h
Системная страница
---------------------  0000h


   Распределение памяти в период исполнения программы,  ском-
пилированной в память:

-------------------------       FFFFh
Память экрана,
регистры,
CP/M
-------------------------       CC06    <-- MemEnd
Возможная
неиспользуемая
область
-------------------------       <-- Конечный адрес из
Стек                                директивы {$M..}
-------------------------
Куча
-------------------------
Переменные
Паскаль-программы
-------------------------
Код Паскаль-программы
-------------------------       <-- Начальный адрес из
Возможная неиспользуемая            директивы {$M..}
область
-------------------------               <--MemStart
Исходный текст
Паскаль-программы
-------------------------
Редактор-компилятор
-------------------------
Библиотека процедур
периода исполнения
-------------------------       0100h
Системная страница
-------------------------       0000


   Если в программе была директива {$S...} и в ней был указан
адрес для размещения стека, то область "стек" компилятором не
выделяется (программа должна сама позаботиться о резервирова-
нии памяти по указанному адресу).
   Возможные неиспользуемые области возникают  только  в  том
случае, когда в программе имеется директива {$M...} и  в  ней
указан соответствующий адрес.
   Распределение памяти в период исполнения  Паскаль-програм-
мы, скомпилированной на диск:

-------------------------       FFFFh
Память экрана,
регистры,
CP/M
-------------------------       CC06    <-- MemEnd
Возможная
неиспользуемая
область
-------------------------       <-- Конечный адрес из
Стек                                директивы {$M..}
-------------------------
Куча
-------------------------
Переменные
Паскаль-программы
-------------------------
Код Паскаль-программы
-------------------------       <-- Начальный адрес из
Возможная неиспользуемая            директивы {$M..}
область
-------------------------               <--MemStart
Библиотека процедур
периода исполнения
-------------------------       0100h
Системная страница
-------------------------       0000


   Как и при выполнении программы, скомпилированной в память,
область для стека при наличии директивы {$S..} с адресом  для
размещения стека не выделяется,  и  возможные  неиспользуемые
области возникают лишь при наличии директивы {$M..}.



   13.2. Внутренние форматы данных.

   13.2.1 Целые типы.

   Формат для представления значений целых типов (в  частнос-
ти, отрезков целых типов) выбирается в зависимости от  нижней
и верхней границы множества значений:

   если обе границы лежат в интервале  от  -128  до  127,  то
представление 1-байтовое со знаком;

   если обе границы лежат в интервале от 0 до 255,  то  пред-
ставление 1-байтовое без знака;

   если обе границы лежат в интервале от -32768 до 32767,  то
представление 2-байтовое со знаком;

   если обе границы лежат в  интервале  от  0  до  65535,  то
представление 2-байтовое без знака;

   иначе представление 4-байтовое со знаком


   Во всех случаях представление отрицательных чисел - в  до-
полнительном коде.


   13.2.2. Тип Char.

   Значение типа char и его отрезков представляются как  без-
знаковый байт.


   13.2.3. Тип Boolean.

   Значения типа boolean занимают один байт. Значение 0 соот-
ветствует False, значение 1 - True; остальные возможные  зна-
чения байта не используются. Если вы  занесете  в  переменную
типа boolean значение, отличное от 0 или 1  (это  можно  сде-
лать, например, использовав ретипирование),  то  в  различных
контекстах оно может быть проинтерпретировано по-разному.


   13.2.4. Перечислимые типы.

   Значения перечислимого типа хранятся как беззнаковый байт,
если количество значений не превосходит 255, и как  беззнако-
вое слово в противном случае.
   Значения отрезков перечислимого типа хранятся как  беззна-
ковый байт, если верхняя граница отрезка имеет порядковый но-
мер (значение функции Ord) <= 255, и как беззнаковое слово  в
противном случае.


   13.2.5. Тип Real.

   Значение типа Real занимает 6 байт  (48  бит).  Порядок  e
расположен в первом байте, остальные 5 байт занимает мантисса
f , причем, содержащий наименее значашие биты мантиссы,  идет
первым. В старшем бите старшего байта мантиссы находится знак
s. Значение числа определяется по формуле:


    s          (e-129)
(-1)  * 1.f * 2         , если e<>0
        0.0             , если e=0

   Нуль всегда имеет нулевой порядок, мантиссу и знак.  Отри-
цательные значения мантиссы представляются в прямом коде.
   Если при выполнении арифметической операции происходит ис-
чезновение порядка (получается слишком маленькое  число),  то
результат есть 0.0 ; если возникает переполнение  (получается
слишком большое число), то возникает ошибка периода  исполне-
ния.


   13.2.6. Указательные типы.

   Значение любого указательного типа есть слово,  содержащее
адрес памяти, nil есть слово с нулевым значением.


   13.2.7. Строковые типы.

   Число байтов, занимаемых значением  string  [длина],  есть
длина+1. Первый байт содержит текущую длину строки, остальные
байты содержат литеры, образующие строку. Содержимое  байтов,
лежащих за пределами текущей длины строки, не определено.


   13.2.8. Типы множеств.

   Множество представляется как массив битов, в котором  каж-
дый из битов индицирует, принадлежит ли соответствующий  эле-
мент множеству или нет. Максимальное количество  элементов  в
множестве есть 256, поэтому множества никогда не занимают бо-
лее 32 байт. Количество байт, занимаемых множеством,  опреде-
ляется по формуле:

Size=(Max div 8)-(Min div 8) +1

где Min и Max есть соответственно нижняя  и  верхняя  границы
базового типа множества. Смещение байта, содержащего бит эле-
мента с порядковым номером E,  относительно  начала  значения
есть:

   ByteNumber = (E div 8)-(Min div 8)

а номер бита в этом байте:

   BitNumber = E mod 8

(наименее значащий бит имеет номер 0, наиболее значащий бит -
номер 7).



   13.2.9. Типы массивов.

   Значение типа массива хранится в  памяти  как  непрерывная
последовательность значений типа компоненты  массива.  Компо-
нента массива с наименьшим значением индекса хранится первой.
Многомерный массив хранится как массив массивов.


   13.2.10. Типы записей.

   Значение типа массива хранится в  памяти  как  непрерывная
последовательность значений типа компонент. Первая компонента
записи расположена в памяти первой. Если запись содержит  ва-
риантную часть, то каждый вариант начинается с одного и  того
же адреса памяти.


   13.2.11. Файловые типы.

   Переменная файлового типа занимает всегда 183 байта.  Пер-
вые 4 байта имеют фиксированный смысл; использование  осталь-
ных байтов зависит от того, является файл дисковым или файлом
на устройстве.
   Содержимое первых 4-х байтов:

 00h -----------             Возможности работы с файлом
       Handle
 01h -----------
       Status               Текущий статус файла
 02h -------------------
           Reclen           Длина записи
 04h -------------------

   Байт Handle определяет устройство, на  котором  расположен
файл, - и, тем самым, возможности работы с ним. Он может  со-
держать одно из следующих значений:

$B0 - файл на диске
$B1 - файл на консоли
$B2 - файл на клавиатуре
$B3 - файл на принтере
$B4 - файл на дополнительном устройстве ввода-вывода
$B5 - файл на устройстве NULL

   Значение байту Handle присваивается при выполнении  проце-
дуры Assign. Любое отличное от перечисленных  значение  байта
Handle означает, что файловая переменная не  была  обработана
процедурой Assign; в этом случае при обращении к любой проце-
дуре ввода-вывода (кроме Assign) возникает ошибка периода ис-
полнения.
   Байт Status содержит  набор  флагов,  описывающих  текущее
состояние файла. Значение битов байта Status:

бит 0: = 1 - достигнут конец файла,
       = 0 - не достигнут

бит 1: = 1 - файл был открыт процедурой Rewrite или Append,
       = 0 - файл был открыт процедурой Reset

бит 2: = 1 - к этой файловой переменной запрещено применение
             п.Rewrite
       = 0 - разрешено

бит 3: = 1 - к этой файловой переменной запрещено применение
             п.Append
       = 0 - разрешено

бит 4: = 1 - к этой файловой переменной запрещено применение
             п.Reset
       = 0 - разрешено

бит 5: = 1 - файловая переменная типа Text
       = 0 - типизированная или нетипизированная

бит 6: = 1 - типизированная файловая переменная
       = 0 - нетипизированная или Text

бит 7: = 1 - файл открыт
       = 0 - закрыт

(Биты 2-4 используются только в предопределенных файловых пе-
ременных. Биты 5 и 6 не могут одновременно принимать значение
1. Для типизированных файлов: бит 1 при открытии файла с  по-
мощью п.Reset устанавливается в 0, а при изменении числа  за-
писей в файле - в 1; здесь он используется как признак  необ-
ходимости перезаписи числа записей при закрытии файла  -  это
имеет смысл только для дисковых файлов).
   Слово Reclen содержит длину записи файла. Для типизирован-
ных файлов это длина компоненты файла;  для  нетипизированных
файлов это значение второго параметра  при  вызове  процедуры
Reset или Rewrite (128, если второй параметр был опущен); для
Text это 1.
   Содержимое остальных полей файловой  переменной  в  случае
дискового файла:

04h -------------------
     Size (5 байт)              Размер файла
09h -----------------------
     FCB (37 байт)              FCB в формате CP/M
2Eh -----------------------
     User                       Номер пользователя
2Fh ---------
     BlkPos                     Текущая позиция в тек. блоке
30h -----------------------
     BlkNr (4 байта)            Номер текущего блока
34h -----------------------
     FlWrt                      Флаг записи блока
35h -----------------------
     ABuf  (2 байта)            Адрес буфера
37h -----------------------
     Buf  (128 байт)            Буфер
B7h------------------------


   В поле Size хранится размер файла в формате:  первый  байт
содержит количество занятых байтов в  последнем  128-байтовом
блоке +128 (тем самым значение этого байта всегда находится в
интервале от 128 до 255), в следующих 4 байтах хранится коли-
чество  128-байтовых блоков -1 (в формате longint).
   В поле FCB хранится FCB (File Control Block - блок  управ-
ления файлом), используемый при обращении к дисковым функциям
CP/M: он дополнен 0-м байтом (для того, чтобы  последнее  по-
ле FCB можно было трактовать как longint).
   В поле User хранится номер пользователя, к которому  отно-
сится файл.
   В полях BlkPos и BlkNr хранятся позиции в текущем 128-бай-
товом блоке и номер текущего блока. При этом если блок  нахо-
дится в буфере, значение BlkPos  задает  истинную  позицию  в
блоке (оно меньше 128) и значение BlkNr есть  истинный  номер
блока; если текущий блок в  буфер  еще  не  считан,  значение
BlkPos есть истинная позиция +128,  а  значение  BlkNr  на  1
меньше истинного номера блока.
   В поле FlWrt находится признак необходимости записи  теку-
щего блока на диск. Если значение этого байта есть 0, то  те-
кущий блок не изменялся, и записывать его на диск  не  нужно;
если же его значение есть 1, то в текущий блок вносились  из-
менения и при необходимости поместить в буфер новый блок  или
при закрытии файла текущий блок должен быть записан на диск.
   В поле ABuf находится адрес 128-байтового буфера,  исполь-
зуемого при обмене с  диском.  При  работе  Паскаль-программы
этот буфер всегда находится в следующем поле; поле ABuf  вве-
дено из-за того, что в период работы редактора или компилято-
ра буфер может располагаться в другом месте.
   Поле Buf есть буфер для обмена с диском. Если файл  открыт
и значение поля BlkPos меньше 128, то в буфере находится  те-
кущий блок; иначе содержимое буфера не определено.
   Для выходных файлов на всех устройствах и для входных фай-
лов на устройстве NUL:  в  файловой  переменной  используются
только первые 4 байта (поля Handle, Stat, Reclen).
   Для входных файлов на устройствах KBD: и AUX:  в  файловой
переменной используются дополнительно 2 байта;

04h ------------
      FlBuf             Флаг наличия символа в буфере
05h ------------
      Buf               Буфер
06h ------------


   В поле FlBuf содержится 0, если буфер (поле Buf)  пуст,  и
1, если в буфере лежит введенный с устройства байт.
   Для входных файлов на устройстве CON: в файловой  перемен-
ной используется дополнительно 132 байта:

04h ------------
     BufPos                     Текущая позиция в буфере
05h ------------
     BufSize                    Размер буфера
06h ------------
     CurSize                    Текущее количество байтов
07h ----------------            в буфере
     Buf (129 байт)             Буфер
88h ----------------


   Поля BufSize, CurSize и Buf составляют буфер консоли,  ко-
торый требутся функцией 10 CP/M (ввод с консоли с  редактиро-
ванием). Поле BufSize содержит число 127 - физический  размер
буфера; в поле CurSize заносится количество символов в  буфе-
ре, введенных в результате очередного ввода строки с консоли;
введенная строка в поле Buf всегда дополняется парой символов
Cr, Lf - для того, чтобы такое добавление всегда было возмож-
но, Buf состоит из 129 байт , а не 127.
   Поле CurPos содержит текущую позицию в буфере - количество
символов, уже выбранных из  буфера  Паскаль-программой.  Если
CurPos > CurSize , то при запросе Паскаль-программой  очеред-
ного байта должен быть выполнен ввод следующей строки с  кон-
соли.
   При вводе с устройства CON: используется функция 10 BDOS -
ввод с консоли с редактированием; вы имеете все  предоставля-
емые CP/M  возможности  редактирования  строки.  Однако,  эта
функция имеет одну неприятную особенность: она обнуляет стар-
ший бит вводимого символа, и из-за этого  все  русские  буквы
превращаются в латинские.
   Независимо от того, сколько байтов используется в файловой
переменной в конкретном случае, она всегда занимает 183  бай-
та: ведь одна и та же файловая переменная может быть  исполь-
зована для доступа к различным внешним файлам.


   13.3. Соглашение о связях.

   13.3.1. Передача параметров.

   Параметры для процедур и функций передаются через стек или
на регистрах. На регистрах может быть передан только  послед-
ний из параметров и только в том случае, когда его формат до-
пускает передачу на регистрах.
   В случае параметров, передаваемых по ссылке  (var-парамет-
ров), передается 2-байтовый адрес переменной  -  фактического
параметра.
   В случае параметров, передаваемых  по  значению,передается
значение выражения - фактического параметра  (даже  если  оно
очень длинное; поэтому по возможности передавайте  параметры,
которые занимают много памяти, по ссылке).
   Последний параметр передается на регистрах в одном из сле-
дующих случаев:

   если параметр не является строкой и занимает 1 байт, то он
передается в A-регистре; при этом отнюдь не обязательно, что-
бы такой параметр имел упорядоченный тип; например, последний
параметр типа array [1...1] of byte будет передан в  A-регис-
тре;

   если параметр не является строкой и занимает 2  байта,  то
он передается в HL-регистрах (в частности, параметр,  переда-
ваемый по ссылке, есть 2-байтовый адрес; если  этот  параметр
является последним, то он будет передан в HL-регистрах);  при
этом отнюдь не обязательно, чтобы такой параметр имел  упоря-
доченный  тип:  например,  последний  параметр  типа   record
a,b:byte end будет передан на HL-регистрах.

   Все остальные параметры передаются через стек.
   Фактические параметры, перечисленные  в  вызове  процедуры
или функции, вычисляются слева направо и в  этом  же  порядке
заносятся в стек (последний параметр, возможно, останется  на
регистрах). После этого выполняется команда CALL. Таким обра-
зом, при входе в процедуру (функцию) в  стеке  находятся  (из
глубины наружу): первый параметр,..., предпоследний параметр,
последний параметр (если он не передается на регистрах),  ад-
рес возврата.
   Формат заносимых в стек параметров:

   если параметр занимает 1 байт и не является строкой, то он
занимае в стеке 2 байта (параметр формируется в A-регистре  и
заносится в стек командой PUSH PSW);

   если параметр занимает 2 байта и не является  строкой,  то
он занимает в стеке 2 байта (параметр  формируется  в  HL-ре-
гистрах и заносится в стек командой PUSH H);

   параметры-множества заносятся в стек в распакованном  виде
и занимаю там 32 байта (это связано с тем , что тип множества
передаваемого по значению, должен быть только совместим отно-
сительно присваивания с типом формального  параметра  -  а  в
этом случае они могут иметь различные длины);

   параметры-строки занимают в стеке "текущая  длина"+1  байт
(1 байт для  хранения  длины);  в  частности,  пустая  строка
(строка с текущей длиной, равной 0) займет в стеке 1 байт;

   параметры всех остальных  типов  занимают  в  стеке  ровно
столько байт, сколько требуется  для  представления  значения
этого типа в памяти, и заносятся в стек в том же  формате,  в
котором они представляются в памяти.

   Вызываемая процедура обязана удалить все переданные ей па-
раметры из стека.
   В начале кода каждой процедуры помещается  код  извлечения
параметров из стека и размещения их  в  локальных  переменных
процедуры, отведенных для параметров. Этот  код  генерируется
компилятором при появлении открывающего тело процедуры  слова
begin - и поэтому, в частности, окажется всегда перед  кодом,
порожденным оператором inline. Поэтому, даже  если  процедура
состоит из единственного оператора inline , у вас нет необхо-
димости вручную выполнять извлечение параметров из стека.


   13.3.2. Возврат результата функции.

   Результат функции возвращается либо в стеке, либо  на  ре-
гистрах - в зависимости от типа результата.  Способ  возврата
результата и формат его представления определяются следующими
правилами:

   результат, занимающий 1 байт,  возвращается  в  A-регистре
(если он не является строкой);

   результат, занимающий 2 байта, возвращается в HL-регистрах
(если он не является строкой);

   результаты всех остальных типов возвращаются в стеке  -  в
том же формате , в каком передаются параметры соответствующих
типов.

   Напомним, что в EP тип результата может быть любым простым
типом, строковым типом или типом множества. Последнее являет-
ся расширением по сравнению с Pascal и Turbo Pascal.  Резуль-
тат типа множества возвращается в стеке в распакованном виде.
   Код для занесения результата функции в  стек  (или  выбора
его на регистры) генерируется компилятором при появлении  за-
вершающего тело процедуры слова end. Генерацию этого кода от-
менить или изменить нельзя; поэтому если  вы  формируете  ре-
зультат нестандартным способом внутри  оператора  inline,  вы
должны в нем же выполнить оператор RET (при этом  стандартный
код выхода из функции все равно будет сгенерирован, хотя и не
будет исполняться).



   13.3.3. Сохранение регистров.

   Процедуры и функции не обязаны сохранять входные  значения
каких бы то ни было регистров.


   13.4. Управление кучей.

   Куча (область памяти, в которой создаются динамические пе-
ременные) всегда располагается между кодом  Паскаль-программы
и ее данными. Под кучу отводится вся  не  использованная  для
других нужд память.
   Дисциплина выделения памяти в куче под динамические  пере-
менные - стековая, среди процедур работы с кучей  отсутствует
процедура Dispose - вместо нее предлагается использовать про-
цедуры Mark и Relese.
   Структура кучи следующая:

--------------------------      <-HeapEnd
   Свободная часть кучи
--------------------------      <-HeapPtr
   Занятая часть кучи
--------------------------      <-HeapOrg


   NeapOrg, HeapPtr, HeapEnd - это доступные пользователю пе-
ременные. Все они имеют значения типа word и содержат:

HeapOrg - адрес первого байта кучи
HeapPtr - адрес первого свободного байта в куче
HeapEnd - адрес первого байта , не входящего в кучу

   Вы можете свободно использовать в вашей программе значения
этих переменных - и даже изменять их значения. Это может быть
использовано вами для организации специальных режимов  работы
с кучей (но в таком случае  ответственность  за  корректность
выполняемых действий  - на вашей совести).


   13.5. Прямые обращения к памяти и портам.

   В EP возможно прямое обращение к ячейкам памяти. Для этого
служит предопределенный массив Mem. Этот массив описан как:

array [0...$FFFF] of byte absolute 0

   Этот массив уместно использовать для обращений к  перемен-
ным ОС. Если тип переменной отличен от byte, то можно  приме-
нить преобразователь типа переменной. Например:

ac:= Mem [word (Mem [$F705])];

(по адресу $F705 находится слово, содержащее адрес  кусора  в
памяти экрана. Этот оператор присваивает переменной  ac  (тип
byte) ASCII- код символа, находящегося под кусором).
   Альтернативой использование массива Mem является использо-
вание absolute-переменных.
   В EP имеется также возможность непосредственного доступа к
портам ввода-вывода. Для этого может быть использован  массив
Port. Вообще , микропроцессор 8080 обеспечивает доступ к  пе-
риферийным устройствам посредством портов ввода-вывода, обра-
щения к которым выполняются с помощью команд IN и OUT.  Но  в
Корвете порты ввода-вывода исполнены в виде ячеек обычной па-
мяти, и обращение к ним может осуществляться с помощью  обыч-
ных команд записи/чтения в память. Поэтому массив Port описан
как:

array [0..255] of byte absolute $FB00

что соответствует странице с портами ввода-вывода в  конфигу-
рации CP/M. На Корвете  для  работы  с  портами  ввода-вывода
вполне достаточно одного массива Mem; массив Port введен  для
совместимости с версиями Turbo Pascal для МП Z80.


   13.6. Процедуры выхода.

   Использование процедур выхода дает возможность вашей прог-
рамме выполнить специальные действия в процессе  ее  заверше-
ния; типичным примером таких действий является  закрытие  от-
крытых программой файлов.
   Вы можете  задать  несколько  процедур  выхода;  правильно
оформленные процедуры выхода образуют цепочку.  Процедуры  из
цепочки процедур выхода выполняются в порядке,  обратном  по-
рядку их задания.
   Цепочка процедур выхода выполняется при  любом  завершении
программы: нормальном (по достижении конца главной  программы
или в результате выполнения п.Halt), прерывании с  консоли  с
помощью /\C, в результате возникновения ошибки периода испол-
нения.
   Для подключения очередной процедуры к цепочке процедур вы-
хода нужно выполнить следующие действия:

   запомнить текущее содержимое  предопределенной  переменной
ExitProc (эта переменная имеет тип Pointer);
   присвоить переменной ExitProc адрес  входа  в  добавляемую
процедуру выхода.

   Процедура выхода не должна иметь параметров. В теле проце-
дуры  выхода  обязательно  должны  присутствовать  операторы,
присваивающие переменной ExitProc запомненное  значение.  Это
требуется потому, что блок выполнения процедур выхода  просто
вызывает процедуру, адрес входа в которую находится  в  пере-
менной ExitProc; после ее завершения снова вызывается  проце-
дура по адресу из ExitProc и  т.д.  Изначально  в  переменной
ExitProc находится адрес  стандартной  процедуры  завершения;
эта процедура не возвращает управление в блок выполнения про-
цедур выхода (вместо этого она возвращает управление  системе
EP или ОС) - поэтому на стандартной процедуре завершения  це-
почка процедур выхода оканчивается. Если же вы не восстанови-
те запомненный адрес, то возникнет бесконечный цикл.
   Если в период выполнения одной из процедур выхода  возник-
нет ошибка времени исполнения, то (в  соответствии  с  общими
правилами) начнется выполнение цепочки процедур  выхода  -  с
той процедуры, адрес которой находился в этот момент в  пере-
менной ExitProc. Поэтому -  чтобы  не  возникло  бесконечного
цикла - восстанавливайте содержимое переменной ExitProc в на-
чале процедуры выхода.
   В следующем примере определяются две процедуры выхода, они
обеспечивают закрытие файлов F1 и F2.

var F1,F2 : file;
   SaveExitProc_1, SaveExitProc_2 : pointer;

....

procedure MyExitProc_1;
   begin ExitProc:= SaveExitProc_1; Close(F1); end;

procedure MyExitProc_2;
   begin ExitProc:= SaveExitProc_2; Close(F2); end;
....

begin
   Assign(F1,'xxx.xxx'); Reset(F1);
   SaveExitProc_1:=ExitProc; ExitProc:=@MyExitProc_1;
  {теперь, как бы не завершилась программа,}
  {файл F1 будет закрыт п.MyExitProc_1}

   Assign(F2,'yyy.yyy'); Reset(F2);
   SaveExitProc_2:=ExitProc; ExitProc:=@MyExitProc_2;
  {теперь, как бы не завершилась программа,}
  {файл F2 будет закрыт п.MyExitProc_2}
....

end.

   Еще раз обращаем ваше внимание на то, что процедуры выхода
выполняются в порядке, обратном порядку их объявления. В при-
веденном примере процедура MyExitProc_1 объявлена раньше , но
будет выполнена позже процедуры MyExitProc_2
   В любой процедуре выхода доступна информация о том, в  ка-
кой точке и по какой причине завершилось выполнение  програм-
мы. Эта информация содержится в предопределенных переменных:

   ErrCode : byte - содержит признак способа завершения прог-
раммы:
0 - если выполнение завершилось нормально;
код ошибки - если выполнение завершилось в результате возник-
             новения ошибки;
$FF - если выполнение завершилось по нажатию /\C

   ErrPC : word - адрес текущей программы в Паскаль-программе
(команды, которая была бы выполнена, если бы выполнение  Пас-
каль-программы не было бы прекращено).

   Кроме того, предопределенная переменная FlErrMsg (тип  by-
te) позволяет управлять режимом выдачи  сообщения  об  ошибке
при завершении программы. Нормально, при возникновении ошибки
времени исполнения или при нажатии /\C на экран выдается  со-
общение; это сообщение выдается перед началом выполнения  це-
почки процедур выхода. Если кака-либо процедура  выхода  пре-
дусматривает свой способ обработки ошибок периода исполнения,
то это сообщение может  оказаться  лишним.  Для  того,  чтобы
стандартное  сообщение  не  выдавалось,  следует   переменной
FlErrMsg присвоить значение 0; для того чтобы сообщение выда-
валось, переменная FlErrMsg должна содержать $FF; любое  дру-
гое значение переменной FlErrMsg недопустимо.
   Реализация процедур выхода требует известной аккуратности,
т.к. ошибки в них могут привести к зацикливанию программы без
выдачи диагностики - и тем самым затруднить отладку.


   13.7. Реализация рекурсивных процедур.

   Реализация рекурсивных процедур в EP имеет некоторые  осо-
бенности, связанные с применяемым методом распределения памя-
ти под локальные переменные.
   Как уже упоминалось, память для локальных переменных  про-
цедур и функций выделяется статически, в период компиляции. В
то же время семантика рекусивных процедур требует  динамичес-
кого выделения памяти для локальных переменных - для  каждого
вызова рекурсивной процедуры (функции) должно  быть  выделено
свое поле для их размещения.
   Этот конфликт разрешается следующим способом.  Память  для
локальных переменных всегда  выделяется  статически,  но  при
входе в рекурсивную процедуру или функцию исходное содержимое
поля локальных переменных копируется в стек, а перед  выходом
из нее восстанавливается. Это приводит к возникновению  огра-
ничения: рекурсивные процедуры и функции не должны иметь  па-
раметров, передаваемых по ссылке (var-параметров).
   Признаком того, что процедуру или функцию нужно компилиро-
вать как рекурсивную, является то, что ее заголовок находится
в области действия директивы  компилятора  {$A-}.  Компилятор
распознает рекурсивные процедуры и функции, и если он обнару-
живает, что какая-либо процедура (функция) фактически являет-
ся рекурсивной, но ее заголовок не находится в  области  дей-
ствия директивы {$A-}, то выдается сообщение об ошибке. Авто-
матически установить  необходимый  режим  компиляции  нельзя,
т.к. факт рекусивности распознается слишком поздно. Чтобы  не
думать каждый раз, вы можете поставить директиву {$A-} в  са-
мом начале вашей программы и  далее  не  отменять  ее.  Такая
программа будет работать правильно - но  выполнение  нерекур-
сивных процедур и функций будет  требовать  наличия  дополни-
тельного свободного места в стеке и будет занимать  несколько
больше времени, чем если бы для каждой процедуры  был  указан
истинный режим ее компиляции.
   Если в вашей программе используются рекурсивные  процедуры
или функции, то стек должен иметь достаточный размер для раз-
мещения в нем сохраняемых локальных переменных. В период ком-
пиляции требуемый размер стека определить невозможно; поэтому
компилятор при наличии рекусивных процедур или функций только
увеличивает размер стека по умолчанию до 1 К (при  отсутствии
рекурсивных процедур или функций размер  стека  по  умолчанию
есть 0.5К). Если, по вашему мнению, требуется  другой  размер
стека, вы должны изменить его  вручную  с  помощью  директивы
компилятора {$S..}. Если у вас возникает подозрение, что ваша
программа работает неправильно из-за  недостаточного  размера
стека, вы можете проверить это с помощью процедуры CheckStack
Процедура CheckStack имеет  единственный  параметр  -  слово,
указывающее требуемый в данной точке программы размер  стека.
Если размер свободного пространства в стеке при вызове проце-
дуры CheckStack превосходит величину, заданную параметром, то
процедура завершает работу нормально; иначе возникает  ошибка
периода   исполнения.   Условие,    проверяемое    процедурой
CheckStack, есть:

   x-y+p=>SP    ,где

x - верхняя граница стека из директивы {$S..}  (MemEnd,  если
    не задано);
y - размер стека из директивы {$S..} (если не задан, то  $200
    при отсутствии рекурсивных процедур и $400 при  их  нали-
    чии);
p = параметр процедуры CheckStack

   Автоматической проверки заполнения стека не  производится;
если стек переполнится , то это будет  иметь  непредсказуемые
последствия.
   Кроме стека, при входе в рекурсивные процедуры  и  функции
неявно используется куча; содержимое поля локальных  перемен-
ных сначала заносится в кучу, затем из стека извлекаются  па-
раметры, и потом содержимое поля локальных переменных копиры-
ется из кучи в стек. Поэтому, при наличии в программе  рекур-
сивных процедур или функций, куча (даже если она явно не  ис-
пользуется) должна иметь размер не меньше,  чем  максимальный
размер поля локальных переменных рекурсивной процедуры.


   13.8. Прочие замечания.

   13.8.1. Генерация и оптимизация кода.

   Оптимизация кода подробно описана в главе 6 части 1; здесь
мы только остановимся подробнее на некоторых деталях  техники
программирования, которые могут оказать влияние на  эффектив-
ность вашей программы.
   Процедуры Inc и Dec.
Везде вместо оператора присваивания вида:

   x:=x+c; или x:=x-c;

можно применять вызовы процедур:

   Inc(x,c);
или
   Dec(x,c);

соответственно. Вызовы процедур Inc и Dec компилируются более
эффективно, чем соответствующие операторы присваивания.  Осо-
бенно уместно использовать их внутри опеераторов цикла. Обра-
щаем ваше внимание на то, что c может быть не только констан-
той, но и произвольным выражением целого типа.
   Использование множеств-констант в условных операторах.
Если вам нужно проверить, например, что введенный с клавиату-
ры символ лежит в некотором  множестве  символов,  вы  можете
воспользоваться оператором:

   if c in ['д', 'Д', 'd', 'D'] then ...;

Такой оператор написать проще (и, пожалуй, он выглядит понят-
нее), чем оператор:

if (c='д') or (c='Д') or (c='d') or (c='D') then ..;

Но результат компиляции первого варианта займет больше памяти
и будет выполняться медленнее, чем результат компиляции  вто-
рого варианта. Поэтому в программах , для которых существенны
размер  кода  и  скорость  выполнения,   пользуйтесь   второй
конструкцией.


   13.8.2. Работа с датчиком случайных чисел.

   Какое случайное число будет выдано следующим (и даже какая
последовательность псевдослучайных чисел будет  выдаваться  в
будущем), полностью определяется значением переменной RandSe-
ed (тип real), к которой программа пользователя может  непос-
редственно обращаться. Генератор псевдослучайных чисел  может
быть проинициализирован с помощью п.Randomize или путем  пря-
мого присваивания начального значения переменной RandSeed.
   При  выполнении  п.Randomize  начальное  значение  датчика
псевдослучайных чисел формируется по времени,  прошедшему  от
момента запуска этой процедуры до  ближайшего  прерывания  по
частоте 50 гц - поэтому время выполнения этой процедуры может
доходить до 20 млсек.
   Если требуется, чтобы при повторных выполнениях  программы
генерировалась одна и та же последовательность  псевдослучай-
ных чисел, то следует инициализировать  датчик  путем  непос-
редственного присваивания одного и того же значения  перемен-
ной RandSeed.
   Очередное псевдослучайное число вычисляется по формуле:

rand(i+1)=Frac((rand(i)*133)+0.71093901315)

   Целое псевдослучайное число в диапазоне от 0 до range  по-
лучается из вещественного по формуле:

   int-rand=Trunc(range*rand)


   13.8.3. Вызов функций BDOS и BIOS.

   Ваша программа может вызывать процедуры  BDOS  и  BIOS  ОС
CP/M. Это можно сделать непосредственно с помощью inline-опе-
ратора, но мы рекомендуем использовать стандартные  процедуры
BDOS и BIOS (см. главу 14), поскольку они обеспечивают выпол-
нение ряда дополнительных действий, необходимых  для  коррек-
тного взаимодействия системы EP с ОС CP/M.
   Поскольку интерфейс процедур BDOS и  BIOS  предусматривает
передачу параметров и возврат результатов на регистрах,  вве-
ден специальный предопределенный тип:

type Registers =
   record
         case Boolean of
         True : (F,A,C,B,E,D,L,H : byte );
         False: (PSW, BC, DE, HL : word );
end

   Поля записи соответствуют регистрам МП 8080. Два  варианта
соответствуют возможностям работы с регистрами как с  байтами
и как со словами.
   О том, какие процедуры BDOS и BIOS имеются и  каких  пара-
метров они требуют, вы можете узнать  из  руководства  по  ОС
CP/M.
   Заметим, что библиотека  процедур  периода  исполнения  EP
предоставляет достаточно  возможностей;  рекомендуем  пользо-
ваться процедурами BDOS и BIOS только при  крайней  необходи-
мости.


   13.8.4. Работа с системой прерываний.

   В системе EP не предусмотрено специальных средств для  ре-
ализации процедур обработки прерываний; однако некоторые воз-
можности создания таких процедур  имеются.  Возможно,  значи-
тельную часть процедуры обработки прерывания  придется  напи-
сать с помощью inline-операторов.
   EP использует в своей работе прерывание уровня 4 (прерыва-
ние с частотой 50 гц) , псевдопрерывание уровня 8 (псевдопре-
рывание по вводу символа с клавиатуры).
   Вся работа с системой прерываний в EP выполняется в  соот-
ветствии с правилами, предусмотренными в ОС. Вы  должны  при-
держиваться этих правил. Кроме того, вы должны  помнить,  что
запрещение всех прерываний или маскирование прерывания уровня
4 будет блокировать ввод с клавиатуры (в частности,  в  такой
ситуации вы не сможете прервать выполнение  выполнение  вашей
программы по /\C).
   Процедура обработки прерывания должна удовлетворять следу-
ющим требованиям:

- процедура не должна иметь параметров;
- процедура должна сохранять все регистры (это  нужно  выпол-
нить с помощью inline-операторов);
- поскольку практически все процедуры  и  функции  библиотеки
периода исполнения EP не являются  реентерабельными,  они  не
должны вызываться из процедуры обработки  прерывания;  то  же
относится к процедурам и функциям BDOS и BIOS (они могут  ис-
пользоваться внутри процедуры обработки прерывания  только  в
том случае, если они не используются в остальной части  прог-
раммы);
- процедуры, интерпретирующие операции над  значениями  типов
set, string,longint, real не являются  реентерабельными,  по-
этому операции над этими значениями не должны  использоваться
внутри процедуры обработки прерывания (такие  операции  могут
использоваться в процедуре обработки прерывания только в  том
случае, если они не используются в остальной части  программы
или используются там только в тех интервалах, в которых  пре-
рывания запрещены);
- все локальные  переменные  процедуры  обработки  прерывания
должны быть описаны как типизированные константы (только этим
можно гарантировать то, что память, выделенная для  локальных
переменных, не будет перекрываться с  памятью  для  локальных
переменных какой-либо другой процедуры);

   В следующем примере прерывание уровня 4 (прерывание с час-
тотой 50 гц) используется для вывода в  правый  верхний  угол
экрана мигающей звездочки (идентификаторы iPUSH_H  и  т.д.  -
идентификаторы констант, значения  которых  суть  коды  соот-
ветствующих команд)

var int_4:pointer absolute $F7D0; {здесь BIOS хранит адрес}
                                {процедуры обработки преры-}
                                {вания уровня 4}
save_int_4 : pointer;          {для сохранения адреса входа}
                {в стандартную процедуру обработки прер-я}
screen : array [1..1024] of byte  {память экрана}
                        absolute $FC00;

procedure InterruptProcedure;
   const tick : word =0;
         begin
inline ( iPUSH_H /              {сохранили регистры}
         iPUSH_D /
         iPUSH_B /
         iPUSH_PSW / );

   inc(tick);
   if tick=30 then screen[64]:='*';
   if tick=50 then begin tick:=0;
                         screen[64]:=' '; end;

inline ( iPOP_PSW /
         iPOP_B /
         iPOP_D /
         iLHLD / save_int_4
         iXTHL );
{восстановили регистры, занесли в стек адрес  перехода на}
{стандартную процедуру обработки прерывания - после выхода}
{из нашей процедуры управление будет передано ей}
   end;
...
begin
....
   inline (iDI);
   save_int_4:=int_4;
   int_4:=@InterruptProcedure;
   inline (iEI); {подключили нашу процедуру, здесь * мигает}

   int_4:=save_int_4;  {отключили наШу процедуру}
...
end.



   13.8.5. Подключение фрагментов, написанных на ассемблере.

   В EP не предусмотрено специальной возможности для  подклю-
чения процедур, написанных на ассемблере. Если у вас  возник-
нет такая необходимость, предлагаем вам следующий путь.
   Сделайте в программе на Паскале какую-либо область  памяти
неиспользуемой с помощью директивы {$M..}.
   Отредактируйте связи процедур на ассемблере так, чтобы они
располагались на освобожденных в Паскаль-программе адресах.
   Напишите программу, которая объединит COM-файл с  програм-
мой на Паскале с COM-файлом с программой на ассемблере (такую
программу просто написать на Паскале).
   В программе на Паскале обращения к процедурам на ассембле-
ре выполните с помощью inline-операторов (если таких  обраще-
ний много, сделайте переходную процедуру).
   Пример:

   Пусть в программу на Паскале PasProg  вам  нужно  вставить
две  процедуры  на  ассемблере,  содержащиеся   в   программе
AssProg. Тексты этих программ тогда должны выглядеть так:

; программа на ассемблере
;
.8080
cseg
;
jmp proc1       ;это вектор входа в процедуры
jmp proc2
;
proc1:
........
proc2:
...................
end

{программа на паскале}

{$M $3000}  {для процедур на ассемблере отводится область}
                {от $2800 до $2FFF}
procedure proc1;
   begin
         inline (iCALL / $2800);
   end;

procedure proc2;
   begin
         inline (iCALL / $2803);
   end;
.....................
begin
..... proc1; ...... proc2; .....

end.



   Пусть теперь код скомпилированной программы на ассемблере
(после редактирования связей) находится в файле  ASSPROG.COM,
код скомпилированной программы на Паскале находится  в  файле
PASPROG.COM. Следующая программа объединит эти файлы (она вы-
полняет перенос кода процедур на ассемблере - фрагмента с ад-
ресами от $2800 до $2FFF - из файла ASSPROG.COM в  файл  PAS-
PROG.COM). Напоминаем, что первый байт COM-файла располагает-
ся по адресу $100, и поэтому смещение нужного фрагмента отно-
сительно начала файлов - $2700.

var fpas,fass:file;
   buf:array [0..$7FF] of byte;
   count:word;

begin
   Assign (fpas, 'PASPROG.COM'); Reset (fpas,1);
   Assign (fass, 'ASSPROG.COM'); Reset (fass,1);
   Seek (fpas, $2700); Seek (fass, $2700);
   BlockRead (fass, buf, $800, count);
   BlockWrite (fpas, buf, count);
   Close (fass); Close (fpas);
end.


   ГЛАВА 14

   СТАНДАРТНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ


----------------------------------------------------------
         ФУНКЦИЯ        Abs
----------------------------------------------------------
ОПИСАНИЕ: function Abs (x:NumType) : NumType

ПАРАМЕТРЫ: x - целого типа или вещественного типа.

ТИП РЕЗУЛЬТАТА: совпадает с типом аргумента

ДЕЙСТВИЕ: вычисляет абсолютную величину (модуль) аргумента

----------------------------------------------------------
         ФУНКЦИЯ        Addr
----------------------------------------------------------
ОПИСАНИЕ: function Addr (x):word

ПАРАМЕТРЫ: x есть произвольная ссылка на переменную или иден-
           тификатор процедуры или функции.

ДЕЙСТВИЕ: результатом этой функции являеется слово,  значение
          которого есть адрес указанной в качестве  аргумента
          переменной, или адрес точки входа в  процедуру  или
          функцию.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: тип результата ф.Addr в EP совпада-
          ет с типом результата этой функции в языке TP v.2.0
          но отличается от ее  типа  результата  в  языке  TP
          v.4.0-там результат есть Pointer. Для  того,  чтобы
          получить значение адреса типа Pointer, в  EP  нужно
          использовать   операцию    @    или    конструкцию:
          Ptr(Addr(x)).
СМ.ТАКЖЕ: Ptr; операция @

----------------------------------------------------------
         ПРОЦЕДУРА      Append
----------------------------------------------------------
ОПИСАНИЕ: procedure Append (var f:Text)

ДЕЙСТВИЕ: п.Append открывает существующий внешний файл, кото-
          рый связан с переменнеой f, как текстовый файл  для
          дозаписи. Текущая позиция в открытом файле устанав-
          ливается на символ  /\Z  в  последнем  128-байтовом
          блоке - если таковой там  имеется,  или  за  концом
          последнего 128-байтного блока - в противном случае.
          Если перед вызовом п.Append файл f был  открыт,  то
          он предварительно закрывается и  затем  открывается
          снова.
          Файл, открытый с помощью п.Append, доступен  только
          для записи; значение ф.Eof(f) всегда есть True.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файловая переменная f  должна  быть
          предварительно связана с внешним файлом  с  помощью
          п.Assign.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
          4 - file not found
          5 - disk read only
          8 - ASSIGN wos not executed
          13 - REWRITE or APPEND not allowed
          В рижеме {$I-} ошибки 4,5 и 13  не  диагностируются
          немедленно, но могут быть обработаны  Паскаль-прог-
          раммой с помощью функции IOResult; ошибка 8  всегда
          диагностируется немедленно.
СМ.ТАКЖЕ: Reset, Rewrite

ПРИМЕР:

var f:text;
begin
   Assign (f,'test.txt'); Rewrite (f);
   Writeln (f, 'начальный текст'); Close (f);
{на текущем диске создали новый файл с именем test.txt и  }
{записали в него одну строку. п.Close здесь можно было бы и }
{не выполнять; файл был бы автоматически закрыт при выполне-}
{нии следующей процедуры Append}
   Append (f);
   Writeln (f,'добавленный текст'); Close (f);
{открыли файл test.txt снова и дописали в него еще одну}
{строку}
end.

----------------------------------------------------------
         ФУНКЦИЯ        ArcTan
----------------------------------------------------------
ОПИСАНИЕ: function ArcTan (x:real) : real

ДЕЙСТВИЕ: вычисляется арктангенс аргумента. Результат выдает-
          ся в радианах

----------------------------------------------------------
         ПРОЦЕДУРА      Assign
----------------------------------------------------------
ОПИСАНИЕ: procedure Assign (var f; name:string)

ПАРАМЕТРЫ: f- переменная любого файлового типа
           neme- выражение  строкового  типа  ,  задающее имя
           внешнего файла

ДЕЙСТВИЕ: с файловой переменной f связывается внешний файл  с
          именем name. Все последующие операции над  файловой
          переменной f будут  выполняться  над  этим  внешним
          файлом.
          Установленная связь  между  файловой  переменной  и
          внешним файлом  сохраняется  до  следующего  вызова
          п.Assign; в этот  период  файл  может  неоднократно
          открываться и закрываться.
          Одна файловая переменная  может  быть  использована
          для последовательной работы с несколькими  внешними
          файлами. В этом случае всякий раз при  переходе  от
          работы с одним внешним файлом к другому должна  вы-
          полняться п.Assign. Имя файла  (значение  параметра
          name) может быть либо именем дискового файла,  либо
          именем устройства.
          Возможные имена устройств:
          CON:, CRT:, TTY:, '', KBD:, LST:, LPT:, PRN:, AUX:,
          NUL: (строчные и прописные буквы отождествляются).
          Имя дискового файла имеет формат:
          duu:nnnnnnnn.eee      ,где
          d -обозначение дисковода (A...P);
          uu - номер пользователя (0...15);
          nnnnnnnnn - имя файла (от 0 до 8 литер);
          eee - расширение (от 0 до 3 литер).
          Обозначение дисковода и  (или)  номер  пользователя
          могут быть опущены; в этом случае  будут  использо-
          ваться текущие.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: п.Assign не  должна  применяться  к
          открытой файловой переменной. Это не контролируется
          автоматически  (поскольку  до  первого   применения
          п.Assign к файловой переменной содержимое ее  полей
          не определено); за выполнение этого требования  от-
          вечает ваша программа.
          Разбор имени файла выполняется  п.Assign  до  конца
          строки name или до появления недопустимой  в  имени
          файла литеры. В последнем случае хвост строки игно-
          рируется; имя формируется из предшествующих  литер.
          Ошибка в имени файла п.Assign не диагностируется.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
          7 - ASSIGN applied to predefined variable.
          Эта ошибка возникает при попытке применить п.Assign
          к предопределенным файловым переменным  (Lst,  Kbd,
          Input, Output). Эта ошибка всегда приводит к  прек-
          ращению выполнения рабочей программы, независимо от
          того, какой режим - {$I+} или {$I-} установлен.

----------------------------------------------------------
         ПРОЦЕДУРА      BDOS
----------------------------------------------------------
ОПИСАНИЕ: procedure BDOS 8var RR:Register)s

ПАРАМЕТРЫ: предопределенный тип Registers описан как:

          type Registers
                record
                        case boolean of
                        True : (A, F, C, B, E, D, L, H:byte);
                        False: (PSW, BC, DE, NL:word);
          end

          Поля записи соответствуют регистрам  МП  8080.  Два
          варианта соответствуют возможностям  работы  с  ре-
          гистрами как с байтами и как со словами.
          Параметр RR является и входным, и выходным.
          Перед вызовом  процедуры  BDOS  в  этой  переменной
          должны быть сформированы регистры  -  аргументы  (в
          частности, в RR.C должен быть задан  номер  функции
          BDOS); после выполнения этой процедуры в переменной
          RR находятся результаты.

ДЕЙСТВИЕ: отключается обработка вводимых с консоли  специаль-
          ных управляющих символов - /\C  и  /\S;  содержимое
          переменной RR переносится в регистры МП; выполняет-
          ся команда CALL 5H; содержимое регистров МП перено-
          сится в переменную RR; включается обработка  /\C  и
          /\S.
          То, какая функция BDOS будет вызвана,  определяется
          содержимым поля RR.C параметра. Значения  остальных
          полей должны быть  сформированы  в  соответствии  с
          требованиями соответствующей функции BDOS. Никакого
          контроля корректности параметров не выполняется.
          Описание процедур BDOS  вы  можете  найти  в  руко-
          водстве по работе с OС.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: поскольку на время выполнения  про-
          цедуры BDOS приостанавливается обработка /\C и /\S,
          обращение к функциям BDOS с помощью этой  процедуры
          предпочтительнее, чем с помощью оператора inline.
          Библиотека процедур периода исполнения  EP  предос-
          тавляет достаточно возможностей; рекомендуем  поль-
          зоваться процедурой BDOS только при крайней необхо-
          димости.

СМ. ТАКЖЕ: BIOS.

----------------------------------------------------------
         ПРОЦЕДУРА      BIOS
----------------------------------------------------------
ОПИСАНИЕ: procedure BIOS (FNr:byte; var RR:Registers)

ПАРАМЕТРЫ: предопределенный тип Registers описан как:

          type Registers =
          record
                case boolean of
                True : (F, A, C, B, E, D, L, H :byte);
                False: (PSW, BC, DE, HL :word);
          end

          Поля записи соответствуют регистрам  МП  8080.  Два
          варианта соответствуют возможностям  работы  с  ре-
          гистрами как с байтами и как со словами.
          Параметр RR является и входным  и  выходным.  Перед
          вызовом процедуры BIOS  в  этой  переменной  должны
          быть сформированы регистры - аргументы;  после  за-
          вершения выполнения этой процедуры в переменной  RR
          находятся результаты.

ДЕЙСТВИЕ: отключается обработка вводимых с консоли  специаль-
         ных управляющих символов - /\C и /\S; содержимое пе-
         ременной RR переносится в регистры  МП;  выполняется
         вызов указанной процедуры BIOS; содержимое регистров
         МП переносится в переменную RR; включается обработка
         /\C и /\S.
         То, какая функция BIOS будет  вызвана,  определяется
         содержимым певого параметра. Функции BIOS  считаются
         пронумерованными с 0, в том порядке, в  котором  они
         расположены в векторе входов (0-начальная  инициали-
         зация; 1-презагрузка ОС; 2-статус консоли  и  т.д.).
         Контроля за тем, что номер функции BIOS является до-
         пустимым, не производится.
         Значения полей RR должны быть сформированы  в  соот-
         ветствии с требованиями соответствующей функции  BI-
         OS. Никакого контроля корректности параметров не вы-
         полняется.
         Описание процедур BIOS вы можете найти в руководстве
         по ОС.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: поскольку на время выполнения  про-
          цедуры BIOS приостанавливается обработка /\C и /\S,
          обращение к функциям BIOS с помощью этой  процедуры
          предпочтительнее, чем с помощью оператора inline.
          Библиотека процедур периода исполнения  EP  предос-
          тавляет достаточно возможностей; рекомендуем  поль-
          зоваться процедурой BIOS только при крайней необхо-
          димости.

СМ. ТАКЖЕ: BDOS.

-------------------------------------------------------------
         ПРОЦЕДУРА      BlockRead
-------------------------------------------------------------
ОПИСАНИЕ: procedure BlockRead (var f:file; var buf;
                                count:word; [var res:word])

ПАРАМЕТРЫ: f-нетипизированная файловая переменная
          buf- ссылка на переменную произвольного типа
          count- выражение типа word
          res- ссылка на переменную типа word (необязательный
          параметр)

ДЕЙСТВИЕ: из файла f читается count или меньше записей и  по-
          мещается в память, начиная с байта, на который ука-
          зывает ссылка на переменную buf. Фактическое  число
          полностью прочитанных записей возвращается в  пара-
          метре res (если он задан). Текущая позиция в  файле
          продвигается на число прочитанных байт вперед.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: п.BlockRead применима только к  не-
          типизированным файлам.
          Файл f должен быть открыт.
          Длина записи определяется в момент открытия  файла:
          она задается вторым параметром п.Reset или  Rewrite
          (если он опущен, то  длина  записи  устанавливается
          равной 128 байт).
          Общее количество читаемых байт не  может  превосхо-
          дить 2'16.
          Проверка выхода за границу переменной buf не произ-
          водится.
          Количество  фактически  прочитанных  записей  может
          оказаться меньше затребованного, только если в про-
          цессе чтения достигнут конец файла. В этом  случае,
          если параметр res опущен, возникает ошибка  периода
          исполнения Reading unwritten data.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
          1 - Reading unwritten data
          8 - ASSIGN wos not executed
          9 - File not open
          11- File write only

          в режиме {$I-} ошибки 1 и 11 не диагностируются не-
          медленно,  но  могут  быть  обработаны  с   поиощью
          ф.IOResult; ошибки 8 и 9 всегда диагностируются не-
          медленно.

СМ.ТАКЖЕ: BlockWrite, Reset, Rewrite.

ПРИМЕР:

{простая и быстрая программа копирования файлов}
{имя исходного файла - первый параметр командной строки}
{имя файла результата - второй}
{никакого контроля за ошибками нет!!!}

var Fromf, Tof:file;
    NrRead, NrWritten:word;
    buf: array [1..10*1024] of byte;

begin
   Assign (Fromf, ParamStr(1)); Reset (Fromf,1);
   Assign (Tof, ParamStr(2));   Rewrite (Tof, 1);
         repeat
   BlockRead (Fromf, buf, sizeof(buf), NrRead);
   BlockWrite (Tof, buf, NrRead, NrWritten);
   until (NrRead=0) or (NrWritten<>NrRead);
   Close (Fromf); Close (Tof);
end.


-------------------------------------------------------------
         ПРОЦЕДУРА      BlockWrite
-------------------------------------------------------------
ОПИСАНИЕ: procedure BlockWrite (var f:file; var buf;
                                count:word; [var res:word])

ПАРАМЕТРЫ: f-нетипизированная файловая переменная
          buf- ссылка на переменную произвольного типа
          count- выражение типа word
          res- ссылка на переменную типа word (необязательный
          параметр)

ДЕЙСТВИЕ:в файл f записывается count или меньше записей из об
          ласти памяти, начинающейся с байта, на который ука-
          зывает ссылка на переменную buf. Фактическое  число
          полностью записанных  записей возвращается в  пара-
          метре res (если он задан). Текущая позиция в  файле
          продвигается на число записанных байт вперед.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: п.BlockWrite применима только к не-
          типизированным файлам.
          Файл f должен быть открыт.
          Длина записи определяется в момент открытия  файла:
          она задается вторым параметром п.Reset или  Rewrite
          (если он опущен, то  длина  записи  устанавливается
          равной 128 байт).
          Общее количество читаемых байт не  может  превосхо-
          дить 2'16.
          Проверка выхода за границу переменной buf не произ-
          водится.
          Количество фактически записанных записей может ока-
          заться меньше затребованного, только если в процес-
          се записи переполнится диск или его  оглавление.  В
          этом случае, если параметр  res  опущен,  возникает
          ошибка периода исполнения Disk full  или  Directory
          full.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
          2- Disk full
          3- Directory full
          5- Disk read only
          6- File read only
          8- Assign was not executed
          9- File not open

          В режиме {$I-} ошибки  2,3,5,6  не  диагностируются
          немедленно ,но  могут  быть  обработаны  с  помощью
          ф.IOResult; ошибки 8 и 9 всегда диагностируются не-
          медленно.

СМ ТАКЖЕ: BlockRead, Reset, Rewrite.

ПРИМЕР:   См. пример к п.BlockRead


-----------------------------------------------------------
         ПРОЦЕДУРА      Break
-----------------------------------------------------------
ОПИСАНИЕ: procedure Break [(label)]

ПАРАМЕТРЫ: необязательный параметр label - метка, которой пом
         ечен оператор, выполнение которого нужно прервать.

ДЕЙСВИЕ: завершается выполнение помеченного меткой label опе-
         ратора (если параметр указан) или самого внутреннего
         оператора цикла for, while или  repeat  в  противном
         случае. Действие этой процедуры эквивалентно перехо-
         ду на оператор, следующий за прерываемым оператором.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если эта процедура выполняется  вне
         помеченного меткой label оператора (при вызове с па-
         раметром) или вне оператора цикла  (при  вызове  без
         параметра), то она не оказывает никакого действия.

СМ.ТАКЖЕ: Exit, Halt

ПРИМЕР:  следующий фрагмент:

var xx: array [1..20, 1..30] of real;
   j, i:integer;
....
begin
...
   for i:=1 to 20
   do for j:=1 to 30
         do if xx[i,j]>0
                then xx[i,j]:=xx[i,j]-1 else break;
.....
end;

эквивалентен фрагменту:

var xx: array [1..20, 1..30] of real;
   j, i:integer;
   label l;
....
begin
...
   for i:=1 to 20
   do begin
         for j:=1 to 30
         do if xx[i,j]>0
                then xx[i,j]:=xx[i,j]-1 else goto l;
.....
l:end;
  .......
end;

------------------------------------------------------------
         ПРОЦЕДУРА      ChDir
------------------------------------------------------------
ОПИСАНИЕ: procedure ChDir (s:string)

ДЕЙСТВИЕ: изменяется текущий дисковод и/или номер пользовате-
         ля.
         Параметр должен быть задан в формате: duu  где
         d- обозначение дисковода (A...P)
         uu-номер пользователя (0...15)
         Обозначение дисковода или номер  пользователя  могут
         быть опущены; в этом случае они не изменяются.  Дво-
         еточие в конце всегда должно присутствовать.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: при ошибке в параметре никаких дей-
         ствий не выполняется, сообщения об ошибке не выдает-
         ся.

СМ.ТАКЖЕ: GetDir


------------------------------------------------------------
         ПРОЦЕДУРА      CheckStack
------------------------------------------------------------
ОПИСАНИЕ: procedure CheckStack (size:word)

ДЕЙСТВИЕ: эта процедура проверяет, что в текущий момент  раз-
         мер свободной части аппаратного стека не меньше  чем
         size байт. В  случае  если  размер  свободной  части
         меньше, чем требуемый, возникает ошибка времени  ис-
         полнения "переполнение стека";  иначе  никаких  дей-
         ствий не выполняется.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         21- Stack overflow


------------------------------------------------------------
         ФУНКЦИЯ        Chr
------------------------------------------------------------
ОПИСАНИЕ: function Chr (x:bfte):char

ДЕЙСТВИЕ: эта функция  не  выполняет  никаких  содержательных
         действий - она только позволяет трактовать  целочис-
         ленное значение как литеру с соответствующим кодом.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: точно такого же эффекта можно  дос-
         тичь с помощью преобразователя типа выражения к типу
         char

СМ.ТАКЖЕ: Ord; преобразователь типа выражения.


------------------------------------------------------------
         ПРОЦЕДУРА      Circle
------------------------------------------------------------
ОПИСАНИЕ: procedure Circle (x,y:integer; r:word;
                                     fill:boolean)

ДЕЙСТВИЕ: рисует окружность с центром в точке (x,y)  и  ради-
         усом r. Если последний параметр (fill)  есть  False,
         то рисуется окружность (контур); если он есть  True,
         то рисуется круг (заполненный).

ДОПОЛНИТЕЛЬНЫЕ  ЗАМЕЧАНИЯ:  окружность выводится на  экран  в
         предположении, что горизонтальный размер экрана  от-
         носится к вертикальному как 4:3; радиус задается как
         число точек по горизонтали.
         Часть окружности может не помещаться  на  экране;  в
         частности, координаты центра  могут  соответствовать
         точке, не помещающейся на экране.
         Координаты точек, присутствующих на экране: по гори-
         зонтали  (x-координата)  -  0...511;  по   вертикали
         (y-координата) - 0...255. Точка в левом верхнем углу
         экрана имеет координаты (0,0).
         Цвет изображения задает п.SetColor.
         Вывод графической информации на экран  может  выпол-
         няться параллельно с выводом  текстовой  информации.
         Текстовая информация на цветном экране выводится бе-
         лым цветом, на черно-белом - самым ярким цветом.

СМ.ТАКЖЕ: ClrScr, GetPixel, Line, PutPixel, Rectangle, SetCo-
          lor


------------------------------------------------------------
         ПРОЦЕДУРА      Close
------------------------------------------------------------
ОПИСАНИЕ: procedure Close (var f)

ПАРАМЕТРЫ: f- переменная любого файлового типа

ДЕЙСТВИЕ: файл f закрывается.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: только при выполнении  п.Close  со-
         держимое буферов ввода-вывода записывается на  диск.
         Если выполнение программы будет прекращено до выпол-
         нения п.Close, то может оказаться, что  в  файле  на
         диске содержится не вся информация, которую програм-
         ма успела туда записать - однако файл на диске будет
         оформлен корректно.
         Никаких ошибок ввода-вывода при  выполнении  п.Close
         не диагностируется (кроме ошибок, связанных с некор-
         ректным обращением к программе).

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         8- ASSIGN was not executed
         9- File not open
         Эти ошибки всегда  вызывают  прекращение  выполнения
         рабочей программы, независимо от того,  какой  режим
         {$I..} установлен.

СМ.ТАКЖЕ: Append, Assign, Reset, Rewrite.


-------------------------------------------------------------
         ПРОЦЕДУРА      ClrGScr
-------------------------------------------------------------
ОПИСАНИЕ: procedure ClrGScr

ДЕЙСТВИЕ: очищает графический экран (окрашивает все его точки
         в черный цвет) и инициализирует  таблицу  присвоения
         цветов. В начале выполнения программы таблица  прис-
         воения цветов запрограммирована так, что  содержимое
         графической памяти не отображается на экране  -  по-
         этому до выполнения этой процедуры выполнение  любой
         другой процедуры вывода на графический экран не ока-
         жет видимого действия.

СМ.ТАКЖЕ: Circle, GetPixel, Line, PutPixel,  Rectangle,  Set-
          Color


-------------------------------------------------------------
         ПРОЦЕДУРА      ClrScr
-------------------------------------------------------------
ОПИСАНИЕ: procedure ClrScr

ДЕЙСТВИЕ: очищает текстовый экран (заполняет его пробелами) и
         помещает курсор в левый верхний его угол.

СМ.ТАКЖЕ: GоtоXY


-------------------------------------------------------------
         ФУНКЦИЯ        Concat
-------------------------------------------------------------
ОПИСАНИЕ: function Concat
                (s1 [,s2,...,sN]:string) : string

ПАРАМЕТРЫ: эта функция  имеет  переменное  число  параметров,
         каждый из которых является выражением строкового ти-
         па

ДЕЙСТВИЕ: результатом этой функции является  строка,  получа-
         емая  конкатенацией  (последовательным  приписываним
         друг к другу) строк-аргументов. Если результат полу-
         чается длиннее 255 символов, то он укорачивается  до
         255 символов откидыванием правых символов.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: тот же самый  результат  получается
         при выполнении операции "+" над строками, и  поэтому
         в EP ф.Concat является избыточной;  она  включена  в
         язык для совместимости с другими версиями языка Пас-
         каль.

СМ.ТАКЖЕ: Copy, Delete, Insert, Length, Pos


-------------------------------------------------------------
         ФУНКЦИЯ        Copy
-------------------------------------------------------------
ОПИСАНИЕ: function Copy (s:string;
                index, count:byte) : string

ДЕЙСТВИЕ: результатом этой функции является подстрока  строки
         s, состоящая из count литер и начинающаяся с  литеры
         номер index в строке s (первая литера в строке имеет
         номер 1)

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если количество литер  в  строке  s
         меньше, чем значение  index,  то  результатом  будет
         пустая строка. Если count задает больше  литер,  чем
         имеется в s, начиная с литеры  index,  то  результат
         будет содержать только length(s)-index+1 литер.

СМ.ТАКЖЕ: Concat, Delete, Insert, Length, Pos


-------------------------------------------------------------
         ФУНКЦИЯ        Cos
-------------------------------------------------------------
ОПИСАНИЕ: function Cos (x:real) : real

ДЕЙСТВИЕ: вычисляется косинус аргумента. Аргумент задается  в
          радианах


-------------------------------------------------------------
         ПРОЦЕДУРА      Dec
-------------------------------------------------------------
ОПИСАНИЕ: procedure Dec (var x:OrdTipe [; n :IntTipe])

ПАРАМЕТРЫ: x- переменная любого упорядоченного типа
           n- выражение целого типа

ДЕЙСТВИЕ: значение переменной x  уменьшается  на  величину  n
          (или на 1, если параметр n опущен).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: для вызова п.Dec генерируется более
         оптимальный код, чем  для  эквивалентного  оператора
         присваивания x:=x-n. Рекомендум  использовать  п.Dec
         во внутренних циклах.

СМ.ТАКЖЕ: Inc, Pred, Succ


-------------------------------------------------------------
         ПРОЦЕДУРА      Delay
-------------------------------------------------------------
ОПИСАНИЕ: procedure Delay (ms:word)

ДЕЙСТВИЕ: выполнение программы приостанавливается на ms  мил-
          лисекунд (приблизительно).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: во время задержки возможен  ввод  с
          клавиатуры; вводимые символы будут накапливаться  в
          буфере.


-------------------------------------------------------------
         ПРОЦЕДУРА      Delete
-------------------------------------------------------------
ОПИСАНИЕ: procedure Delete (var s:string;
                        index, count :byte)

ДЕЙСТВИЕ: из строки s удаляется count литер, начиная с литеры
         номер index (первая литера в строке имеет номер 0).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если количество литер  в  строке  s
         меньше, чем значение index, то из строки s ничего не
         удаляется. Если count задает больше литер, чем  име-
         ется в s , начиная  с  литеры  index,  то  удаляется
         хвост строки (состоящий из length(s)-index+1 литер).

СМ.ТАКЖЕ: Concat, Copy, Insert, Length, Pos


-------------------------------------------------------------
         ФУНКЦИЯ        DiskFree
-------------------------------------------------------------
ОПИСАНИЕ: function DiskFree :longint

ДЕЙСТВИЕ: результатом этой функции является  количество  сво-
          бодных байт на текущем диске.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: для того, чтобы узнать размер  сво-
         бодного пространства на не  текущем  диске,  следует
         сначала сделать  его  текущим  и  затем  вызвать  ф.
         DiskFree.

СМ.ТАКЖЕ: DiskSize


-------------------------------------------------------------
         ФУНКЦИЯ        DiskSize
-------------------------------------------------------------
ОПИСАНИЕ: function DiskSize : longint

ДЕЙСТВИЕ: результатом этой функции является общее  количество
          байт на текущем диске.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: для того, чтобы узнать общий размер
         не текущего диска, следует сначала сделать его теку-
         щим и затем вызвать ф.DiskSize.

СМ.ТАКЖЕ: DiskFree


-------------------------------------------------------------
         ФУНКЦИЯ        Eof
-------------------------------------------------------------
ОПИСАНИЕ: function Eof [(var f)] : boolean

ПАРАМЕТРЫ: f- переменная произвольного файлового  типа;  если
         этот параметр опущен, то подразумевается предопреде-
         ленный файл Input.

ДЕЙСТВИЕ: эта функция выдает True, если текущая позиция нахо-
         дится в конце файла, и False в противном случае.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл  должен  быть  открыт.  Никакх
         ошибок, кроме ошибок  некорректного  обращения  ,при
         вызове этой функции не возникает.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         8- ASSIGN was not executed
         9- File not open
         Эти ошибки всегда приводят к прекращению  выполнения
         рабочей программы, независимо от того,  какой  режим
         {SI..} установлен

СМ.ТАКЖЕ: Eoln.

ПРИМЕР:

{вывод текстового файла на дисплей}
{имя выводимого файла берется из командной строки}

var f:text;
    s:string;

begin
   assign (f, paramstr(1)); reset (f);
   while not eof (f)
   do begin readln (f,s); writeln(s); end;
end.


-------------------------------------------------------------
         ФУНКЦИЯ        Eoln
-------------------------------------------------------------
ОПИСАНИЕ: function Eoln [(var f:Text)] : boolean

ПАРАМЕТРЫ: если параметр f опущен , то  подразумевается  пре-
           допределенный файл Input.

ДЕЙСТВИЕ: если текущая позиция находится в конце  строки,  то
          результат функции есть True, иначе  результат  есть
          False. Текущая позиция считается находящейся в кон-
          це строки, если истинно Eof(f) или  текущий  символ
          есть Cr или Lf (0Dh и 0Ah соответственно).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data
         8- ASSIGN was not executed
         9- File not open
         11- File write only
         В режиме {$I-} ошибка 1 не диагностируется немедлен-
         но, но может буть обработана с  помощью  ф.IOResult;
         ошибки 8,9 и 11 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Eof.


-------------------------------------------------------------
         ПРОЦЕДУРА      Erase
-------------------------------------------------------------
ОПИСАНИЕ: procedure Erase (var f)

ПАРАМЕТРЫ: f- переменная любого файлового типа

ДЕЙСТВИЕ: на диске уничтожается файл с именем,  которое  было
          присвоено файловой переменной f п.Assign.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл не должен  быть  открыт.  Если
          файл назначен на устройство, то никаких действий не
          выполняется.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         4- File not found
         5- Disk read only
         6- File read only
         8- ASSIGN was not executed
         10- File is open
         В режиме {$I-} ошибки 4,5,6 не  диагностируются  не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8 и 10 всегда диагностируются немедлен-
         но.

СМ.ТАКЖЕ: Rename.

ПРИМЕР:

{программа удаления файла с диска}
{имя файла (возможно с указанием дисковода и номера}
{пользователя) задается в командной строке.}

var f:file;
    c:char;

begin
   assign (f, paramstr(1));
   {$I-} reset(f); {$I+}
   if ioresult<>0
   then writeln ('файл', paramstr(1), 'не найден')
else begin
   close(f);
   write ('удалять', paramstr(1), '? (д/н)');
   readln(c);
   if upcase(c)='д' then erase(f);
   then begin
         {$I-} erase(f); {$I+}
         if ioresult=0
         then writeln ('удален')
         else writeln ('удаление невозможно');
         end;
   end;
end.


-------------------------------------------------------------
         ПРОЦЕДУРА      Exit
-------------------------------------------------------------
ОПИСАНИЕ: prosedure Exit

ДЕЙСТВИЕ: эта процедура вызывает выход из выполняемой в  дан-
          ный момент процедуры или функции. Выполнение п.Exit
         полнстью эквивалентно переходу (goto) на метку, рас-
         положенную перед завершающим  тело  процедуры  (фун-
         кции) end.

СМ.ТАКЖЕ: Break, Halt.

ПРИМЕР:

{эта процедура выводит в середину верхней строки экрана}
{мигающую надпись "Ожидание ввода" до тех пор, пока не}
{будет нажата клавиша на клавиатуре}

procedure WAITFORINPUT;

procedure  outmess;
begin
   gotoxy(0,24);
   writeln ('Ожидание ввода');
end;
procedure clearmess;
begin
   gotoxy (0,24);
   writeln ('              ');
end;
begin
   while true
   do begin
         if keypressed then exit;
         outmess; delay (400);
         clearmess; delau (100);
   end;
end.


-------------------------------------------------------------
         ФУНКЦИЯ        Еxp
-------------------------------------------------------------
ОПИСАНИЕ: function Exp (x:real) : real

ДЕЙСТВИЕ: вычисляется экспонента аргумента, т.е. e'x, где
          е=2.718281828... - основание натурального  логариф-
          ма.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         16- Invalid argumment

СМ.ТАКЖЕ: Ln.


-------------------------------------------------------------
         ФУНКЦИЯ        FilePos
-------------------------------------------------------------
ОПИСАНИЕ: function FilePos (var f) : longint

ПАРАМЕТРЫ: f- переменная любого файлового типа

ДЕЙСТВИЕ: результат функции есть количество записей между на-
          чалом файла и текущей позицией.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.
         Если текущая позиция находится в  начале  файла,  то
         FilePos(f)=0. Если текущая позиция находится в конце
         файла (т.е. Eof(f)=True), то  FilePos(f)=FileSize(f)
         - за исключением случая текстового файла, где  будет
         FilePos(f)<FileSize(f).
         Для текстовых файлов запись считается  состоящей  из
         1-го байта, поэтому FilePos выдает количество байтов
         перед текущей позицией.
         Для файлов на устройствах всегда выдает 0.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         8- ASSIGN was not executid
         9- File not open
         Эти ошибки всегда приводят к прекращению  выполнения
         программы, независимо от того,  какой  режим  {$I..}
         установлен.

СМ.ТАКЖЕ: FileSize, Seek



































































































































































































------------------------------------------------------------
         ФУНКЦИЯ        FileSize
------------------------------------------------------------
ОПИСАНИЕ: function FileSize (var f) : longint

ПАРАМЕТРЫ: f- переменная любого файлового типа.

ДЕЙСТВИЯ: результат функции есть количество записей в файле.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.
         Для текстовых файлов  запись считается состоящей  из
         1-го байта, поэтому FileSize выдает количество  байт
         в файле - включая последний 128-байтовый блок  цели-
         ком.
         Для файлов на устройствах всегда выдает 0.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         8- ASSIGN was not executed
         9- File not open
         Эти ошибки всегда приводят к прекращению  выполнения
         программы, независимо от того,  какой  режим  {$I..}
         установлен.

СМ.ТАКЖЕ: FilePos, Seek.


------------------------------------------------------------
         ПРОЦЕДУРА      FillChar
------------------------------------------------------------
ОПИСАНИЕ: procedure FillChar (var x; cnt:word; ch)

ПАРАМЕТРЫ: x- произвольная ссылка на переменную
         cnt- выражение целого типа
         ch- выражение произвольного упорядоченнго  типа  (из
         него используется только мл. байт).

ДЕЙСТВИЕ: область памяти длиной cnt байт, начиная  с  первого
         байта, занимаемого переменной x,  заполняется  кодом
         ch. Проверки выхода за пределы переменной x не  про-
         изводится.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если  возможно,  используйте  Size-
         Of(x) на месте параметра cnt - это уменьшит риск ис-
         портить расположенные рядом с x переменные.
         После заполнения строковой переменной  не  забывайте
         сформировать ее длину - никто, кроме вас ,  об  этом
         не позаботится.

СМ.ТАКЖЕ: Move.

ПРИМЕР:

.....
var s:string[64];
.....
fillchar (s, sizeof(s), '-');
s[0]:64;      {на экран выводится строка, состоящая из одних}
write(s);       {черточек (перевод строки не выполняется-}
                 {при заполнении строки целиком курсор авто-}
......           {матически переходит на следующую строку}


------------------------------------------------------------
         ФУНКЦИЯ        Frac
------------------------------------------------------------
ОПИСАНИЕ: function Frac (x:real) : real

ДЕЙСТВИЕ: результат функции есть дробная часть  вещественного
         числа x: Frac(x)=x-Int(x).  Т.к.  Int(x)  получается
         округлением x по направлению к 0 , для отрицательных
         аргументов  значение  Frac(x)  будет  отрицательным.
         Например: Frac(1.6)=0.6; Frac(-1.6)=-0.6.

СМ.ТАКЖЕ: Int


------------------------------------------------------------
         ПРОЦЕДУРА      GetDir
------------------------------------------------------------
ОПИСАНИЕ: procedure GetDir (var s:string)

ПАРАМЕТРЫ: s- переменная строкового  типа;  ее  длина  должна
         быть не меньше 4 -  процедура  всегда  устанавливает
         динамическую длину строки равной 4, и заполняет пер-
         вые 4 литеры, не проверяя максимальную длину  факти-
         ческого параметра.

ДЕЙСТВИЕ: в строковую переменную - параметр заносится  инфор-
         мация о текущем дисководе и  номере  пользователя  в
         формате:  "duu"  ,  где  d-  обозначение   дисковода
         (A...P), uu- номер пользователя (0...15,  ведущий  0
         присутствует).

СМ.ТАКЖЕ: ChDir.


------------------------------------------------------------
         ПРОЦЕДУРА      GetMem
------------------------------------------------------------
ОПИСАНИЕ: procedure GetMem (var p:pointer; size:word)

ДЕЙСТВИЕ: в куче создается динамическая  переменная  размером
         size байт и ее адрес заносится в переменную p

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: состав процедур работы с кучей в EP
         таков, что фрагментации памяти в куче не происходит.
         Свободная память в куче всегда образует связную  об-
         ласть, и п.GetMem выделяет память  с  нижнего  конца
         этой области. Если памяти в  куче  недостаточно,  то
         возникает ошибка периода исполнения.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         19- Heap overflow

СМ.ТАКЖЕ: Mark, MemAvail, New, Release.


------------------------------------------------------------
         ФУНКЦИЯ        GetPixel
------------------------------------------------------------
ОПИСАНИЕ: function GetPixel (x,y:integer) : byte

ДЕЙСТВИЕ: эта функция выдает цвет точки графического экрана с
          координатами (x,y).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если заданные координаты выходят за
         пределы экрана, то результат есть черный цвет.
         Координаты точек, присутствующих на экране: по гори-
         зонтали  (x-координата)  -  0...511;  по   вертикали
         (y-координата) - 0...255. Точка в верхнем левом углу
         экрана имеет координаты (0,0).
         Кодировка цветов:
         0- черный
         1- синий
         2- зеленый
         3- голубой
         4- красный
         5- фиолетовый
         6- желтый
         7- белый

         На черно-белом экране  цвета  передаются  градациями
         яркости; яркость  возрастает  при  возрастании  кода
         цвета.
         Наличие текстовой информации в соответствующем месте
         экрана никак не учитывается.

СМ.ТАКЖЕ: Circle, ClrGScr, Line, PutPixel, Rectangle,  SetCo-
          lor.


------------------------------------------------------------
         ПРОЦЕДУРА      GotoXY
------------------------------------------------------------
ОПИСАНИЕ: procedure GotoXY (x,y:byte)

ДЕЙСТВИЕ: курсор на экране перемещается  в  строку  номер  y,
          столбец номер x.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: строки и столбцы на экране  нумеру-
         ются с 0. В результате выполнения GotoXY (x,y),  над
         курсором находится y строк и слева от курсора  нахо-
         дится x столбцов.


------------------------------------------------------------
         ПРОЦЕДУРА      Halt
------------------------------------------------------------
ОПИСАНИЕ: procedure Halt

ДЕЙСТВИЕ: выполнение  программы  прекращается  и   управление
         возвращается системе EP (если программа  выполнялась
         по команде Run) или ОС (если выполнялась скомпилиро-
         ванная ранее на диск программа).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: как и при любом  другом  завершении
         программы, после выполнения п.Halt инициируется  це-
         почка процедур выхода (см. главу 13).

СМ.ТАКЖЕ: Break, Exit


------------------------------------------------------------
         ФУНКЦИЯ        Hi
------------------------------------------------------------
ОПИСАНИЕ: procedure Hi (iw) : byte

ПАРАМЕТРЫ: iw- выражение типа integer или типа word.

ДЕЙСТВИЕ: результатом функции является ст.байт слова-аргумен-
          та.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: независимо от того, является  аргу-
         мент знаковым или беззнаковым, результат будет  без-
         знаковым байтом. Так, например, Hi(-1) равно 255.

СМ.ТАКЖЕ: Lo, Swap.


------------------------------------------------------------
         ПРОЦЕДУРА      Inc
------------------------------------------------------------
ОПИСАНИЕ: procedure Inc (var x:OrdTipe; [n:IntTipe])

ПАРАМЕТРЫ: x- переменная любого упорядоченного типа,
           n- выражение целого типа.

ДЕЙСТВИЕ: значение переменной x увеличивается на  величину  n
          (или на 1, если параметр n опущен).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: для вызова п.Inc генерируется более
         оптимальный код, чем  для  эквивалентного  оператора
         присваивания x:=x+n.
         Рекомендуем использовать п.Inc во внутренних циклах.

СМ.ТАКЖЕ: Dec,Pred, Succ.


------------------------------------------------------------
         ПРОЦЕДУРА      Insert
------------------------------------------------------------
ОПИСАНИЕ: procedure Insert (source:string;
                        var s:string; index:byte)

ДЕЙСТВИЕ: строка source вставляется в строку s перед символом
         с номером index (первый символ в строке имеет  номер
         1). Если результат получается длиннее 255  символов,
         то он укорачивается  до  255  символов  откидыванием
         правых символов.

СМ.ТАКЖЕ: Concat, Copy, Delete, Insert, Length, Pos.


------------------------------------------------------------
         ФУНКЦИЯ        Int
------------------------------------------------------------
ОПИСАНИЕ: function Int (x:real) : real

ДЕЙСТВИЕ: результатом функции является целая часть веществен-
         ного числа x. Целая часть получается путем  округле-
         ния x по  направлению  к  0.  Например,  Int(1.6)=1,
         Int(-1.3)=-1.

СМ.ТАКЖЕ: Frac.


------------------------------------------------------------
         ФУНКЦИЯ        IOResult
------------------------------------------------------------
ОПИСАНИЕ: function IOResult:word

ДЕЙСТВИЕ: результатом функции является код ошибки,установлен-
         ный последней операцией ввода-вывода. Если ошибки не
         было, то значение IOResult есть 0.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: вызов ф.IOResult имеет смысл только
         в том случае, когда  предшествующий  вызов  операции
         ввода-вывода был скомпилирован в режиме {$I-} - ина-
         че ошибка будет диагностироваться в период  выполне-
         ния операции и выполнение программы будет  прекраще-
         но. Сам вызов ф.IOResult может и не находиться в об-
         ласти директивы {$I-} (см. пример).
         Если  вызов  процедуры  (функции)  ввода-вывода  был
         скомпилирован в режиме {$I-} и при  выполнении  этой
         операции возникла ошибка, но до  следующей  операции
         ввода-вывода ф.IOResult не вызывалась , то в  начале
         очередной операции ввода-вывода будет диагностирова-
         на ошибка и выполнение программы будет прекращено.
         Вызов ф.IOResult сбрасывает внутренний флаг  ошибки,
         поэтому при повторном вызове этой функции  результат
         всегда будет равен 0.
         Коды ошибок, возвращаемые ф.IOResult, есть коды  со-
         общений об ошибках, выдаваемых на экран системой EP;
         они приведены в приложении Б.

ПРИМЕР:

{эта программа выдает размер файла в байтах.}
{имя файла берется из командной строки}

var f:file;
begin
   assign (f, paramstr(1));
   {$I-} reset(f,1); {$I+}
   if IOResult=0
   then writeln ('размер файла=', FileSize(f), 'байт')
   else writeln ('файл не найден');
end.


------------------------------------------------------------
         ФУНКЦИЯ        KeyPressed
------------------------------------------------------------
ОПИСАНИЕ: function KeyPressed : boolean

ДЕЙСТВИЕ: результатом функции будет True, если в буфере  кла-
         виатуры имеется хотя бы один символ, и False в  про-
         тивном случае. Символ из буфера не удаляется, и  да-
         лее может быть прочитан оттуда п.ReadKey, ReadKeyExt
         Read, Readln.

СМ.ТАКЖЕ: ReadKey, ReadKeyExt.


------------------------------------------------------------
         ФУНКЦИЯ        Length
------------------------------------------------------------
ОПИСАНИЕ: function Length (s:string) : byte

ДЕЙСТВИЕ: результатом  функции  является  динамическая  длина
          строки-параметра.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: в случае, когда  фактический  пара-
         метр является ссылкой на переменную, Length(s)  пол-
         ностью  эквивалентно  byte(s[0]),  что   реализуется
         весьма эффективно. Если же фактический параметр  яв-
         ляется выражением, то оно будет полностью вычислено,
         хотя из результата будет использована только  длина.
         Поэтому результат компиляции выражения:

         Length(s1)+Length(s2)

         (где s1 и s2 - строковые переменные) будет  занимать
         меньше места и будет выполняться  быстрее,  чем  ре-
         зультат компиляции:

         Length(s1+s2)

СМ.ТАКЖЕ: Concat, Copy, Delete, Insert, Pos


------------------------------------------------------------
         ПРОЦЕДУРА      Line
------------------------------------------------------------
ОПИСАНИЕ: procedure Line (x1, y1, x2, y2 :integer)

ДЕЙСТВИЕ: проводит на графическом экране прямую линию от точ-
         ки с координатами  x1,y1  до  точки  с  координатами
         x2,y2.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: координаты одной или обеих конечных
         точек прямой могут выходить  за  пределы  экрана;  в
         этом случае будет изображена та часть прямой,  кото-
         рая помещается на экране.
         При проведении наклонных линий учитывайте, что точки
         на экране не квадратные, и поэтому прямая, проведен-
         ная как Line (0,0,100,100) не будет  иметь  угол  45
         гр. с горизонталью.
         Координаты точек, присутствующих на экране: по гори-
         зонтали  (x-координата)  -  0...511;  по   вертикали
         (y-координата) - 0...255. Точка в верхнем левом углу
         экрана имеет координаты (0,0).
         Цвет изображения задает п.SetColor.
         Вывод графической информации на экран  может  выпол-
         няться параллельно с выводом  текстовой  информации.
         Текстовая информация на цветном экране выводится бе-
         лым цветом, на черно-белом - самым ярким цветом.

СМ.ТАКЖЕ: Circle,  ClrGScr,  GetPixel,  PutPixel,  Rectangle,
          SetColor.

ПРИМЕР:

var i:integer;
begin
   clrgscr;
   for i:=0 to 511
   do begin setcolor ((i mod 2)*7);
                line (i,0,511-i,255); end;
   for i:=0 to 255
   do begin setcolor ((i mod 2)*7);
                line (0,i,511,255-i); end;
end.


------------------------------------------------------------
         ФУНКЦИЯ        Ln
------------------------------------------------------------
ОПИСАНИЕ: function Ln (x:real) : real

ДЕЙСТВИЕ: результатом функции является  натуральный  логарифм
          числа x. Если x<=0, то возникает ошибка.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         16- Invalid Argument

СМ.ТАКЖЕ: Exp.


------------------------------------------------------------
         ФУНКЦИЯ        Lo
------------------------------------------------------------
ОПИСАНИЕ: procedure Lo (iw):byte

ПАРАМЕТРЫ: iw- выражение типа integer или типа word.

ДЕЙСТВИЕ: результатом функции является мл.  байт  слова-аргу-
          мента.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: независимо от того, является  аргу-
         мент знаковым или беззнаковым, результат будет  без-
         знаковым байтом. Например, Lo(-1) равно 255.

СМ.ТАКЖЕ: Hi, Swap.


------------------------------------------------------------
         ПРОЦЕДУРА      Mark
------------------------------------------------------------
ОПИСАНИЕ: procedure Mark (var p:pointer)

ПАРАМЕТРЫ: p- переменная произвольного указательного типа

ДЕЙСТВИЕ: переменной p присваивается текущее значение  указа-
         теля кучи; оно в дальнейшем может быть  использовано
         в качестве параметра процедуры Release.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: выполнение п.Mark(p) полностью  эк-
         вивалентно выполнению оператора присваивания:
         p:=HeapPtr;

СМ.ТАКЖЕ: GetMem, MemAvail, New, Release


------------------------------------------------------------
         ФУНКЦИЯ        MemAvail
------------------------------------------------------------
ОПИСАНИЕ: function MemAvail : word

ДЕЙСТВИЕ: результатом функции является  количество  свободных
          байт в куче.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: состав процедур работы с кучей в EP
         таков, что фрагментации памяти в куче не происходит.
         Свободная память  в  куче  всегда  образует  связную
         обл., и ф.MemAvail сообщает ее размер. Вы можете да-
         лее создать динамическую переменную размером  вплоть
         до указанного; при попытке создать переменную  боль-
         шего размера возникнет ошибка периода исполнения.
         Куча используется также при сохранении в  стеке  ло-
         кальных переменных рекурсивных процедур  и  функций.
         Поэтому, если таковые используются в вашей  програм-
         ме, позаботьтесь о том, чтобы  в  момент  их  вызова
         размер свободного пространства в куче был  достаточ-
         ным.

СМ.ТАКЖЕ: GetMem, Mark, New, Release.


------------------------------------------------------------
         ПРОЦЕДУРА      Move
------------------------------------------------------------
ОПИСАНИЕ: procedure Move (var source, dest; count:word)

ПАРАМЕТРЫ: source и dest- произвольные ссылки на переменные
         count- выражение типа word.

ДЕЙСТВИЕ: область памяти длиной count  байт,  начинающаяся  с
         первого байта source, копируется в  область  памяти,
         начинающуюся с первого байта dest.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ:  процедура  автоматически  выбирает
         направление пересылки (от мл.байт к старшим  или  от
         ст. байт к младшим) так, что при перекрывающихся об-
         ластях source и  dest  копирование  будет  выполнено
         корректно. Поэтому следующая последовательность опе-
         раторов:

         mem[$80]:=0; move(mem[$80], mem[$81], $7F);

         не приведет к заполнению области от $80 до $FF нуля-
         ми. Для заполнения памяти заданным кодом пользуйтесь
         п.FillChar.
         Никакой проверки выхода за пределы переменных source
         и dest не производится.
         Рекомендуем по возможности пользоваться ф.SizeOf для
         задания параметра count.

СМ.ТАКЖЕ: FillChar.

ПРИМЕР:

......
var a:array [1,4] of char;
   b:longint;
....
move (a,b,sizeof(b));
   {содержимое 4-байтового массива литер копируется в пере-}
   {менную типа longint (зачем это может понадобиться}
   {придумайте сами). Использование SizeOf гарантирует,}
   {что переменные, расположенные рядом с b, не испортятся}


------------------------------------------------------------
         ПРОЦЕДУРА      New
------------------------------------------------------------
ОПИСАНИЕ: procedure New (var p: pointer)

ПАРАМЕТРЫ: p- переменная указательного типа - обязательно ти-
           пизированного (т.е. типа вида /\type).

ДЕЙСТВИЕ: в куче создается динамическая переменная типа  type
         и ее адрес заносится в переменную p. В дальнейшем на
         эту переменную можно ссылаться с помощью конструкции
         p/\.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: состав процедур работы с кучей в EP
         таков, что фрагментации памяти в куче не происходит.
         Свободная память в куче всегда образует связную  об-
         ласть и п.New выделяет память с нижнего  конца  этой
         области. Если памяти в куче недостаточно, то  возни-
         кает ошибка периода исполнения.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         19- Heap overflow

СМ.ТАКЖЕ: GetMem, Mark, MemAvail, Release.


-----------------------------------------------------------
         ФУНКЦИЯ        Odd
-----------------------------------------------------------
ОПИСАНИЕ: function Odd (x:longint) : boolean

ДЕЙСТВИЕ: результатом функции является True, если x есть  не-
          четное число, и False - в противном случае.


-----------------------------------------------------------
         ФУНКЦИЯ        Ord
-----------------------------------------------------------
ОПИСАНИЕ: function Ord (x:OrdType) : longint

ПАРАМЕТРЫ: x- выражение любого упорядоченного типа.

ДЕЙСТВИЕ: результатом функции является порядковый номер  зна-
         чения аргумента.  Если  OrdType  есть  целочисленный
         тип, то Ord(x)=x.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: порядковые номера значений в  пере-
         числимых типах начинаются с нуля. Порядковые  номера
         значений целых типов совпадают с самими  значениями.
         Порядковый номер символа равен значению его кода AS-
         CII(0...255). Порядковые номера логических  констант
         False=0, а True=1. Порядковые номера значений отрез-
         ковых типов совпадают с их  порядковыми  номерами  в
         базовых типах.

СМ.ТАКЖЕ: Chr, преобразователь типа выражения.


-----------------------------------------------------------
         ФУНКЦИЯ        ParamCount
-----------------------------------------------------------
ОПИСАНИЕ: function ParamCount : word

ДЕЙСТВИЕ: результатом функции является число параметров в ко-
         мандной строке CP/M, с помощью которой была запущена
         программа.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: см.  дополнительные  замечания  для
         ф.ParamStr.

СМ.ТАКЖЕ: ParamStr.

ПРИМЕР: см. пример для ф.ParamStr.


-----------------------------------------------------------
         ФУНКЦИЯ        ParamStr
-----------------------------------------------------------
ОПИСАНИЕ: function ParamStr (i:word) : string

ДЕЙСТВИЕ: результат этой функции есть строка, содержащая i-ый
         параметр, переданный программе в командной строке.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: командная строка - это то,  что  вы
         набираете в ответ на приглашение CP/M к вводу коман-
         ды "А>". Командная строка имеет формат:

         имя-программы параметр-1 ... параметр-N

         Имя-программы от параметров и параметры друг от дру-
         га отделяются одним или несколькими пробелами и зна-
         ками табуляции. Имя-программы используется CP/M  для
         поиска программы на диске и  запуска  ее;  остальная
         часть командной строки передается  запущенной  прог-
         рамме и может быть использована по ее усмотрению (ОС
         располагает эту часть командной строки по адресу $80
         в формате string). Доступ к этой информации програм-
         ма может получить с помощью ф.ParamCount и ParamStr.
         Чтобы вы могли  отлаживать  программы,  использующие
         командную строку, запуская их с помощью команды  Run
         основного меню, вам предоставляется возможность  за-
         дать цодержимое командной строки с  помощью  команды
         Parameter String основного меню (здесь имя-программы
         указывать не нужно, только параметры).
         Если при обращении к функции ParamStr параметр i ра-
         вен 0 или превосходит  ParamCount,  то  возвращается
         пустая строка.

СМ.ТАКЖЕ: ParamCount.

ПРИМЕР:

{вывод на экран содержимого команды и строки}

program typeparm
var i: word
begin
   writeln ('Количество параметров ', paramcount);
   for i:=1 to paramcount
   do writeln (i, '-й параметр', paramstr(1));
end.

Если эту программу запустить командной строкой:
    TypePapm /x+ /Y- name1 name234
то на экране появится:
   1-й параметр /x+
   2-й параметр /y-
   3-й параметр name1
   4-й параметр name234


------------------------------------------------------------
         ФУНКЦИЯ        Pi
------------------------------------------------------------
ОПИСАНИЕ: function pi : real

ДЕЙСТВИЕ: результатом этой функции является число "пи" (равно
         3.14159265359).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: вы  можете  считать  ,что  Pi  есть
         константа - ни в каком месте программы отличие  фун-
         кции от константы не скажется.


------------------------------------------------------------
         ФУНКЦИЯ        Pos
------------------------------------------------------------
ОПИСАНИЕ: function Pos (substr, s:string) : byte

ДЕЙСТВИЕ: если строка substr является подстрокой строки s, то
         результат функции есть номер первого символа  самого
         левого вхождения подстроки substr в строку s; в про-
         тивном случае результат функции есть 0.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: номер первого символа строки есть 1

СМ.ТАКЖЕ: Concat, Copy, Delete, Insert, Length.

ПРИМЕР:

{эта процедура приписывает к имени файла расширение .txt,}
{если расширение отсутствовало                           }

procedure exttxt (var s:string);
   begin
         if pos('.',s) <> 0
         then s:=s+'.txt';
end;


------------------------------------------------------------
         ФУНКЦИЯ        Pred
------------------------------------------------------------
ОПИСАНИЕ: function Pred (x:OrdType) : OrdType

ПАРАМЕТРЫ: x- выражение любого упорядоченного типа.

ДЕЙСТВИЕ: результатом функции является  предшественник  аргу-
         мента, т.е. значение того же типа, что  и  аргумент,
         но с порядковым номером на 1 меньше.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: выражение pred(x), где x- выражение
         (упорядоченного) типа Type,  эквивалентно  выражению
         Type (Ord(x)-1), но вычисляется быстрее.

СМ.ТАКЖЕ: Dec,Inc, Succ.


------------------------------------------------------------
         ФУНКЦИЯ        Ptr
------------------------------------------------------------
ОПИСАНИЕ: function Ptr (a:word) : pointer

ДЕЙСТВИЕ: эта функция позволяет трактовать  целое  число  как
         указатель на переменную, расположенную по адресу а.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: тип результата есть  pointer,  т.е.
         нетипизированный указатель. Поэтому к нему  неприме-
         нима операция разыменования /\,  но  он  может  быть
         присвоен любой указательной переменной.

ПРИМЕР:

var p:/\byte;
begin
   p:=ptr($80);
   writeln ('длина строки параметров=', p/\);


------------------------------------------------------------
         ПРОЦЕДУРА      PutPixel
------------------------------------------------------------
ОПИСАНИЕ: procedure PutPixel (x,y:integer)

ДЕЙСТВИЕ: закрашивает точку с координатами (x,y) цветом,  ус-
          тановленным п.SetColor.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: координаты (x,y) могут выходить  за
         пределы экрана; в этом случае  никаких  действий  не
         выполняется.
         Координаты точек, присутствующих на экране: по гори-
         зонтали  (x-координата)  -  0...511,;  по  вертикали
         (y-координата) - 0...255.
         Точка в левом верхнем углу экрана  имеет  координаты
         (0,0).
         Вывод графической информации на экран  может  выпол-
         няться параллельно с выводом текста.
         Текст на цветном экране выводится белым  цветом,  на
         черно-белом - самым ярким цветом.

СМ.ТАКЖЕ: Circle, ClrGScr, GetPixel, Line, Rectangle,  SetCo-
          lor.


------------------------------------------------------------
         ФУНКЦИЯ        Random
------------------------------------------------------------
ОПИСАНИЕ: function Random [(range:integer)] : RT

ПАРАМЕТРЫ: range- необязательный параметр  -  выражение  типа
           integer.

ТИП РЕЗУЛЬТАТА: если параметр задан, то тип  результата  есть
          integer , иначе тип результата есть real.

ДЕЙСТВИЕ: если параметр не задан, то результат  функции  есть
         вещественное псевдослучайное число в диапазоне от  0
         до 1.
         Если параметр задан, то: если он  >0,  то  результат
         функции есть есть целое псевдослучайное число в  ди-
         апазоне 0...range-1; иначе результат функции есть 0.

ДОПОЛНИТЕЛЬНЫЕ  ЗАМЕЧАНИЯ:  генератор  псевдослучайных  чисел
         должен быть инициализирован с помощью  п.  Randomize
         или путем прямого присваивания  начального  значения
         предопределенной переменной  RandSeed  (типа  real).
         Текущее псевдослучайное число хранится в  переменной
         RandSeed; ее значение всегда находится  в  интервале
         0...1. Очередное псевдослучайное  число  вычисляется
         по формуле:

         rand(i+1)=Frac((rand(i)*133)+0.71093901315)

         Целое псевдослучайное число в диапазоне 0 ...  range
         получается из вещественного по формуле:

         int-rand=Trunc(range*rand)

СМ.ТАКЖЕ: Randomize

ПРИМЕР:

{мигающие звезды}

begin
   Randomize;
   repeat
         gotoxy (random(64), random(16));
         write ('*'); delay (200);      {зажгли звезду}
         gotoxy (random(64), random(16));
         write (' '); delay (200);      {погасили звезду}
   until False;
end.


------------------------------------------------------------
         ПРОЦЕДУРА      Randomize
------------------------------------------------------------
ОПИСАНИЕ: procedure Randomize

ДЕЙСТВИЕ: инициализируется  датчик  псевдослучайных  чисел  -
         присваивается начальное значение переменной RandSeed

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: начальное значение датчика псевдос-
         лучайных чисел формируется по времени, прошедшему от
         момента запуска этой процедуры до ближайшего  преры-
         вания по частоте 50 гц -  поэтому  время  выполнения
         этой процедуры может доходить до 20 млс.
         Выполнить инициализацию датчика псевдослучайных  чи-
         сел можно также путем присваивания какого-либо числа
         в диапазоне от 0 до  1  предопределенной  переменной
         RandSeed (типа real). Если вам нужно повторять  одну
         и ту же последовательность псевдослучайных чисел, то
         следует воспользоваться этим методом.

СМ.ТАКЖЕ: Random.


------------------------------------------------------------
         ПРОЦЕДУРА      Read    (типизированные файлы)
------------------------------------------------------------
ОПИСАНИЕ: procedure Read (var f:FileOfType;
                                [var v1, .., vN : Type])

ПАРАМЕТРЫ: f- типизированная файловая переменная (т.е.  пере-
         менная , тип которой есть file of type)
         v1, ..., vN - переменные типа Type (т.е. их тип дол-
         жен быть базовым типом f). Список переменных v1...vN
         мы называем списком ввода.

ДЕЙСТВИЕ: если список ввода пуст, то  никаких  содержательных
         действий по вводу не выполняется - однако диагности-
         руются ошибки обращения 8 и 9 (если они имеются).
         Если список ввода не пуст, то из  файла  читаются  N
         записей, и заносятся  последовательно  в  переменные
         v1...vN. Чтение записей из файла начинается с  теку-
         щей позиции; после чтения каждой записи текущая  по-
         зиция продвигается на 1 запись вперед. Если  достиг-
         нут конец файла (Eof(f)=True), а список ввода еще не
         исчерпан, то возникает ошибка 1.
         Размер типизированного файла определяется  по  числу
         записей, записанному в начале файла - а не по  физи-
         ческому размеру файла; подробнее о структуре типизи-
         рованного файла см. главу 10.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data.
         8- ASSIGN was not executed.
         9- File not open.
         11- File write only.

         В режиме {$1-} ошибка 1 не диагностируется немедлен-
         но, но может быть обработана с  помощью  ф.IOResult;
         ошибки 8, 9, и 11 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Write.

ПРИМЕР: эта программа корректирует файл  DATA.DAT.  Файл  DA-
        TA.DAT создан другой программой как file  of  real  и
        всегда содержит ровно 1000 чисел. Настоящая программа
        считывает файл в память, вносит в него  изменения,  и
        затем перезаписывает файл на диске.

var f:file of real;
   i:word;
   xx:array [1...100] of real;
begin
   assign (f,'data.dat');       {считывание файла в память}
   reset (f);
   if filesize(f) <> 1000
   then begin
         writeln ('??? неправильное количество записей',
                        'в data.dat');
         halt;
   end;
for i:=1 to 1000
do read (f, xx[i]);
close(f);
                        {обработка данных}
.......................
                        {перезапись файла на диск}

rewrite(f);
for i:=1 to 1000
do write (f,xx[i]);
close (f);
end.
































































































































----------------------------------------------------------
         ПРОЦЕДУРА      READ (текстовые файлы)
----------------------------------------------------------
ОПИСАНИЕ: procedure Read [([var f:Text;][var v1,...,vN])]

ПАРАМЕТРЫ: f- файловая переменная типа Text; если этот  пара-
         метр  опущен,  то  подразумевается  предопределенная
         файловая переменная типа Input.
         v1...vN - переменные типов char, shortint, byte, in-
         teger, word, longint, real или строковых типов.
         Список переменных v1...vN мы называем списком ввода.

ДЕЙСТВИЕ: если список ввода пуст, то  никаких  содержательных
         действий по вводу не выполняется - однако диагности-
         руются ошибки обращения 8 и 9 (если они имеются).
         Если список ввода не пуст, то  из  файла  последова-
         тельно читаются N значений и заносятся в  переменные
         v1...vN. При чтении значений из текстового файла вы-
         полняются форматные  преобразования.  Эти  форматные
         преобразования подробно описаны в разделе 4.1. главы
         10.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data.
         8- ASSIGN was not executed.
         9- File not open.
         11- File write only.
         15- Invalid number format.

         В режиме {$1-} ошибки 1 и 15 не диагностируются  не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8,9,11 всегда диагностируются немедлен-
         но.

СМ.ТАКЖЕ: Readln, Write, Writeln.

ПРИМЕР: программа решения квадратного уравнения. Эта програм-
        ма вводит коэффициенты уравнения с клавиатуры и выво-
        дит результаты на экран.

var a,b,c,d,d1:real;
begin
   writeln ('*** решение квадратного уравнения ***');
   write (' введите коэффициенты a,b,c: ');
   read (a,b,c);

   if a=0
   then writeln ('это не квадратное уравнение');
   d:=sqr(b) - 4a*c; d1:=sqrt(abs(d));
   if d >= 0
   then begin
         writeln ('вещественные корни:');
         writeln ((-b+d1)/(2*a):20,
                        (-b-d1)/(2*a):20);
   end;
   else writeln ('вещественных корней нет');
end.


-----------------------------------------------------------
         ФУНКЦИЯ        ReadKey
-----------------------------------------------------------
ОПИСАНИЕ: function ReadKey : char

ДЕЙСТВИЕ: результатом этой функции является очредной  введен-
         ный с клавиатуры символ. Если перед вызовом  ReadKey
         значение KeyPressed есть True, то результат  возвра-
         щается немедленно, иначе  функция  ожидает  ввода  с
         клавиатуры символа.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: введенный символ удаляется из буфе-
         ра клавиатры; следующее обращение к ф.ReadKey приве-
         дет к чтению следующего символа.
         Введенный символ на экране не отображается. Формиро-
         вание ASCII-кода для буквенно-цифровых символов  вы-
         полняется в зависимости от  состояния  клавиатуры  и
         того, какие клавиши-модификаторы  прижаты  в  данный
         момент - по тем правилам, которые описаны в гл.1 и 3
         ASCII-код для управляющих клавиш формируется вне за-
         висимости от состояния клавиатуры  и  прижатых  кла-
         виш-модификаторов по таблице:

         Esc    1bh             Stop    03h
         Tab    09h             Del     7fh
         Cr     0dh             Ins     12h
         Bs     08h             Cls     0ch

         Для клавиш дополнительной клавиатуры:

         2      1fh                6    1ch
         4      1dh                8    1eh

         Для любой другой управляющей клавиши формируется AS-
         CII-код 0. Если в вашей программе необходимо исполь-
         зовать такие  клавиши,  то  следует  воспользоваться
         п.ReadKeyExt.

СМ.ТАКЖЕ: KeyPressed, ReadKeyExt.

ПРИМЕР:

{очистка буфера клавиатуры}

procedure clearkbdbuf;

var c:char;
begin
   while keypressed do c:=readkey;
end;


-----------------------------------------------------------
         ПРОЦЕДУРА      ReadKeyExt
-----------------------------------------------------------
ОПИСАНИЕ: procedure ReadKeyExt (var a,s,m:byte)

ПАРАМЕТРЫ: все параметры этой процедуры  являются  выходными,
         т.е. процедура заносит в них результаты своей  рабо-
         ты, а исходное значение их несущественно.

ДЕЙСТВИЕ: аналогично дествию ф.ReadKey, возвращает больше ин-
         формации. Именно, в переменные-параметры заносится:
         а- ASCII-код (то, что выдает  ф.ReadKey  в  качестве
         результата);
         s- скан-код нажатой клавиши;
         m- байт с флагами нажатых клавиш-модификаторов.
         Скан-коды можно найти в документации на ПЭВМ.
         Каждой клавише-модификатору в байте m  соответствует
         1 бит; маски для выделения битов:

         01h    левый Shift
         02h    Alph
         04h    Graf
         10h    Sel
         20h    Ctrl
         40h    Fix
         80h    правый Shift
         (бит с маской 08h не используется)

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: использование этой процедуры позво-
         ляет вашей программе различать нажатие основной кла-
         виши в сочетании  с  наборами  клавиш-модификаторов,
         которые не различаются стандартным алгоритмом форми-
         рования ASCII-кода.
         Отдельные нажатия клавиш-модификаторов не  обнаружи-
         ваются ни п.ReadKeyExt,  ни  ф.KeyPressed,  ReadKey:
         например, если вы нажмете клавишу Shift и  отпустите
         ее не нажав другой клавиши, то с помощью этих проце-
         дур вы о таком событии ничего не узнаете.

СМ.ТАКЖЕ: KeyPressed, ReadKey.


-----------------------------------------------------------
         ПРОЦЕДУРА      Readln
-----------------------------------------------------------
ОПИСАНИЕ: prgcedure Readln [([var f:Text;][var v1,...,vN])]

ПАРАМЕТРЫ: f- файловая переменная типа Text; если этот  пара-
         метр  опущен,  то  подразумевается  предопределенная
         файловая переменная Input.
         v1,...,vN- переменные типов  char,  shortint,  byte,
         integer, word, logint, real или строковых типов.
         Список переменных v1,...,vN мы называем списком вво-
         да.

ДЕЙСТВИЕ: если список ввода пуст, то выполняется пропуск  ли-
         тер до конца текущей  строки  включительно  (или  до
         конца файла, если он будет достигнут раньше).
         Если список ввода не пуст, то выполняются те же дей-
         ствия, что и при выполнении п.Read, и затем  пропус-
         каются литеры до конца текущей  строки  включительно
         (или до конца файла, если он будет  достигнут  рань-
         ше).
         Обратите внимание на то, что в результате одного вы-
         зова п.Readln может быть прочитано  несколько  строк
         файла: если в списке ввода есть числовые переменные,
         то при их чтении пропускаются предшествующие  разде-
         лители, среди которых могут оказаться маркеры  конца
         строки.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data.
         8- ASSIGN was not executed.
         9- File not open.
         11- File write only.
         15- Invalid number format.

         В режиме {$I-} ошибки 1 и 15 не диагностируются  не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8,9,11 всегда диагностируются немедлен-
         но.

СМ.ТАКЖЕ: Read, SeekEof, SeekEoln, Write, Writeln.

ПРИМЕРЫ: см. пример для п.Read (текстовые файлы).



------------------------------------------------------------
         ПРОЦЕДУРА      Rectangle
------------------------------------------------------------
ОПИСАНИЕ: procedure Rectangle (x1, y1, x2, y2:integer;
                                fill:boolean)

ДЕЙСТВИЕ: рисует прямоугольник, два противоположных угла  ко-
         торого имеют  координаты  (x1,y1)  и  (x2,y2)  соот-
         ветственно. Если последний параметр (fill) есть Fal-
         se, то рисуется контур прямоугольника; если он  есть
         True, то рисуется заполненный прямоугольник.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если координаты  одного  или  обоих
         углов прямоугольника лежат вне экрана,  то  рисуется
         часть прямоугольника.
         Учитывайте, что точки на экране не являются квадрат-
         ными, и поэтому то, что появится на экране в резуль-
         тате выполнения:

         Rectangle (c,0,0,100,100, False)

         не будет квадратом.
         Цвет изображения задает п.SetColor.

СМ.ТАКЖЕ: Circle, ClrGScr, GetPixel, Line, PutPixel,SetColor


------------------------------------------------------------
         ПРОЦЕДУРА      Release
------------------------------------------------------------
ОПИСАНИЕ: procedure Release (var p: pointer)

ДЕЙСТВИЕ: процедура удаляет из кучи все динамические перемен-
         ные, созданные п.GetMem, New после последнего вызова
         п.Mark с параметром p.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: нормально параметр p для  п.Release
         подготавливается п.Mark; однако он может быть подго-
         товлен и с помощью оператора присваивания:

         p:=HeapPtr

         (выполнение которого эквивалентно выполнению п.Mark)
         В свою очередь, вызов п.Release(p) эквивалентен опе-
         ратору присваивания

         HeapPtr:=p

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         20- Invalid heap operation.

СМ.ТАКЖЕ: GetMem, Mark, MemAvail, New.


------------------------------------------------------------
         ПРОЦЕДУРА      Rename
------------------------------------------------------------
ОПИСАНИЕ: procedure Rename (var f; newname:string)

ПАРАМЕТРЫ: f- переменная любого файлового типа
           newname- строковое выражение, задающее  новое  имя
           файла.

ДЕЙСТВИЕ: внешний дисковый файл, связанный п.Assign с  файло-
         вой переменной f, получает новое имя newname.
         Новое имя файла в  переменной  newname  должно  быть
         оформлено по тем же правилам, что и  имя  файла  при
         обращении к п.Assign с  той  разницей,  что  оно  не
         должно содержать обозначение дисковода и имени поль-
         зователя (и отделяющего их от имени двоеточия).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл не  должен  быть  открыт.  Эта
         процедура имеет смысл только  для  дисковых  файлов.
         Для файлов на устройствах она допустима, но не  ока-
         зывает никакого действия.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         4- File not found.
         5- Disk read only.
         6- File read only.
         8- ASSIGN was not executed.
         10- File is open.

         В режиме {$I-} ошибки 4,5,6,не  диагностируются  не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8,10 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Assign, Erase.

ПРИМЕР:

{замена расширения ".doc" на расширение ".txt"}

var f:file;
   name:string[16];

begin
   write ('имя файла:'); readln (name);
   assign (f, name+'.doc');
   rename (f, name+'.txt');
end.


------------------------------------------------------------
         ПРОЦЕДУРА      Reset
------------------------------------------------------------
ОПИСАНИЕ: procedure Reset (var f; [RecSize :word])

ПАРАМЕТРЫ: f- файловая переменная любого типа
         RecSize- выражение типа  word;  может  быть  указано
         только если f- нетипизированная файловая переменная.

ДЕЙСТВИЕ: внешний файл, связанный ранее с файловой переменной
         f п.Assign , открывается. Текущая позиция устанавли-
         вается перед первой записью файла.
         Если файл был открыт, то он предварительно  закрыва-
         ется, а затем открывается вновь.
         Необязательный параметр RecSize  может  быть  указан
         только для нетипизированных файлов; он задает  длину
         записи в байтах. Если  для  нетипизированного  файла
         параметр RecSize опущен, то длина записи  устанавли-
         вается равной 128 байт.  Для  типизированных  файлов
         длина записи  автоматически  устанавливается  равной
         длине компоненты файла; для текстовых файлов - 1.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если открывается дисковый файл,  то
         он должен существовать; если файл на диске не  будет
         найден, то возникает ошибка 4.
         Файл, открытый на диске с помощью п.Reset,  доступен
         и для чтения и для записи -  за  исключением  случая
         текстового файла; текстовый файл, открытый п.Reset ,
         доступен только для чтения.
         П.Reset можно  открыть  файл  на  любом  устройстве,
         кроме "LST:"- при такой попытке возникает ошибка 12.
         Файл на любом устройстве, открытый п.Reset ,  досту-
         пен только для чтения.
         Если п.Reset открывается типизированный файл на дис-
         ке, то он должен содержать по крайней мере 6 байт (2
         первых байта должны содержать длину записи в формате
         word, и 4 следующих - количество записей в  файле  в
         формате longint). При этом  проверяется,  что  длина
         записи, указанная в файле, совпадает с длиной  запи-
         си, задаваемой типом файловой переменой, и что физи-
         ческий размер файла не  меньше  размера,  требуемого
         для размещения указанного в начале файла  количества
         записей.
         Если хотя бы одно из перечисленных условий не выпол-
         нено, возникает ошибка 14.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         4- File not found.
         8- ASSIGN was not executed.
         12- Reset not allowed.
         14- Invalid file format.

         В режиме {$I-} ошибки 4 и 14 не диагностируются  не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8 и 12 всегда диагностируются немедлен-
         но.

СМ.ТАКЖЕ: Append, Assign, Rewrite.


------------------------------------------------------------
         ПРОЦЕДУРА      Rewrite
------------------------------------------------------------
ОПИСАНИЕ: procedure Rewrite (var f; [RecSize : word])

ПАРАМЕТРЫ: f- файловая переменная любого типа
         RecSize- выражение типа  word;  может  быть  указано
         только если f- нетипизированная файловая переменная.

ДЕЙСТВИЕ: в случае дискового файла:  создается  новый  пустой
         файл с именем, связанным ранее с файловой переменной
         f п.Assign. В случае  файла  на  устройстве  никаких
         действий  не  выполняется  (только  подготавливается
         файловая переменная). В любом случае этот  файл  от-
         крывается.
         Текущая позиция устанавливается в начале вновь  соз-
         данного пустого файла. Если файл был открыт,  то  он
         предварительно закрывается.
         Необязательный параметр RecSize  может  быть  только
         указан для нетипизированных файлов; он задает  длину
         записи в байтах. Если  для  нетипизированного  файла
         параметр RecSize опущен, то длина записи  устанавли-
         вается равной 128 байт. Для типизированных файл дли-
         на записи автоматически устанавливается равной длине
         компоненты файла; для текстовых файлов - 1.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если дисковый файл уже существовал,
         то он предварительно уничтожается.
         Файл, открытый на диске с помощью п.Rewrite,  досту-
         пен и для чтения и для записи - за исключеним случая
         текстового файла; текстовый файл, открытый п.Rewrite
         доступен только для записи.
         П.Rewrite можно открыть файл  на  любом  устройстве,
         кроме "KBD:" - при такой  попытке  возникает  ошибка
         13. Файл на любом  устройстве,  открытый  п.Rewrite,
         доступен только для записи.
         После выполнения Rewrite(f) ф.Eof(f) выдает True.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         2- Disk full.
         3- Directory full.
         5- Disk read only.
         6- File read only.
         8- Assign was not executed.
         13- Rewrite or Append not allowed.

         В режиме {$I-} ошибки 2,3,5,6 не диагностируются не-
         медленно, но могут быть обработаны п.IOResult; ошиб-
         ки 8 и 13 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Append, Assign, Reset.


------------------------------------------------------------
         ФУНКЦИЯ        Round
------------------------------------------------------------
ОПИСАНИЕ: function Round (x:real) : longint

ДЕЙСТВИЕ: результатом функции является ближайщее к аргументу-
         целое число. Если  значение  аргумента  находится  в
         точности посредине между двумя  целыми  числами,  то
         результатом будет число с большей абсолютной величи-
         ной. Например:

         round (2.127)=2
         round (-2.127)=-2
         round (12.5)=13
         round (-12.5)=-13

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если результат  превосходит  макси-
         мальное представимое в формате longint значение,  то
         возникает ошибка 16.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         16- Invalid argument.

СМ.ТАКЖЕ: Int, Trunc.


------------------------------------------------------------
         ПРОЦЕДУРА      Seek
------------------------------------------------------------
ОПИСАНИЕ: procedure Seek (var f; pos:longint)

ПАРАМЕТРЫ: f- переменная любого файлового типа
         pos- выражение типа longint.

ДЕЙСТВИЕ: текущая позиция в файле устанавливается  перед  за-
         писью с номером pos (первая запись файла имеет номер
         0).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: записью считается: для  нетипизиро-
         ванных файлов - группа байт в количестве,  указанном
         при открытии файла; для типизированных файлов - ком-
         понента файла; для текстовых файлов - 1  байт.  Если
         значение pos отрицательно, то оно  считается  равным
         0. Если значение pos превосходит  размер  файла,  то
         текущая позиция устанавливается  на  конец  файла  и
         возникает ошибка 1 (то, что текущая позиция  в  этом
         случае устанавливается на конец  файла,  может  быть
         использовано только в том случае, если вы  обрабаты-
         ваете ошибки с помощью ф.IOResult).
         Для установки текущей позиции в  конец  файла  можно
         использовать вызов:

         Seek (f, FileSize(f) )

         Эта процедура  вызывает  изменение  текущей  позиции
         только для файлов на диске; для  файлов  на  устрой-
         ствах никаких действий невыполняется.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data.
         8- Assign was not executed.
         9- File not open.

         В режиме {$I-} ошибка 1 не диагностируется немедлен-
         но, но может быть обработана с  помощью  ф.IOResult;
         ошибки 8, 9 всегда диагностируются немедленно.

СМ.ТАКЖЕ: FilePos, FileSize.

ПРИМЕР:

{корректировка файла DATA iz вещественных чисел}

var f:file of real;
    x:real;
    p:longint;
    z:byte;

begin
   assign (f, 'DATA'); reset(f);
   while true
   do begin
         write ('введите позицию:'); readln(p);
         if p<0                         {признак конца}
         then begin     close(f); halt; end;
         seek (f,p); z:=ioresult;  {сброс возможной ошибки}
         if eof(f)
         then write ('новое число')
         else begin
                read(f,x);
                write (x, 'измените:');
                seek(f,p);
         end;
         readln (x); write(f,x);
   end;
end.


------------------------------------------------------------
         ФУНКЦИЯ        SeekEof
------------------------------------------------------------
ОПИСАНИЕ: function SeekEof [(var f:text)] : boolean

ПАРАМЕТРЫ: f- файловая переменная типа text; если этот  пара-
         метр опущен, то подразумевается предопределенная пе-
         ременная Input.

ДЕЙСТВИЕ: процедура пропускает  пробелы,  знаки  табуляции  и
         маркеры конца строки. После этого  возвращается  ре-
         зультат True, если  текущая  позиция  оказывается  в
         конце файла, и FAlse в противном случае.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл дожен быть открыт.
         Маркер конца строки есть последовательность символов
         Cr и Lf, либо одиночные символы Cr и Lf (0dh  и  0ah
         соответственно). Эта функция полезна при чтении  чи-
         сел из текстовых файлов.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- READING unwritten data.
         8- Assign was not executed.
         9- File not open.
         11- File write only.

         В режиме {$I-} ошибка 1 не диагностируется немедлен-
         но, но может быть  обработана  ф.  IOResult;  ошибки
         8,9,11 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Eof, Eoln, SeekEoln.


------------------------------------------------------------
         ФУНКЦИЯ        SeekEoln
------------------------------------------------------------
ОПИСАНИЕ: function SeekEoln [(var f:text)] : boolean

ПАРАМЕТРЫ: f- файловая переменная типа text; если этот  пара-
         метр  опущен,  то  подразумевается  предопределенная
         файловая переменная Input.

ДЕЙСТВИЕ: процедура пропускает  пробелы  и  знаки  табуляции.
         После этого возвращается результат True, если  теку-
         щая позиция оказывается в конце  файла,  и  False  в
         противном случае.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.  Эта  фун-
         кция полезна при чтении чисел из текстовых файлов.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         1- Reading unwritten data.
         8- Assign was not executed.
         9- File not open.
         11- File write only.

         В режиме {$I-} ошибка 1 не диагностируется немедлен-
         но, но  может  быть  обработана  ф.IOResult,  ошибки
         8,9,11,всегда диагностируются немедленно.

СМ.ТАКЖЕ: Eof, Eoln, SeekEof.


------------------------------------------------------------
         ПРОЦЕДУРА      SetColor
------------------------------------------------------------
ОПИСАНИЕ procedure SetColor (color:byte)

ДЕЙСТВИЕ: устанавливает цвет  изображения,  используемый  при
         выводе на графический  экран  п.Circle,  Line,  Put-
         Pixel, Rectangle.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: кодировка цветов:
         0- черный
         1- синий
         2- зеленый
         3- голубой
         4- красный
         5- фиолетовый
         6- желтый
         7- белый

         На черно-белом экране  цвета  передаются  градациями
         яркости; яркость  возрастает  при  возрастании  кода
         цвета.
         Если значение параметра превосходит значение  7,  то
         используется значение (color mod 8).
         Вывод графической информации на экран  может  выпол-
         няться параллельно с выводом  текстовой  информации.
         Текстовая информация на цветном экране выводится бе-
         лым цветом, на черно-белом - самым ярким цветом.

СМ.ТАКЖЕ: Circle, ClrGScr, GetPixel, Line, PutPixel,  Rectan-
          gle.


------------------------------------------------------------
         ФУНКЦИЯ        Sin
------------------------------------------------------------
ОПИСАНИЕ: function Sin (x:real) : real

ДЕЙСТВИЕ: вычисляется синус аргумента.  Аргумент  задается  в
          радианах.


------------------------------------------------------------
         ФУНКЦИЯ        SizeOf
------------------------------------------------------------
ОПИСАНИЕ: function SizeOf (x) : word

ПАРАМЕТРЫ: x- ссылка на переменную или идентификатор типа.

ДЕЙСТВИЕ: результат функции есть размер области памяти, зани-
         маемой переменной x, или значением типа x.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: ф.SizeOf рекомендуется использовать
         для указания длины поля при вызове п.FillChar,  Get-
         Mem, Move.



------------------------------------------------------------
         ФУНКЦИЯ        Sqr
------------------------------------------------------------
ОПИСАНИЕ: function Sqr (x:NumTipe) : NymTipe

ПАРАМЕТРЫ: x- выражение  любого числового типа.

ТИП РЕЗУЛЬТАТА: определяется по  общим  правилам  определения
        типа выражения x*x.

ДЕЙСТВИЕ: вычисляется квадрат аргумента.



------------------------------------------------------------
         ФУНКЦИЯ        Sqrt
------------------------------------------------------------
ОПИСАНИЕ: function Sqrt (x:real) : real

ДЕЙСТВИЕ: вычисляется квадратный корень из аргумента.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если значение аргумента  меньше  0,
          то возникает ошибка "недопустимый аргумент".

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         16- Inwalid argument.



------------------------------------------------------------
         ПРОЦЕДУРА      Str
------------------------------------------------------------
ОПИСАНИЕ:  procedure  Str   (x   [:width   [:decimals];   var
                                              s:string])

ПАРПМЕТРЫ: x- выражение числового типа;
         width- выражение типа byte (необязательный параметр)
         - задает количество позиций, отводимое на  строковое
         представление x;
         decimals- выражение  типа  shortint  (необязательный
         параметр; может быть задан, только если задан  пара-
         метр width и выражение x имеет тип  real)  -  задает
         количество десятичных знаков в строковом представле-
         нии x.

ДЕЙСТВИЕ: значение x преобразуется в строковое  представление
         в соответствии с параметрами форматв width  и  deci-
         mals. Действие п.Str совпадает с  действием  п.Write
         для текстовых файлов с тем отличием, что  полученное
         строковое представление заносится в строку s,  а  не
         записывается в текстовый файл.

ДОПОЛНИТЕЛЬНЫЕ  ЗАМЕЧАНИЯ:  если   сформированное   строковое
         представление занимает больше  позиций,  чем  размер
         строки s, то правые символы откидываются.

СМ.ТАКЖЕ: Val, Write.


------------------------------------------------------------
         ФУНКЦИЯ        Succ
------------------------------------------------------------
ОПИСАНИЕ: function Succ (x:OrdType) : OrdType

ПАРАМЕТРЫ: x- выражение любого упорядоченного типа.

ТИП РЕЗУЛЬТАТА: совпадает с типом аргумента.

ДЕЙСТВИЕ: результатом функции является последователь аргумен-
та, т.е. значение того же типа, что и аргумент, но с порядко-
вым номером на 1 больше.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: выражение Succ(x), где x- выражение
         упорядоченного типа Type, эквивалентно выражению Ty-
         pe(Ord(x)+1), но вычисляется быстрее.

СМ.ТАКЖЕ: Dec, Inc, Pred.



------------------------------------------------------------
         ФУНКЦИЯ          Swap
------------------------------------------------------------
ОПИСАНИЕ: function Swap (x:intword) : intword

ПАРАМЕТРЫ: x- выражение типа integer или word.

ТИП РЕЗУЛЬТАТА: совпадает с типом аргумента.

ДЕЙСТВИЕ: результат функции является  словом,  полученным  из
         слова-аргумента перестановкой мл. и ст. байтов.

СМ.ТАКЖЕ: Hi, Lo.


------------------------------------------------------------
         ФУНКЦИЯ        Trunc
------------------------------------------------------------
ОПИСАНИЕ: function Trunc (x:real) : longint

ДЕЙСТВИЕ: результатом функции является целое  число,  получа-
         емое из аргумента путем округления его по  направле-
         нию к 0.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: если результат  превосходит  макси-
         мальное представимое в формате longint значение,  то
         возникает ошибка 16.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         16- Invalid argument.

СМ.ТАКЖЕ: Int, Round.


------------------------------------------------------------
         ПРОЦЕДУРА      Truncate
------------------------------------------------------------
ОПИСАНИЕ: procedure Truncate (var f)

ПАРАМЕТРЫ: f- переменная любого файлового типа.

ДЕЙСТВИЕ: все записи файла, находящиеся после  текущей  пози-
         ции, удаляются из файла.

ДОПОЛНИТЕЛЬНЫЕ  ЗАМЕЧАНИЯ:  ввиду  ограниченных  возможностей
         CP/M эта процедура выполняется только для  типизиро-
         ванных файлов на диске; во  всех  остальных  случаях
         никаких действий не выполняется.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         8- Assign was not executed.
         9- File nоt open.

         Эти ошибки всегда приводят к прекращению  выполнения
         программы, независимо от того, какой режим -  {$I..}
         установлен.

СМ.ТАКЖЕ: FilePos, FileSize, Seek.


------------------------------------------------------------
         ФУНКЦИЯ        UpCase
------------------------------------------------------------
ОПИСАНИЕ: function UpCase (c:char) : char

ДЕЙСТВИЕ: если  аргументом  функции  является  латинская  или
         русская строчная буква, то результатом  будет  соот-
         ветствующая прописная буква; иначе результат функции
         совпадает с ее аргументом.



------------------------------------------------------------
         ПРОЦЕДУРА      Val
------------------------------------------------------------
ОПИСАНИЕ: procedure Val (s:string; var v; var c:word)

ПАРАМЕТРЫ: s- выражение строкового типа
         v- переменная числового типа
         c- переменная типа word

ДЕЙСТВИЕ: содержимое строки s рассматривается как  символьная
         запись числа типа переменной v. Содержимое строки  s
         преобразуется в числовой формат и заносится в  пере-
         менную v. Преобразование числа из символьного  пред-
         ставления выполняется по тем же правилам, что и  при
         выполнении п.Read.
         Если в числе обнаруживается ошибка, то номер первого
         ошибочного символа заносится в c; содержимое v вэтом
         случае не определено. Если ошибок нет, то в c  зано-
         сится 0.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: значение строкового выражения  мо-
         жет содержать ведущие пробелы и знаки табуляции,  но
         не должно содержать таковые после числа.

СМ.ТАКЖЕ: Read, Str.


------------------------------------------------------------
         ПРОЦЕДУРА      Write   (типизированные файлы)
------------------------------------------------------------
ОПИСАНИЕ: procedure Write (var f:FileOfType;
                                [var v1,...,vN:Type])

ПАРАМЕТРЫ: f- типизированная файловая переменная (т.е.  пере-
         менная, тип которой есть file of type).
         v1,...,vN - переменные типа type (т.е. их тип должен
         быть базовым типом f). Список переменных v1...vN  мы
         называем списком ввода.

ДЕЙСТВИЕ: если список вывода пуст, то никаких  содержательных
         действий по выводу не выполняется - однако  диагнос-
         тируются ошибки обращения 8 и 9 (если они имеются).
         Если список вывода не пуст, то в файл записывается N
         записей - содержимое переменных  v1...vN.  Очередная
         запись записывается в текущую позицию;  после  этого
         текущая позиция продвигается на 1 запись вперед. Ес-
         ли текущая позиция находится в конце файла, то  файл
         расширяется. Иначе новая запись заменяет присутству-
         ющую в файле.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         2- Disk full.
         3- Directory full.
         5- Disk read only.
         6- File read only.
         8- Assign was not executed.
         9- File not open.

         В режиме {$I-} ошибки 2,3,5,6 не диагностируются не-
         медленно, но могут быть обработаны с помощью п.IORe-
         sult; ошибки 8 и 9 всегда диагностируются немедленно

СМ.ТАКЖЕ: Read.

ПРИМЕР: см. пример для п. Read.


-----------------------------------------------------------
         ПРОЦЕДУРА      Write   (текстовые файлы)
-----------------------------------------------------------
ОПИСАНИЕ: procedure Write [([var f:text] v1...vN)]

ПАРАМЕТРЫ: f- файловая переменная типа text; если этот  пара-
         метр  опущен,  то  подразумевается  предопределенная
         файловая переменная Output.
         v1...vN - список вывода. Каждый элемент списка имеет
         формат:

         expr [:width [:decimals]]

         где expr- выражение типа char, shortint, byte, inte-
         ger, word, longint, real или строкового типа;
         width и decimals- выражения типа byte (width и deci-
         mals есть спецификаторы формата вывода).

ДЕЙСТВИЕ: если список вывода пуст, то никаких  содержательных
         действий по выводу не выполняется - однако  диагнос-
         тируются ошибки обращения 8 и 9 (если они имеются).
         Если список вывода не пуст, то значения выражений
         из списка вывода преобразуются в строковый вид и за-
         писываются в файл. Формальные преобразования при вы-
         воде в текстовый файл описаны в  разделе  4.2  главы
         10.

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         2- Disk full.
         3- Directory full.
         5- Disk read only.
         6- File read only.
         8- Assign was not executed.
         9- File not open.

         В режиме {$I-} ошибки 2,3,5,6 не диагностируются не-
         медленно  ,  но  могут  быть  обработаны  с  помощью
         ф.IOResult; ошибки 8 и 9 всегда диагностируются  не-
         медленно.

СМ.ТАКЖЕ: Read, Readln, Writeln.


-----------------------------------------------------------
         ПРОЦЕДУРА      Writeln
-----------------------------------------------------------
ОПИСАНИЕ: procedure Writeln [([var f:text;] [v1,...,vN])]

ПАРАМЕТРЫ: f- файловая переменная типа text; если этот  пара-
         метр  опущен,  то  подразумевается  предопределенная
         файловая переменная Output.
         v1...vN - список вывода. Каждый элемент списка имеет
         формат:

         expr [:width [:decimals]]

         где expr- выражение типа char, shortint, byte, inte-
         ger, word, longint, real или строкового типа;
         width и decimals- выражения типа byte (width и deci-
         mals есть спецификаторы формата вывода).

ДЕЙСТВИЕ: действие п.Writeln полностью совпадает с  действием
         п.Write с тем дополнением,  что  после  вывода  всех
         значений из списка  вывода  выводится  маркер  конца
         строки - символы Cr и Lf (0dh и 0ah соответственно).

ДОПОЛНИТЕЛЬНЫЕ ЗАМЕЧАНИЯ: файл должен быть открыт.

ВОЗМОЖНЫЕ ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ:
         2- Disk full.
         3- Directory full.
         5- Disk read only.
         6- File read only.
         8- Assign was not executed.
         9- File not open.

         В режиме {$I-} ошибки 2,3,5,6 не диагностируется не-
         медленно, но могут быть обработаны с помощью ф.IORe-
         sult; ошибки 8,9 всегда диагностируются немедленно.

СМ.ТАКЖЕ: Read, Readln, Write.










































































































































                                        ПРИЛОЖЕНИЕ А.


   Нам удалось добиться практически полной  совместимости  по
входному языку с системой Turbo  Pascal  v.4.0.  В  настоящем
приложении мы описываем имеющиеся  отличия.  Они  в  основном
связаны с машинно-зависимыми деталями языка.


1. Ограничения по сравнению с языком Turbo  Pascal  v.4.0.

* работа с кучей возможна только по стековой  дисциплине  (п.
FreeMem, Dispose отсутствуют; для освобождения  памяти  может
быть использована только п.Release).

* рекурсивные процедуры и функции не могут иметь  параметров,
передаваемых по ссылке.

* невозможно описание процедур и функций как external или in-
terrupt.


2. Расширения по сравнению с языком Turbo  Pascal  v.4.0.

* во всех местах,где по синтаксису Паскаля требуются констан-
ты, допускаются константные выражения.

* в absolute-конструкции  и  в  элементах  inline-  оператора
вместо идентификаторов  переменных  допускаются  произвольные
статические ссылки на переменную.

* тип результата функции может быть типом множества.

* в качестве  управляющей  переменной  for-цикла  допускается
произвольная статическая ссылка на переменную.

* в идентификаторах все литеры (до 127) являются значимыми.

* нет ограничения на максимальное число процедур и функций  в
программе.

* приостановка и прерывание работы Паскаль-программы возможны
не только в моменты выполнения ею  операций  ввода-вывода  на
консоль, но в любой момент времени  (кроме  изменения  работы
системы обработки прерываний).


3. Отличия , определяемые отличиями в оборудовании и в ОС.

* ввиду отсутствия математического сопроцессора типа 8087,  в
EP не реализованы соответствующие типы данных (single,  doub-
le, extended, comp).

* все адреса (и индексы массива Mem) задаются как целые числа
в диапазоне от 0 до 2*16-1 - а не как пары чисел Seg:Ofs.

* отсутствуют или модифицированы процедуры и функции, обеспе-
чивающие обращения к ОС.



                                        ПРИЛОЖЕНИЕ Б.


         СООБЩЕНИЯ ОБ ОШИБКАХ.

   Все ошибки периода времени исполнения могут возникать и  в
период компиляции; поэтому применяется единая нумерация  оши-
бок. Превые номера отводятся под ошибки  периода  исполнения,
последние - под ошибки, которые могут возникнуть только в пе-
риод компиляции.


         ОШИБКИ ПЕРИОДА ИСПОЛНЕНИЯ.

   В сообщениях об ошибках, связанных с работой с  диском,  в
скобках указывается имя файла, при  выполнении  операции  над
которым возникла ошибка.


1. Reading unwritten data [имя файла]
         Чтение незаписанных данных.

   При работе системы эта ошибка может возникнуть при  чтении
с диска текстового файла с исходным текстом программы. Причи-
ной ошибки может быть либо то, что вы  пытаетесь  читать  не-
текстовый файл, либо то, что файл на диске испорчен.
   При выполнении программы эта  ошибка  может  возникнуть  в
случаях:

- при вызове п.Seek указана  позиция,  выходящая  за  пределы
файла.

- при чтении данных из  типизированного  файла  после  чтения
последней записи выполняется попытка чтения еще одной записи.

- при чтении данных из  нетипизированного  файла  выполняется
попытка чтения записи, не входящей в файл.

- файл на диске испорчен или имеет  не  тот  формат,  который
предполагает ваша программа.

- диск был заменен в период работы с файлами.

При чтении корректных текстовых файлов такая ошибка не возни-
кает.


2. Disk full (имя файла).
         Диск переполнен.

   На диске не осталось места для  записи  новой  информации.
Если эта ошибка возникла при сохранении текста  программы  на
диске, то, чтобы сохранить ваш файл, вы можете  записать  его
под именем уже имеющегося на диске файла ( этот файл при этом
будет потерян). Файл, на место которого  вы  производите  за-
пись, должен иметь размер не меньше, чем  записываемый  вами.
Перед записью вам нужно включить BAK-copy off.


3. Directory full.
         Оглавление диска переполнено.

   В оглавлении диска не осталось строк для записи информации
о новом файле или для расширения существующего файла.
Если эта ошибка возникла при сохранении текста  программы  на
диске, то, чтобы сохранить ваш файл, вы можете  записать  его
под именем уже имеющегося на диске файла ( этот файл при этом
будет потерян). Файл, на место которого  вы  производите  за-
пись, должен иметь размер не меньше, чем  записываемый  вами.
Перед записью вам нужно включить BAK-copy off.


4. File not found (имя файла).
                Файл не найден.

5. Disk read only (имя файла).
                Диск доступен только для чтения.

   Сделана попытка записи в файл, расположенный на диске, ко-
торый объявлен доступным только для чтения. Эта ошибка возни-
кает только если диск объявлен защищенным от записи с помощью
соответствующей команды CP/M. Если на диске  физически  уста-
новлена защита записи, то возникает  необрабатываемая  ошибка
ввода-вывода, после которой происходит рестарт ОС.


6. File read only.
                Файл доступен только для чтения.


7. Assign applied to predеfined variable.
                П.Assign применена к предопределенной
                переменной.

   Применение п.Assign к передопределенным файловым  перемен-
ным (Input, Output, Kbd, Lst) недопустимо. 


8. Assign was not executed.
                П.Assign не была выполнена.

   Сделана попытка выполнить операцию с  файловой  переменной
не обработанной п. Assign.



9. File not open (имя файла).
                Файл не открыт.


10. File is open (имя файла).
                Файл открыт.


11. File write only (имя файла).
                Файл доступен только для записи.

Файлы, доступные только для записи - это файлы на устройствах
или текстовые файлы, открытые п.Rewrite, Append.


12. Reset not allowed.
                Reset здесь недопустима.

П.Reset неприменима  к  файлам  на  устройствах,  допускающих
только запись.


13. Rewrite or Append not allowed.
                Rewrite и Append здесь недопустимы.

Эти процедуры неприменимы к файлам на  устройствах,  допуска-
ющих только чтение; п.Append  применима  только  к  текстовым
файлам.


14. Invalid file format (имя файла).
                Неправильный формат файла.

При открытии для чтения типизированного  файла  обнаружилось,
что в первых  6  байтах  содержится  некорректная  информация
(первые 2 байта типизированного файла должны содержать  длину
записи, а следующие 4  -  количество  записей;  эти  значения
должны быть согласованы с физической длиной файла).


15. Invalid number format (имя файла).
                Неправильный формат числа.

Число, читаемое из текстового файла, имеет неправильный  фор-
мат: содержит недопустимые литеры или имеет значение, выходя-
щее за допустимые пределы.


16. Invalid argument.
                Неправильный аргумент.

Аргумент стандартной арифметической процедуры или функции вы-
ходит за область допустимых значений.


17. Division by zero.
                Деление на ноль.


18. Arithmetic overflow.
                Арифметическое переполнение.


19. Heap overflow.
                Переполнение кучи.


20. Invalid heap operation.
                Недопустимая операция над кучей.

При освобождении памяти в куче указан адрес, который не может
принадлежать куче.


21. Stack overflow.
                Переполнение стека.

* при работе системы: память, отведенная для аппаратного сте-
ка и стека include-файлов, переполнилась.  Возможно,  следует
попытаться уменьшить глубину вложенности include-файлов.

*   при   выполнении   Паскаль-программы:   при    выполнении
п.CheckStack обнаружено, что в стеке недостаточно  свободного
места. Увеличьте размер стека с помощью директивы {$S...}.



22. Value out of range.
                Значение за пределами диапазона.

* при работе системы: в описании типизированной константы на-
чальное значение выходит за пределы диапазона,  определяемого
типом.

* при выполнении Паскаль-программы: сделана попытка присвоить
переменной значение, выходящее за пределы диапазона,  опреде-
ляемого типом, или индекс массива выходит за допустимые  гра-
ницы. Эта ошибка может возникнуть только в том случае,  когда
соответствующий фрагмент программы скомпилирован с директивой
{$R+}. Если компиляция велась с директивой {$R-}  (устанавли-
вается по умолчанию), то такая ошибка останется  незамеченной
и может вызвать неприятные последствия. 






              ОШИБКИ ПЕРИОДА КОМПИЛЯЦИИ


23. Verify error.
                Ошибка сравнения.

При выполнении команды "Verify" основного меню обнаружено не-
совпадение текста в памяти с текстом на диске.  На  экране  в
этот момент виден номер строки, при сравнении которой обнару-
жено несовпадение.


24. Out of memory.
                Не хватает памяти.

Компилятору не хватает памяти для выполнения  компиляции  или
результирующая программа оказывается слишком большой  (размер
кода превосходит 48К или размер поля  переменных  превосходит
64К). Если у вас возникла такая ошибка, попытайтесь  последо-
вательно сделать следующее:

* проверьте правильность вашей  программы  (возможно,  непра-
вильно указана длина массива, и ему требуется  слишком  много
памяти)

* сократите часть исходного текста программы, хранящуюся  при
компиляции в памяти (вы можете хранить в памяти только дирек-
тиву {$I имя файла})

* при загрузке системы  исключите  модуль  с  сообщениями  об
ошибках

* попытайтесь уменьшить количество и длину одновременно  дос-
тупных идентификаторов.


25. Invalid compiler directive.
                Неправильная директива компилятора.


26. String constant exceeds line.
             Строковая константа выходит за пределы  строки.

Скорее всего, вы забыли поставить закрывающий апостроф.



27. Error in integer constant.
                Ошибка в целой константе.



28. End of text within comment.
                Конец текста внутри комментария.

Скорее всего, вы забыли поставить закрывающую скобку } или *)



29. End of file within comment.
                Конец файла внутри комментария.

Комментарий, начавшийся внутри include-файла,  должен  внутри
него и закончиться. Скорее всего, вы забыли поставить  закры-
вающую комментарий скобку } или *).


30. Directive exceeds line.
                Директива  компилятора  выходит  за   пределы
                строки

Директива компилятора должна целиком лежать в пределах  одной
строки. Скорее всего, вы забыли поставить закрывающую  дирек-
тиву скобку } или *).


31. Illegal character.
                Недопустимая литера.

Следующие ошибки возникают в тех случаях, когда по синтаксису
Паскаля в данной точке программы должна стоять указанная лек-
сема или конструкция, а ее нет.  Довольно  часто  эти  ошибки
вызваны не тем,  что  вы  пропустили  указанную  лексему  или
конструкцию, а тем, что вы ошиблись в одной из соседних  лек-
сем.


32. Identifier expected.
                Ожидается идентификатор.


33. Label expected.
                Ожидается метка.


34. Expression expected.
                Ожидается выражение.


35. Constant expression expected.
                Ожидается константное выражение.


36. Constant pointer expression expected.
                Ожидается константное выражение указательного
                типа.


37. Integer expression expected.
                Ожидается выражение целого типа.


38. Ordinal type identifier expected.
                Ожидается идентификатор упорядоченного типа.


39. Ordinal type expression expected.
                Ожидается выражение упорядоченного типа.


40. Boolean expression expected.
                Ожидается выражение типа boolean.


41. Variable declaration Expected.
                Ожидается описание переменной.


42. Variable Expected.
                Ожидается переменная.


43. Record variable expected.
                Ожидается переменная типа записи.


44. Statement Expected.
                Ожидается оператор.


45. Type identifier expected.
                Ожидается идентификатор типа.


46. "Begin" expected.
                Ожидается "Begin".


47. "Do" expected.
                Ожидается "do."


48. "End" expected.
                Ожидается "End".


49. "Implementation" expected.
                Ожидается  "Implementation".


50. "Interface" expected.
                Ожидается "Interface".


51. "Of" expected.
                Ожидается "Of".


52. "Then" expected.
                Ожидается "then".


53. "To" expected.
                Ожидается "To".


54. "Until" expected.
                Ожидается "Until".


55. "(" expected.
                Ожидается "(".


56. ")" expected.
                Ожидается ")".


57. "[" expected.
                Ожидается "[".


58. "]" expected.
                Ожидается "]".


59. "=" expected.
                Ожидается "=".


60. "," expected.
                Ожидается ",".


61. ";" expected.
                Ожидается ";".


62. ":" expected.
                Ожидается ":".


63. "." expected.
                Ожидается ".".


64. "+" expected.
                Ожидается "+".


65. ".." expected.
                Ожидается "..".


66. ":=" expected.
                Ожидается ":=".


67. "=" or ":" expected.
                Ожидается "=" или ":".


68. "Absolute" applied to variable list.
                "Absolute" применена к списку переменных.

Конструкция "Absolute" может быть применена  только  к  одной
переменной, но не к списку переменных.


69. Type mismatch.
                Несоответствие типов.

Эта ошибка возникает в одном из следующих случаев:

* тип выражения в правой части оператора присваивания  несов-
местим относительно присваивания с типом переменной  в  левой
части

* тип выражения - фактического  параметра,  передаваемого  по
значению, несовместим относительно присваивания с типом  фор-
мального параметра

* тип переменной - фактического параметра,  передаваемого  по
ссылке, неидентичен типу формального параметра

* тип индексного выражения несовместим с типом индекса.


70. Too many variables.
                Слишком много переменных.

Размер поля локальных переменных процедуры превысил 64К.


71. Duplicated identifier or label.
                Повторяющийся идентификатор или метка.


72. Duplicated field identifier.
                Повторяющийся идентификатор поля.


73. Unknown  identifier.
                Неизвестный идентификатор.


74. Unknown qualified identifier.
                Неизвестный уточненный идентификатор.


75. Undefined identifier or label.
                Неопределенный идентификатор или метка.


76. Invalid type definition.
                Неправильное определение типа.


77. Invalid index type.
                Недопустимый тип индекса.


78. Invalid set base type.
                Недопустимый базовый тип множества.


79. Invalid subrange base type.
                Недопустимый базовый тип отрезка.


80. Invalid type of constant.
                Недопустимый тип константы.


81. Invalid order of fields.
                Неправильный порядок полей.

В типизированной константе-записи могут быть  заданы  не  все
поля, но задаваемые поля должны идти в том же порядке, в  ко-
тором они идут в описании типа записи.


82. Invalid length of string.
                Неправильная длина строки.

Если в типизированной константе значение типа array  of  char
задается строковой константой, то строковая константа  должна
содержать ровно столько литер,  сколько  указано  в  описании
массива.


83. Invalid absolute clause or inline element.
                Неправильная absolute-конструкция или элемент
                оператора inline.


84. Invalid control variable.
                Недопустимая управляющая переменная.

В цикле for управляющая переменная  (параметр  цикла)  должна
быть статической ссылкой на  переменную  (можно  использовать
x[5], но нельзя использовать x[i]).


85. Invalid function result type.
                Недопустимый тип результата функции.

Результат функции может иметь только простой  тип,  строковый
тип или тип множества; все остальные типы недопустимы.


86. Uncompatible bounds types.
                Несовместимые типы границ.

В описании типа отрезка границы заданы константными выражени-
ями несовместимых типов.


87. Lower bound greater then upper bounds.
                Нижняя граница больше , чем верхняя.

В описании типа отрезка значение константного выражения,  за-
дающего нижнюю границу, больше значения константного  выраже-
ния, задающего верхнюю границу.


88. "<" is not allowed here
                "<" здесь недопустимо.

В элементе inline-оператора задано адресное константное выра-
жение, а оно обязательно занимает слово.


89. File components may not be file.
                Компоненты файла не могут быть файлами.

Тип компоненты файлового типа  не  может  быть  файловым  или
структурным типом, содержащим файловую компоненту.


90. Illegal goto.
                Недопустимый goto.

Оператор goto передает управление  снаружи  внутрь  оператора
for или оператора with.


91. Header does not match previous definition.
                Заголовок не соответствует первоначальному.

В повторном описании процедуры или функции,  ранее  описанной
как forward, заголовок не соответствует первоначальному (т.е.
в новом заголовке присутствует список параметров (и  тип  ре-
зультата для функции), и он не совпадает с заданным в  перво-
начальном заголовке).


92. Undefined label <метка>.
                Неопределенная метка.

<Метка> была описана в разделе описаний  меток,  но в разделе
операторов не появилось ее определяющего вхождения.


93. Undefined forward <идентификатор>.
                Неопределенное описание forward-описание.

В блоке было forward-описание процедуры (функции) < идентифи-
катор>, но не было определяющего ее описания. 


94. Not defined identifier <идентификатор>.
                Неопределенный идентификатор.


95. Not type identifier <идентификатор>.
                Не идентификатор типа.

Контекст, в котором появился <идентификатор>, требует иденти-
фикатора типа, а <идентификатор> таковым не является.


96. Unit used in previously declared unit.
                Модуль используется в ранее объявленном моду-
                ле.

В предложении uses модуль А, используемый в модуле B,  указан
после модуля B.


97. <имя файла>: invalid unit format.
                Недопустимый формат модуля.


98. Recursive call of nonrecursive procedure <идентификатор>
                Рекурсивный вызов нерекурсивной процедуры.

Обнаружен рекурсивный (прямой или через цепочку) вызов проце-
дуры <идентификатор>, а эта процедура скомпилирована как  не-
рекурсивная (ее описание находится вне области  действия  ди-
рективы {$A-}).


99. No programm to run.
                Нет программы для выполнения.

Перед выполнением команды Run основного меню программа не бы-
ла скомпилирована в память (или после последней компиляции  в
нее были внесены изменения).


100. Illegal item.
                Недопустимая лексема.


101. Error in expression.
                Ошибка в выражении.


102. Operand types do not match operator.
                Типы операндов не соответствуют операции.


103. Invalid value typecast.
                Недопустимый преобразователь типа значения.


104. Invalid index.
                Недопустимый индекс.


105. Unknown field identifier.
                Неизвестный идентификатор типа.


106. Invalid type of identifier.
                Недопустимый тип идентификатора.


107. Variable reference expected.
                Ожидается ссылка на переменную.


108. Invalid index type.
                Недопустимый тип индекса.


109. File is not allowed here.
                Файл здесь недопустим.

Сделана попытка присвоить значение файлового типа или  струк-
турного типа , содержащего файловый тип.


110. Error in compiler.
                Ошибка в компиляторе.

Если у вас возникнет такая ошибка -  пожалуйста  сообщите  об
этом разработчикам; сохраните и передайте при этом программу,
при компиляции которой возникла такая ошибка.


111. Text file expected.
                Ожидается текстовый файловый тип.

Файловая переменная в этом месте должна иметь тип Text.


112. File variable expected.
                Ожидается файловая переменная.


113. Undefined type.
                Неопределенный тип.

Сделана попытка применить операцию разыменования к  нетипизи-
рованной указательной переменной типа Pointer.


114. File mast be untyped.
                Файл должен быть нетипизированный.

Файловая переменная в этом месте должна быть нетипизированная
(иметь тип file).


115. Pointer variable expected.
                Ожидается переменная указательного типа.


116. File mast be typed or text.
                Файл должен быть текстовым или типизированным

Файловая переменная в этом месте должна  быть  типизированной
или текстовой (иметь тип file of <тип> или Text.


117. String variable expected.
                Ожидается переменная строкового типа.


118. Cannot read variable of this type.
                Невозможно чтение переменной этого типа.


119. Cannot write value of this type.
                Невозможна запись значения этого типа.

В списке вывода п.Write или Writeln указано  выражение  типа,
который не может быть записан в текстовый файл.


120. Wrong PC.
                Неправильный PC.

PC,  указанный  при   выполнении   команды   основного   меню
"Find-run-time error" указывает точку вне программы.




















